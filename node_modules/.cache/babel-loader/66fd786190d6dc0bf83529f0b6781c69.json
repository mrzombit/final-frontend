{"ast":null,"code":"import * as P from '@react-pdf/primitives';\nimport { isNil, matchPercent } from '@react-pdf/fns';\nimport absPath from 'abs-svg-path';\nimport parsePath from 'parse-svg-path';\nimport normalizePath from 'normalize-svg-path';\nimport colorString from 'color-string';\nimport _extends from '@babel/runtime/helpers/extends';\nvar renderPath = function renderPath(ctx, node) {\n  var _node$props;\n  var d = (_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.d;\n  if (d) ctx.path(node.props.d);\n};\nvar KAPPA$3 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nvar renderRect = function renderRect(ctx, node) {\n  var _node$props, _node$props2, _node$props3, _node$props4, _node$props5, _node$props6;\n  var x = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.x) || 0;\n  var y = ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.y) || 0;\n  var rx = ((_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.rx) || 0;\n  var ry = ((_node$props4 = node.props) === null || _node$props4 === void 0 ? void 0 : _node$props4.ry) || 0;\n  var width = ((_node$props5 = node.props) === null || _node$props5 === void 0 ? void 0 : _node$props5.width) || 0;\n  var height = ((_node$props6 = node.props) === null || _node$props6 === void 0 ? void 0 : _node$props6.height) || 0;\n  if (!width || !height) return;\n  if (rx && ry) {\n    var krx = rx * KAPPA$3;\n    var kry = ry * KAPPA$3;\n    ctx.moveTo(x + rx, y);\n    ctx.lineTo(x - rx + width, y);\n    ctx.bezierCurveTo(x - rx + width + krx, y, x + width, y + ry - kry, x + width, y + ry);\n    ctx.lineTo(x + width, y + height - ry);\n    ctx.bezierCurveTo(x + width, y + height - ry + kry, x - rx + width + krx, y + height, x - rx + width, y + height);\n    ctx.lineTo(x + rx, y + height);\n    ctx.bezierCurveTo(x + rx - krx, y + height, x, y + height - ry + kry, x, y + height - ry);\n    ctx.lineTo(x, y + ry);\n    ctx.bezierCurveTo(x, y + ry - kry, x + rx - krx, y, x + rx, y);\n  } else {\n    ctx.moveTo(x, y);\n    ctx.lineTo(x + width, y);\n    ctx.lineTo(x + width, y + height);\n    ctx.lineTo(x, y + height);\n  }\n  ctx.closePath();\n};\nvar renderLine$1 = function renderLine(ctx, node) {\n  var _ref = node.props || {},\n    x1 = _ref.x1,\n    x2 = _ref.x2,\n    y1 = _ref.y1,\n    y2 = _ref.y2;\n  ctx.moveTo(x1, y1);\n  ctx.lineTo(x2, y2);\n};\nvar renderGroup = function renderGroup() {\n  // noop\n};\nvar KAPPA$2 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nvar drawEllipse = function drawEllipse(ctx, cx, cy, rx, ry) {\n  var x = cx - rx;\n  var y = cy - ry;\n  var ox = rx * KAPPA$2;\n  var oy = ry * KAPPA$2;\n  var xe = x + rx * 2;\n  var ye = y + ry * 2;\n  var xm = x + rx;\n  var ym = y + ry;\n  ctx.moveTo(x, ym);\n  ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n  ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n  ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n  ctx.closePath();\n};\nvar renderEllipse = function renderEllipse(ctx, node) {\n  var _ref = node.props || {},\n    cx = _ref.cx,\n    cy = _ref.cy,\n    rx = _ref.rx,\n    ry = _ref.ry;\n  drawEllipse(ctx, cx, cy, rx, ry);\n};\nvar renderCircle = function renderCircle(ctx, node) {\n  var _node$props, _node$props2, _node$props3;\n  var cx = (_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.cx;\n  var cy = (_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.cy;\n  var r = (_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.r;\n  drawEllipse(ctx, cx, cy, r, r);\n};\nvar renderGlyphs = function renderGlyphs(ctx, glyphs, positions, x, y, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var scale = 1000 / ctx._fontSize;\n  var unitsPerEm = ctx._font.font.unitsPerEm || 1000;\n  var advanceWidthScale = 1000 / unitsPerEm;\n\n  // Glyph encoding and positioning\n  var encodedGlyphs = ctx._font.encodeGlyphs(glyphs);\n  var encodedPositions = positions.map(function (pos, i) {\n    return {\n      xAdvance: pos.xAdvance * scale,\n      yAdvance: pos.yAdvance * scale,\n      xOffset: pos.xOffset,\n      yOffset: pos.yOffset,\n      advanceWidth: glyphs[i].advanceWidth * advanceWidthScale\n    };\n  });\n  return ctx._glyphs(encodedGlyphs, encodedPositions, x, y, options);\n};\nvar renderRun$1 = function renderRun(ctx, run) {\n  var runAdvanceWidth = run.xAdvance;\n  var _run$attributes = run.attributes,\n    font = _run$attributes.font,\n    fontSize = _run$attributes.fontSize,\n    color = _run$attributes.color,\n    opacity = _run$attributes.opacity;\n  ctx.fillColor(color);\n  ctx.fillOpacity(opacity);\n  if (font.sbix || font.COLR && font.CPAL) {\n    ctx.save();\n    ctx.translate(0, -run.ascent);\n    for (var i = 0; i < run.glyphs.length; i += 1) {\n      var position = run.positions[i];\n      var glyph = run.glyphs[i];\n      ctx.save();\n      ctx.translate(position.xOffset, position.yOffset);\n      glyph.render(ctx, fontSize);\n      ctx.restore();\n      ctx.translate(position.xAdvance, position.yAdvance);\n    }\n    ctx.restore();\n  } else {\n    ctx.font(typeof font.name === 'string' ? font.name : font, fontSize);\n    try {\n      renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);\n    } catch (error) {\n      console.log(error);\n    }\n  }\n  ctx.translate(runAdvanceWidth, 0);\n};\nvar renderSpan = function renderSpan(ctx, line, textAnchor, dominantBaseline) {\n  var _line$box, _line$box2, _line$runs$, _line$runs$2, _line$runs$2$attribut;\n  ctx.save();\n  var x = ((_line$box = line.box) === null || _line$box === void 0 ? void 0 : _line$box.x) || 0;\n  var y = ((_line$box2 = line.box) === null || _line$box2 === void 0 ? void 0 : _line$box2.y) || 0;\n  var font = (_line$runs$ = line.runs[0]) === null || _line$runs$ === void 0 ? void 0 : _line$runs$.attributes.font;\n  var scale = ((_line$runs$2 = line.runs[0]) === null || _line$runs$2 === void 0 ? void 0 : (_line$runs$2$attribut = _line$runs$2.attributes) === null || _line$runs$2$attribut === void 0 ? void 0 : _line$runs$2$attribut.scale) || 1;\n  var width = line.xAdvance;\n  var ascent = font.ascent * scale;\n  var xHeight = font.xHeight * scale;\n  var descent = font.descent * scale;\n  var capHeight = font.capHeight * scale;\n  var xTranslate = x;\n  var yTranslate = y;\n  switch (textAnchor) {\n    case 'middle':\n      xTranslate = x - width / 2;\n      break;\n    case 'end':\n      xTranslate = x - width;\n      break;\n    default:\n      xTranslate = x;\n      break;\n  }\n  switch (dominantBaseline) {\n    case 'middle':\n    case 'central':\n      yTranslate = y + capHeight / 2;\n      break;\n    case 'hanging':\n      yTranslate = y + capHeight;\n      break;\n    case 'mathematical':\n      yTranslate = y + xHeight;\n      break;\n    case 'text-after-edge':\n      yTranslate = y + descent;\n      break;\n    case 'text-before-edge':\n      yTranslate = y + ascent;\n      break;\n    default:\n      yTranslate = y;\n      break;\n  }\n  ctx.translate(xTranslate, yTranslate);\n  line.runs.forEach(function (run) {\n    return renderRun$1(ctx, run);\n  });\n  ctx.restore();\n};\nvar renderSvgText = function renderSvgText(ctx, node) {\n  node.children.forEach(function (span) {\n    return renderSpan(ctx, span.lines[0], span.props.textAnchor, span.props.dominantBaseline);\n  });\n};\nvar pairs = function pairs(values) {\n  var result = [];\n  for (var i = 0; i < values.length; i += 2) {\n    result.push([values[i], values[i + 1]]);\n  }\n  return result;\n};\n\n/**\n * Parse svg-like points into number arrays\n *\n * @param {String} points string ex. \"20,30 50,60\"\n * @return {Array} points array ex. [[20, 30], [50, 60]]\n */\nvar parsePoints = function parsePoints(points) {\n  var values = (points || '').trim().replace(/,/g, ' ').replace(/(\\d)-(\\d)/g, '$1 -$2').split(/\\s+/);\n  if (values.length % 2 !== 0) {\n    values = values.slice(0, -1);\n  }\n  values = values.map(parseFloat);\n  return pairs(values);\n};\nvar drawPolyline = function drawPolyline(ctx, points) {\n  if (points.length > 0) {\n    ctx.moveTo(points[0][0], points[0][1]);\n    points.slice(1).forEach(function (p) {\n      return ctx.lineTo(p[0], p[1]);\n    });\n  }\n};\nvar renderPolyline = function renderPolyline(ctx, node) {\n  var points = parsePoints(node.props.points || '');\n  drawPolyline(ctx, points);\n};\nvar renderPolygon = function renderPolygon(ctx, node) {\n  renderPolyline(ctx, node);\n  ctx.closePath();\n};\nvar renderImage$1 = function renderImage(ctx, node) {\n  if (!node.image.data) return;\n  var _node$props = node.props,\n    x = _node$props.x,\n    y = _node$props.y;\n  var _node$style = node.style,\n    width = _node$style.width,\n    height = _node$style.height,\n    opacity = _node$style.opacity;\n  var paddingTop = node.box.paddingLeft || 0;\n  var paddingLeft = node.box.paddingLeft || 0;\n  if (width === 0 || height === 0) {\n    console.warn(\"Image with src '\" + node.props.href + \"' skipped due to invalid dimensions\");\n    return;\n  }\n  ctx.save();\n  ctx.fillOpacity(opacity || 1).image(node.image.data, x + paddingLeft, y + paddingTop, {\n    width: width,\n    height: height\n  });\n  ctx.restore();\n};\n\n// This constant is used to approximate a symmetrical arc using a cubic\n// Bezier curve.\nvar KAPPA$1 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nvar clipNode = function clipNode(ctx, node) {\n  if (!node.style) return;\n  var _node$box = node.box,\n    top = _node$box.top,\n    left = _node$box.left,\n    width = _node$box.width,\n    height = _node$box.height;\n  var _node$style = node.style,\n    _node$style$borderTop = _node$style.borderTopLeftRadius,\n    borderTopLeftRadius = _node$style$borderTop === void 0 ? 0 : _node$style$borderTop,\n    _node$style$borderTop2 = _node$style.borderTopRightRadius,\n    borderTopRightRadius = _node$style$borderTop2 === void 0 ? 0 : _node$style$borderTop2,\n    _node$style$borderBot = _node$style.borderBottomRightRadius,\n    borderBottomRightRadius = _node$style$borderBot === void 0 ? 0 : _node$style$borderBot,\n    _node$style$borderBot2 = _node$style.borderBottomLeftRadius,\n    borderBottomLeftRadius = _node$style$borderBot2 === void 0 ? 0 : _node$style$borderBot2;\n\n  // Border top\n  var rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n  var ctr = rtr * (1.0 - KAPPA$1);\n  ctx.moveTo(left + rtr, top);\n  ctx.lineTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - ctr, top, left + width, top + ctr, left + width, top + rtr);\n\n  // Border right\n  var rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n  var cbr = rbr * (1.0 - KAPPA$1);\n  ctx.lineTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - cbr, left + width - cbr, top + height, left + width - rbr, top + height);\n\n  // Border bottom\n  var rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n  var cbl = rbl * (1.0 - KAPPA$1);\n  ctx.lineTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + cbl, top + height, left, top + height - cbl, left, top + height - rbl);\n\n  // Border left\n  var rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n  var ctl = rtl * (1.0 - KAPPA$1);\n  ctx.lineTo(left, top + rtl);\n  ctx.bezierCurveTo(left, top + ctl, left + ctl, top, left + rtl, top);\n  ctx.closePath();\n  ctx.clip();\n};\nvar applySingleTransformation = function applySingleTransformation(ctx, transform, origin) {\n  var operation = transform.operation,\n    value = transform.value;\n  switch (operation) {\n    case 'scale':\n      {\n        var scaleX = value[0],\n          scaleY = value[1];\n        ctx.scale(scaleX, scaleY, {\n          origin: origin\n        });\n        break;\n      }\n    case 'rotate':\n      {\n        var angle = value[0];\n        ctx.rotate(angle, {\n          origin: origin\n        });\n        break;\n      }\n    case 'translate':\n      {\n        var x = value[0],\n          y = value[1];\n        ctx.translate(x, y, {\n          origin: origin\n        });\n        break;\n      }\n    case 'skew':\n      {\n        var xAngle = value[0],\n          yAngle = value[1];\n        ctx.skew(xAngle, yAngle, {\n          origin: origin\n        });\n        break;\n      }\n    case 'matrix':\n      {\n        ctx.transform.apply(ctx, value);\n        break;\n      }\n    default:\n      {\n        console.error(\"Transform operation: '\" + operation + \"' doesn't supported\");\n      }\n  }\n};\nvar applyTransformations = function applyTransformations(ctx, node) {\n  var _node$style, _node$props;\n  if (!node.origin) return;\n  var origin = [node.origin.left, node.origin.top];\n  var operations = ((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.transform) || ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.transform) || [];\n  operations.forEach(function (operation) {\n    applySingleTransformation(ctx, operation, origin);\n  });\n};\nvar _boundingBoxFns;\n\n// From https://github.com/dy/svg-path-bounds/blob/master/index.js\nvar getPathBoundingBox = function getPathBoundingBox(node) {\n  var _node$props;\n  var path = normalizePath(absPath(parsePath(((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.d) || '')));\n  if (!path.length) return [0, 0, 0, 0];\n  var bounds = [Infinity, Infinity, -Infinity, -Infinity];\n  for (var i = 0, l = path.length; i < l; i += 1) {\n    var points = path[i].slice(1);\n    for (var j = 0; j < points.length; j += 2) {\n      if (points[j + 0] < bounds[0]) bounds[0] = points[j + 0];\n      if (points[j + 1] < bounds[1]) bounds[1] = points[j + 1];\n      if (points[j + 0] > bounds[2]) bounds[2] = points[j + 0];\n      if (points[j + 1] > bounds[3]) bounds[3] = points[j + 1];\n    }\n  }\n  return bounds;\n};\nvar getCircleBoundingBox = function getCircleBoundingBox(node) {\n  var _node$props2, _node$props3, _node$props4;\n  var r = ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.r) || 0;\n  var cx = ((_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.cx) || 0;\n  var cy = ((_node$props4 = node.props) === null || _node$props4 === void 0 ? void 0 : _node$props4.cy) || 0;\n  return [cx - r, cy - r, cx + r, cy + r];\n};\nvar getEllipseBoundingBox = function getEllipseBoundingBox(node) {\n  var _node$props5, _node$props6, _node$props7, _node$props8;\n  var cx = ((_node$props5 = node.props) === null || _node$props5 === void 0 ? void 0 : _node$props5.cx) || 0;\n  var cy = ((_node$props6 = node.props) === null || _node$props6 === void 0 ? void 0 : _node$props6.cy) || 0;\n  var rx = ((_node$props7 = node.props) === null || _node$props7 === void 0 ? void 0 : _node$props7.rx) || 0;\n  var ry = ((_node$props8 = node.props) === null || _node$props8 === void 0 ? void 0 : _node$props8.ry) || 0;\n  return [cx - rx, cy - ry, cx + rx, cy + ry];\n};\nvar getLineBoundingBox = function getLineBoundingBox(node) {\n  var _node$props9, _node$props10, _node$props11, _node$props12;\n  var x1 = ((_node$props9 = node.props) === null || _node$props9 === void 0 ? void 0 : _node$props9.x1) || 0;\n  var y1 = ((_node$props10 = node.props) === null || _node$props10 === void 0 ? void 0 : _node$props10.y1) || 0;\n  var x2 = ((_node$props11 = node.props) === null || _node$props11 === void 0 ? void 0 : _node$props11.x2) || 0;\n  var y2 = ((_node$props12 = node.props) === null || _node$props12 === void 0 ? void 0 : _node$props12.y2) || 0;\n  return [Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2), Math.max(y1, y2)];\n};\nvar getRectBoundingBox = function getRectBoundingBox(node) {\n  var _node$props13, _node$props14, _node$props15, _node$props16;\n  var x = ((_node$props13 = node.props) === null || _node$props13 === void 0 ? void 0 : _node$props13.x) || 0;\n  var y = ((_node$props14 = node.props) === null || _node$props14 === void 0 ? void 0 : _node$props14.y) || 0;\n  var width = ((_node$props15 = node.props) === null || _node$props15 === void 0 ? void 0 : _node$props15.width) || 0;\n  var height = ((_node$props16 = node.props) === null || _node$props16 === void 0 ? void 0 : _node$props16.height) || 0;\n  return [x, y, x + width, y + height];\n};\nvar max = function max(values) {\n  return Math.max.apply(Math, [-Infinity].concat(values));\n};\nvar min = function min(values) {\n  return Math.min.apply(Math, [Infinity].concat(values));\n};\nvar getPolylineBoundingBox = function getPolylineBoundingBox(node) {\n  var _node$props17;\n  var points = parsePoints(((_node$props17 = node.props) === null || _node$props17 === void 0 ? void 0 : _node$props17.points) || []);\n  var xValues = points.map(function (p) {\n    return p[0];\n  });\n  var yValues = points.map(function (p) {\n    return p[1];\n  });\n  return [min(xValues), min(yValues), max(xValues), max(yValues)];\n};\nvar boundingBoxFns = (_boundingBoxFns = {}, _boundingBoxFns[P.Rect] = getRectBoundingBox, _boundingBoxFns[P.Line] = getLineBoundingBox, _boundingBoxFns[P.Path] = getPathBoundingBox, _boundingBoxFns[P.Circle] = getCircleBoundingBox, _boundingBoxFns[P.Ellipse] = getEllipseBoundingBox, _boundingBoxFns[P.Polygon] = getPolylineBoundingBox, _boundingBoxFns[P.Polyline] = getPolylineBoundingBox, _boundingBoxFns);\nvar getBoundingBox = function getBoundingBox(node) {\n  var boundingBoxFn = boundingBoxFns[node.type];\n  return boundingBoxFn ? boundingBoxFn(node) : [0, 0, 0, 0];\n};\nvar _renderFns$1;\nvar setStrokeWidth = function setStrokeWidth(ctx, node) {\n  var _node$props;\n  var lineWidth = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.strokeWidth) || 0;\n  if (lineWidth) ctx.lineWidth(lineWidth);\n};\nvar setStrokeColor = function setStrokeColor(ctx, node) {\n  var _node$props2;\n  var strokeColor = ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.stroke) || null;\n  if (strokeColor) ctx.strokeColor(strokeColor);\n};\nvar setOpacity = function setOpacity(ctx, node) {\n  var _node$props3;\n  var opacity = ((_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.opacity) || null;\n  if (!isNil(opacity)) ctx.opacity(opacity);\n};\nvar setFillOpacity = function setFillOpacity(ctx, node) {\n  var _node$props4;\n  var fillOpacity = ((_node$props4 = node.props) === null || _node$props4 === void 0 ? void 0 : _node$props4.fillOpacity) || null;\n  if (!isNil(fillOpacity)) ctx.fillOpacity(fillOpacity);\n};\nvar setStrokeOpacity = function setStrokeOpacity(ctx, node) {\n  var _node$props5;\n  var strokeOpacity = ((_node$props5 = node.props) === null || _node$props5 === void 0 ? void 0 : _node$props5.strokeOpacity) || null;\n  if (!isNil(strokeOpacity)) ctx.strokeOpacity(strokeOpacity);\n};\nvar setLineJoin = function setLineJoin(ctx, node) {\n  var _node$props6;\n  var lineJoin = ((_node$props6 = node.props) === null || _node$props6 === void 0 ? void 0 : _node$props6.strokeLinejoin) || null;\n  if (lineJoin) ctx.lineJoin(lineJoin);\n};\nvar setLineCap = function setLineCap(ctx, node) {\n  var _node$props7;\n  var lineCap = ((_node$props7 = node.props) === null || _node$props7 === void 0 ? void 0 : _node$props7.strokeLinecap) || null;\n  if (lineCap) ctx.lineCap(lineCap);\n};\nvar setLineDash = function setLineDash(ctx, node) {\n  var _node$props8;\n  var value = ((_node$props8 = node.props) === null || _node$props8 === void 0 ? void 0 : _node$props8.strokeDasharray) || null;\n  if (value) ctx.dash(value.split(','));\n};\nvar hasLinearGradientFill = function hasLinearGradientFill(node) {\n  var _node$props9, _node$props9$fill;\n  return ((_node$props9 = node.props) === null || _node$props9 === void 0 ? void 0 : (_node$props9$fill = _node$props9.fill) === null || _node$props9$fill === void 0 ? void 0 : _node$props9$fill.type) === P.LinearGradient;\n};\nvar hasRadialGradientFill = function hasRadialGradientFill(node) {\n  var _node$props10, _node$props10$fill;\n  return ((_node$props10 = node.props) === null || _node$props10 === void 0 ? void 0 : (_node$props10$fill = _node$props10.fill) === null || _node$props10$fill === void 0 ? void 0 : _node$props10$fill.type) === P.RadialGradient;\n};\n\n// Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L104\nvar setLinearGradientFill = function setLinearGradientFill(ctx, node) {\n  var _node$props11;\n  var bbox = getBoundingBox(node);\n  var gradient = ((_node$props11 = node.props) === null || _node$props11 === void 0 ? void 0 : _node$props11.fill) || null;\n  var x1 = gradient.props.x1 || 0;\n  var y1 = gradient.props.y1 || 0;\n  var x2 = gradient.props.x2 || 1;\n  var y2 = gradient.props.y2 || 0;\n  var m0 = bbox[2] - bbox[0];\n  var m3 = bbox[3] - bbox[1];\n  var m4 = bbox[0];\n  var m5 = bbox[1];\n  var gx1 = m0 * x1 + m4;\n  var gy1 = m3 * y1 + m5;\n  var gx2 = m0 * x2 + m4;\n  var gy2 = m3 * y2 + m5;\n  var grad = ctx.linearGradient(gx1, gy1, gx2, gy2);\n  gradient.children.forEach(function (stop) {\n    grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);\n  });\n  ctx.fill(grad);\n};\n\n// Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L155\nvar setRadialGradientFill = function setRadialGradientFill(ctx, node) {\n  var _node$props12;\n  var bbox = getBoundingBox(node);\n  var gradient = ((_node$props12 = node.props) === null || _node$props12 === void 0 ? void 0 : _node$props12.fill) || null;\n  var cx = gradient.props.cx || 0.5;\n  var cy = gradient.props.cy || 0.5;\n  var fx = gradient.props.fx || cx;\n  var fy = gradient.props.fy || cy;\n  var r = gradient.props.r || 0.5;\n  var m0 = bbox[2] - bbox[0];\n  var m3 = bbox[3] - bbox[1];\n  var m4 = bbox[0];\n  var m5 = bbox[1];\n  var gr = r * m0;\n  var gcx = m0 * cx + m4;\n  var gcy = m3 * cy + m5;\n  var gfx = m0 * fx + m4;\n  var gfy = m3 * fy + m5;\n  var grad = ctx.radialGradient(gfx, gfy, 0, gcx, gcy, gr);\n  gradient.children.forEach(function (stop) {\n    grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);\n  });\n  ctx.fill(grad);\n};\nvar setFillColor = function setFillColor(ctx, node) {\n  var _node$props13;\n  var fillColor = ((_node$props13 = node.props) === null || _node$props13 === void 0 ? void 0 : _node$props13.fill) || null;\n  if (fillColor) ctx.fillColor(fillColor);\n};\nvar setFill = function setFill(ctx, node) {\n  if (hasLinearGradientFill(node)) return setLinearGradientFill(ctx, node);\n  if (hasRadialGradientFill(node)) return setRadialGradientFill(ctx, node);\n  return setFillColor(ctx, node);\n};\nvar draw = function draw(ctx, node) {\n  var props = node.props || {};\n  if (props.fill && props.stroke) {\n    ctx.fillAndStroke(props.fillRule);\n  } else if (props.fill) {\n    ctx.fill(props.fillRule);\n  } else if (props.stroke) {\n    ctx.stroke();\n  } else {\n    ctx.save();\n    ctx.opacity(0);\n    ctx.fill(null);\n    ctx.restore();\n  }\n};\nvar noop = function noop() {};\nvar renderFns$1 = (_renderFns$1 = {}, _renderFns$1[P.Tspan] = noop, _renderFns$1[P.TextInstance] = noop, _renderFns$1[P.Path] = renderPath, _renderFns$1[P.Rect] = renderRect, _renderFns$1[P.Line] = renderLine$1, _renderFns$1[P.G] = renderGroup, _renderFns$1[P.Text] = renderSvgText, _renderFns$1[P.Circle] = renderCircle, _renderFns$1[P.Image] = renderImage$1, _renderFns$1[P.Ellipse] = renderEllipse, _renderFns$1[P.Polygon] = renderPolygon, _renderFns$1[P.Polyline] = renderPolyline, _renderFns$1);\nvar renderNode$1 = function renderNode(ctx, node) {\n  var renderFn = renderFns$1[node.type];\n  if (renderFns$1) {\n    renderFn(ctx, node);\n  } else {\n    console.warn(\"SVG node of type \" + node.type + \" is not currenty supported\");\n  }\n};\nvar drawNode = function drawNode(ctx, node) {\n  setLineCap(ctx, node);\n  setLineDash(ctx, node);\n  setLineJoin(ctx, node);\n  setStrokeWidth(ctx, node);\n  setStrokeColor(ctx, node);\n  setFill(ctx, node);\n  setStrokeOpacity(ctx, node);\n  setFillOpacity(ctx, node);\n  setOpacity(ctx, node);\n  applyTransformations(ctx, node);\n  renderNode$1(ctx, node);\n  draw(ctx, node);\n};\nvar clipPath = function clipPath(ctx, node) {\n  var _node$props14;\n  var value = (_node$props14 = node.props) === null || _node$props14 === void 0 ? void 0 : _node$props14.clipPath;\n  if (value) {\n    var children = value.children || [];\n    children.forEach(function (child) {\n      return renderNode$1(ctx, child);\n    });\n    ctx.clip();\n  }\n};\nvar drawChildren = function drawChildren(ctx, node) {\n  var children = node.children || [];\n  children.forEach(function (child) {\n    ctx.save();\n    clipPath(ctx, child);\n    drawNode(ctx, child);\n    drawChildren(ctx, child);\n    ctx.restore();\n  });\n};\nvar resolveAspectRatio = function resolveAspectRatio(ctx, node) {\n  var _node$box = node.box,\n    width = _node$box.width,\n    height = _node$box.height;\n  var _node$props15 = node.props,\n    viewBox = _node$props15.viewBox,\n    _node$props15$preserv = _node$props15.preserveAspectRatio,\n    preserveAspectRatio = _node$props15$preserv === void 0 ? {} : _node$props15$preserv;\n  var _preserveAspectRatio$ = preserveAspectRatio.meetOrSlice,\n    meetOrSlice = _preserveAspectRatio$ === void 0 ? 'meet' : _preserveAspectRatio$,\n    _preserveAspectRatio$2 = preserveAspectRatio.align,\n    align = _preserveAspectRatio$2 === void 0 ? 'xMidYMid' : _preserveAspectRatio$2;\n  if (viewBox == null || width == null || height == null) return;\n  var x = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.minX) || 0;\n  var y = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.minY) || 0;\n  var logicalWidth = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.maxX) || width;\n  var logicalHeight = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.maxY) || height;\n  var logicalRatio = logicalWidth / logicalHeight;\n  var physicalRatio = width / height;\n  var scaleX = width / logicalWidth;\n  var scaleY = height / logicalHeight;\n  if (align === 'none') {\n    ctx.scale(scaleX, scaleY);\n    ctx.translate(-x, -y);\n    return;\n  }\n  if (logicalRatio < physicalRatio && meetOrSlice === 'meet' || logicalRatio >= physicalRatio && meetOrSlice === 'slice') {\n    ctx.scale(scaleY, scaleY);\n    switch (align) {\n      case 'xMinYMin':\n      case 'xMinYMid':\n      case 'xMinYMax':\n        ctx.translate(-x, -y);\n        break;\n      case 'xMidYMin':\n      case 'xMidYMid':\n      case 'xMidYMax':\n        ctx.translate(-x - (logicalWidth - width * logicalHeight / height) / 2, -y);\n        break;\n      default:\n        ctx.translate(-x - (logicalWidth - width * logicalHeight / height), -y);\n    }\n  } else {\n    ctx.scale(scaleX, scaleX);\n    switch (align) {\n      case 'xMinYMin':\n      case 'xMidYMin':\n      case 'xMaxYMin':\n        ctx.translate(-x, -y);\n        break;\n      case 'xMinYMid':\n      case 'xMidYMid':\n      case 'xMaxYMid':\n        ctx.translate(-x, -y - (logicalHeight - height * logicalWidth / width) / 2);\n        break;\n      default:\n        ctx.translate(-x, -y - (logicalHeight - height * logicalWidth / width));\n    }\n  }\n};\nvar moveToOrigin = function moveToOrigin(ctx, node) {\n  var _node$box2 = node.box,\n    top = _node$box2.top,\n    left = _node$box2.left;\n  var paddingLeft = node.box.paddingLeft || 0;\n  var paddingTop = node.box.paddingTop || 0;\n  ctx.translate(left + paddingLeft, top + paddingTop);\n};\nvar renderSvg = function renderSvg(ctx, node) {\n  ctx.save();\n  clipNode(ctx, node);\n  moveToOrigin(ctx, node);\n  resolveAspectRatio(ctx, node);\n  drawChildren(ctx, node);\n  ctx.restore();\n};\nvar parseColor = function parseColor(hex) {\n  var parsed = colorString.get(hex);\n  var value = colorString.to.hex(parsed.value.slice(0, 3));\n  var opacity = parsed.value[3];\n  return {\n    value: value,\n    opacity: opacity\n  };\n};\n\n/* eslint-disable no-param-reassign */\nvar DEST_REGEXP = /^#.+/;\nvar isSrcId$1 = function isSrcId(src) {\n  return src.match(DEST_REGEXP);\n};\nvar renderAttachment = function renderAttachment(ctx, attachment) {\n  var _attachment$xOffset = attachment.xOffset,\n    xOffset = _attachment$xOffset === void 0 ? 0 : _attachment$xOffset,\n    _attachment$yOffset = attachment.yOffset,\n    yOffset = _attachment$yOffset === void 0 ? 0 : _attachment$yOffset,\n    width = attachment.width,\n    height = attachment.height,\n    image = attachment.image;\n  ctx.translate(-width + xOffset, -height + yOffset);\n  ctx.image(image, 0, 0, {\n    fit: [width, height],\n    align: 'center',\n    valign: 'bottom'\n  });\n};\nvar renderAttachments = function renderAttachments(ctx, run) {\n  ctx.save();\n  var font = run.attributes.font;\n  var space = font.glyphForCodePoint(0x20);\n  var objectReplacement = font.glyphForCodePoint(0xfffc);\n  var attachmentAdvance = 0;\n  for (var i = 0; i < run.glyphs.length; i += 1) {\n    var position = run.positions[i];\n    var glyph = run.glyphs[i];\n    attachmentAdvance += position.xAdvance || 0;\n    if (glyph.id === objectReplacement.id && run.attributes.attachment) {\n      ctx.translate(attachmentAdvance, position.yOffset || 0);\n      renderAttachment(ctx, run.attributes.attachment);\n      run.glyphs[i] = space;\n      attachmentAdvance = 0;\n    }\n  }\n  ctx.restore();\n};\nvar renderRun = function renderRun(ctx, run, options) {\n  var _run$attributes = run.attributes,\n    font = _run$attributes.font,\n    fontSize = _run$attributes.fontSize,\n    link = _run$attributes.link;\n  var color = parseColor(run.attributes.color);\n  var opacity = isNil(run.attributes.opacity) ? color.opacity : run.attributes.opacity;\n  var height = run.height,\n    descent = run.descent,\n    xAdvance = run.xAdvance;\n  if (options.outlineRuns) {\n    ctx.rect(0, -height, xAdvance, height).stroke();\n  }\n  ctx.fillColor(color.value);\n  ctx.fillOpacity(opacity);\n  if (link) {\n    if (isSrcId$1(link)) {\n      ctx.goTo(0, -height - descent, xAdvance, height, link.slice(1));\n    } else {\n      ctx.link(0, -height - descent, xAdvance, height, link);\n    }\n  }\n  renderAttachments(ctx, run);\n  if (font.sbix || font.COLR && font.CPAL) {\n    ctx.save();\n    ctx.translate(0, -run.ascent);\n    for (var i = 0; i < run.glyphs.length; i += 1) {\n      var position = run.positions[i];\n      var glyph = run.glyphs[i];\n      ctx.save();\n      ctx.translate(position.xOffset, position.yOffset);\n      glyph.render(ctx, fontSize);\n      ctx.restore();\n      ctx.translate(position.xAdvance, position.yAdvance);\n    }\n    ctx.restore();\n  } else {\n    ctx.font(typeof font.name === 'string' ? font.name : font, fontSize);\n    try {\n      renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);\n    } catch (error) {\n      console.log(error);\n    }\n  }\n  ctx.translate(xAdvance, 0);\n};\nvar renderBackground$1 = function renderBackground(ctx, rect, backgroundColor) {\n  var color = parseColor(backgroundColor);\n  ctx.save();\n  ctx.fillOpacity(color.opacity);\n  ctx.rect(rect.x, rect.y, rect.width, rect.height);\n  ctx.fill(color.value);\n  ctx.restore();\n};\nvar renderDecorationLine = function renderDecorationLine(ctx, line) {\n  ctx.save();\n  ctx.lineWidth(line.rect.height);\n  ctx.strokeOpacity(line.opacity);\n  if (/dashed/.test(line.style)) {\n    ctx.dash(3 * line.rect.height);\n  } else if (/dotted/.test(line.style)) {\n    ctx.dash(line.rect.height);\n  }\n  if (/wavy/.test(line.style)) {\n    var dist = Math.max(2, line.rect.height);\n    var step = 1.1 * dist;\n    var stepCount = Math.floor(line.rect.width / (2 * step));\n\n    // Adjust step to fill entire width\n    var remainingWidth = line.rect.width - stepCount * 2 * step;\n    var adjustment = remainingWidth / stepCount / 2;\n    step += adjustment;\n    var cp1y = line.rect.y + dist;\n    var cp2y = line.rect.y - dist;\n    var x = line.rect.x;\n    ctx.moveTo(line.rect.x, line.rect.y);\n    for (var i = 0; i < stepCount; i += 1) {\n      ctx.bezierCurveTo(x + step, cp1y, x + step, cp2y, x + 2 * step, line.rect.y);\n      x += 2 * step;\n    }\n  } else {\n    ctx.moveTo(line.rect.x, line.rect.y);\n    ctx.lineTo(line.rect.x + line.rect.width, line.rect.y);\n    if (/double/.test(line.style)) {\n      ctx.moveTo(line.rect.x, line.rect.y + line.rect.height * 2);\n      ctx.lineTo(line.rect.x + line.rect.width, line.rect.y + line.rect.height * 2);\n    }\n  }\n  ctx.stroke(line.color);\n  ctx.restore();\n};\nvar renderLine = function renderLine(ctx, line, options) {\n  var lineAscent = line.ascent;\n  if (options.outlineLines) {\n    ctx.rect(line.box.x, line.box.y, line.box.width, line.box.height).stroke();\n  }\n  ctx.save();\n  ctx.translate(line.box.x, line.box.y + lineAscent);\n  for (var i = 0; i < line.runs.length; i += 1) {\n    var run = line.runs[i];\n    var isLastRun = i === line.runs.length - 1;\n    if (run.attributes.backgroundColor) {\n      var overflowRight = isLastRun ? line.overflowRight : 0;\n      var backgroundRect = {\n        x: 0,\n        y: -lineAscent,\n        height: line.box.height,\n        width: run.xAdvance - overflowRight\n      };\n      renderBackground$1(ctx, backgroundRect, run.attributes.backgroundColor);\n    }\n    renderRun(ctx, run, options);\n  }\n  ctx.restore();\n  ctx.save();\n  ctx.translate(line.box.x, line.box.y);\n  for (var _i = 0; _i < line.decorationLines.length; _i += 1) {\n    var decorationLine = line.decorationLines[_i];\n    renderDecorationLine(ctx, decorationLine);\n  }\n  ctx.restore();\n};\nvar renderBlock = function renderBlock(ctx, block, options) {\n  block.forEach(function (line) {\n    renderLine(ctx, line, options);\n  });\n};\nvar renderText = function renderText(ctx, node) {\n  var _node$box2, _node$box3;\n  var _node$box = node.box,\n    top = _node$box.top,\n    left = _node$box.left;\n  var blocks = [node.lines];\n  var paddingTop = ((_node$box2 = node.box) === null || _node$box2 === void 0 ? void 0 : _node$box2.paddingTop) || 0;\n  var paddingLeft = ((_node$box3 = node.box) === null || _node$box3 === void 0 ? void 0 : _node$box3.paddingLeft) || 0;\n  var initialY = node.lines[0] ? node.lines[0].box.y : 0;\n  var offsetX = node.alignOffset || 0;\n  ctx.save();\n  ctx.translate(left + paddingLeft - offsetX, top + paddingTop - initialY);\n  blocks.forEach(function (block) {\n    renderBlock(ctx, block, {});\n  });\n  ctx.restore();\n};\nvar renderPage = function renderPage(ctx, node) {\n  var _node$props;\n  var _node$box = node.box,\n    width = _node$box.width,\n    height = _node$box.height;\n  var dpi = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.dpi) || 72;\n  var userUnit = dpi / 72;\n  ctx.addPage({\n    size: [width, height],\n    margin: 0,\n    userUnit: userUnit\n  });\n};\nvar renderNote = function renderNote(ctx, node) {\n  var _node$children, _node$style, _node$style2;\n  var _node$box = node.box,\n    top = _node$box.top,\n    left = _node$box.left;\n  var value = (node === null || node === void 0 ? void 0 : (_node$children = node.children) === null || _node$children === void 0 ? void 0 : _node$children[0].value) || '';\n  var color = ((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.backgroundColor) || null;\n  var borderWidth = ((_node$style2 = node.style) === null || _node$style2 === void 0 ? void 0 : _node$style2.borderWidth) || null;\n  ctx.note(left, top, 0, 0, value, {\n    color: color,\n    borderWidth: borderWidth\n  });\n};\nvar isNumeric = function isNumeric(n) {\n  return !Number.isNaN(parseFloat(n)) && Number.isFinite(n);\n};\nvar applyContainObjectFit = function applyContainObjectFit(cw, ch, iw, ih, px, py) {\n  var cr = cw / ch;\n  var ir = iw / ih;\n  var pxp = matchPercent(px);\n  var pyp = matchPercent(py);\n  var pxv = pxp ? pxp.percent : 0.5;\n  var pyv = pyp ? pyp.percent : 0.5;\n  if (cr > ir) {\n    var _height = ch;\n    var _width = _height * ir;\n    var _yOffset = isNumeric(py) ? py : 0;\n    var _xOffset = isNumeric(px) ? px : (cw - _width) * pxv;\n    return {\n      width: _width,\n      height: _height,\n      xOffset: _xOffset,\n      yOffset: _yOffset\n    };\n  }\n  var width = cw;\n  var height = width / ir;\n  var xOffset = isNumeric(px) ? px : 0;\n  var yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n  return {\n    width: width,\n    height: height,\n    yOffset: yOffset,\n    xOffset: xOffset\n  };\n};\nvar applyNoneObjectFit = function applyNoneObjectFit(cw, ch, iw, ih, px, py) {\n  var width = iw;\n  var height = ih;\n  var pxp = matchPercent(px);\n  var pyp = matchPercent(py);\n  var pxv = pxp ? pxp.percent : 0.5;\n  var pyv = pyp ? pyp.percent : 0.5;\n  var xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n  var yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n  return {\n    width: width,\n    height: height,\n    xOffset: xOffset,\n    yOffset: yOffset\n  };\n};\nvar applyCoverObjectFit = function applyCoverObjectFit(cw, ch, iw, ih, px, py) {\n  var ir = iw / ih;\n  var cr = cw / ch;\n  var pxp = matchPercent(px);\n  var pyp = matchPercent(py);\n  var pxv = pxp ? pxp.percent : 0.5;\n  var pyv = pyp ? pyp.percent : 0.5;\n  if (cr > ir) {\n    var _width2 = cw;\n    var _height2 = _width2 / ir;\n    var _xOffset2 = isNumeric(px) ? px : 0;\n    var _yOffset2 = isNumeric(py) ? py : (ch - _height2) * pyv;\n    return {\n      width: _width2,\n      height: _height2,\n      yOffset: _yOffset2,\n      xOffset: _xOffset2\n    };\n  }\n  var height = ch;\n  var width = height * ir;\n  var xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n  var yOffset = isNumeric(py) ? py : 0;\n  return {\n    width: width,\n    height: height,\n    xOffset: xOffset,\n    yOffset: yOffset\n  };\n};\nvar applyScaleDownObjectFit = function applyScaleDownObjectFit(cw, ch, iw, ih, px, py) {\n  var containDimension = applyContainObjectFit(cw, ch, iw, ih, px, py);\n  var noneDimension = applyNoneObjectFit(cw, ch, iw, ih, px, py);\n  return containDimension.width < noneDimension.width ? containDimension : noneDimension;\n};\nvar applyFillObjectFit = function applyFillObjectFit(cw, ch, px, py) {\n  return {\n    width: cw,\n    height: ch,\n    xOffset: matchPercent(px) ? 0 : px || 0,\n    yOffset: matchPercent(py) ? 0 : py || 0\n  };\n};\nvar resolveObjectFit = function resolveObjectFit(type, cw, ch, iw, ih, px, py) {\n  if (type === void 0) {\n    type = 'fill';\n  }\n  switch (type) {\n    case 'contain':\n      return applyContainObjectFit(cw, ch, iw, ih, px, py);\n    case 'cover':\n      return applyCoverObjectFit(cw, ch, iw, ih, px, py);\n    case 'none':\n      return applyNoneObjectFit(cw, ch, iw, ih, px, py);\n    case 'scale-down':\n      return applyScaleDownObjectFit(cw, ch, iw, ih, px, py);\n    default:\n      return applyFillObjectFit(cw, ch, px, py);\n  }\n};\nvar drawImage = function drawImage(ctx, node, options) {\n  var _node$style, _node$style2, _node$style3, _node$style4;\n  if (options === void 0) {\n    options = {};\n  }\n  var _node$box = node.box,\n    left = _node$box.left,\n    top = _node$box.top;\n  var opacity = (_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.opacity;\n  var objectFit = (_node$style2 = node.style) === null || _node$style2 === void 0 ? void 0 : _node$style2.objectFit;\n  var objectPositionX = (_node$style3 = node.style) === null || _node$style3 === void 0 ? void 0 : _node$style3.objectPositionX;\n  var objectPositionY = (_node$style4 = node.style) === null || _node$style4 === void 0 ? void 0 : _node$style4.objectPositionY;\n  var paddingTop = node.box.paddingTop || 0;\n  var paddingRight = node.box.paddingRight || 0;\n  var paddingBottom = node.box.paddingBottom || 0;\n  var paddingLeft = node.box.paddingLeft || 0;\n  var imageCache = options.imageCache || new Map();\n  var _resolveObjectFit = resolveObjectFit(objectFit, node.box.width - paddingLeft - paddingRight, node.box.height - paddingTop - paddingBottom, node.image.width, node.image.height, objectPositionX, objectPositionY),\n    width = _resolveObjectFit.width,\n    height = _resolveObjectFit.height,\n    xOffset = _resolveObjectFit.xOffset,\n    yOffset = _resolveObjectFit.yOffset;\n  if (node.image.data) {\n    if (width !== 0 && height !== 0) {\n      var cacheKey = node.image.key;\n      var image = imageCache.get(cacheKey) || ctx.embedImage(node.image.data);\n      if (cacheKey) imageCache.set(cacheKey, image);\n      var imageOpacity = isNil(opacity) ? 1 : opacity;\n      ctx.fillOpacity(imageOpacity).image(image, left + paddingLeft + xOffset, top + paddingTop + yOffset, {\n        width: width,\n        height: height\n      });\n    } else {\n      console.warn(\"Image with src '\" + JSON.stringify(node.props.src) + \"' skipped due to invalid dimensions\");\n    }\n  }\n};\nvar renderImage = function renderImage(ctx, node, options) {\n  ctx.save();\n  clipNode(ctx, node);\n  drawImage(ctx, node, options);\n  ctx.restore();\n};\nvar CONTENT_COLOR = '#a1c6e7';\nvar PADDING_COLOR = '#c4deb9';\nvar MARGIN_COLOR = '#f8cca1';\n\n// TODO: Draw debug boxes using clipping to enhance quality\n\nvar debugContent = function debugContent(ctx, node) {\n  var _node$box = node.box,\n    left = _node$box.left,\n    top = _node$box.top,\n    width = _node$box.width,\n    height = _node$box.height,\n    _node$box$paddingLeft = _node$box.paddingLeft,\n    paddingLeft = _node$box$paddingLeft === void 0 ? 0 : _node$box$paddingLeft,\n    _node$box$paddingTop = _node$box.paddingTop,\n    paddingTop = _node$box$paddingTop === void 0 ? 0 : _node$box$paddingTop,\n    _node$box$paddingRigh = _node$box.paddingRight,\n    paddingRight = _node$box$paddingRigh === void 0 ? 0 : _node$box$paddingRigh,\n    _node$box$paddingBott = _node$box.paddingBottom,\n    paddingBottom = _node$box$paddingBott === void 0 ? 0 : _node$box$paddingBott,\n    _node$box$borderLeftW = _node$box.borderLeftWidth,\n    borderLeftWidth = _node$box$borderLeftW === void 0 ? 0 : _node$box$borderLeftW,\n    _node$box$borderTopWi = _node$box.borderTopWidth,\n    borderTopWidth = _node$box$borderTopWi === void 0 ? 0 : _node$box$borderTopWi,\n    _node$box$borderRight = _node$box.borderRightWidth,\n    borderRightWidth = _node$box$borderRight === void 0 ? 0 : _node$box$borderRight,\n    _node$box$borderBotto = _node$box.borderBottomWidth,\n    borderBottomWidth = _node$box$borderBotto === void 0 ? 0 : _node$box$borderBotto;\n  ctx.fillColor(CONTENT_COLOR).opacity(0.5).rect(left + paddingLeft + borderLeftWidth, top + paddingTop + borderTopWidth, width - paddingLeft - paddingRight - borderRightWidth - borderLeftWidth, height - paddingTop - paddingBottom - borderTopWidth - borderBottomWidth).fill();\n};\nvar debugPadding = function debugPadding(ctx, node) {\n  var _node$box2 = node.box,\n    left = _node$box2.left,\n    top = _node$box2.top,\n    width = _node$box2.width,\n    height = _node$box2.height,\n    _node$box2$paddingLef = _node$box2.paddingLeft,\n    paddingLeft = _node$box2$paddingLef === void 0 ? 0 : _node$box2$paddingLef,\n    _node$box2$paddingTop = _node$box2.paddingTop,\n    paddingTop = _node$box2$paddingTop === void 0 ? 0 : _node$box2$paddingTop,\n    _node$box2$paddingRig = _node$box2.paddingRight,\n    paddingRight = _node$box2$paddingRig === void 0 ? 0 : _node$box2$paddingRig,\n    _node$box2$paddingBot = _node$box2.paddingBottom,\n    paddingBottom = _node$box2$paddingBot === void 0 ? 0 : _node$box2$paddingBot,\n    _node$box2$borderLeft = _node$box2.borderLeftWidth,\n    borderLeftWidth = _node$box2$borderLeft === void 0 ? 0 : _node$box2$borderLeft,\n    _node$box2$borderTopW = _node$box2.borderTopWidth,\n    borderTopWidth = _node$box2$borderTopW === void 0 ? 0 : _node$box2$borderTopW,\n    _node$box2$borderRigh = _node$box2.borderRightWidth,\n    borderRightWidth = _node$box2$borderRigh === void 0 ? 0 : _node$box2$borderRigh,\n    _node$box2$borderBott = _node$box2.borderBottomWidth,\n    borderBottomWidth = _node$box2$borderBott === void 0 ? 0 : _node$box2$borderBott;\n  ctx.fillColor(PADDING_COLOR).opacity(0.5);\n\n  // Padding top\n  ctx.rect(left + paddingLeft + borderLeftWidth, top + borderTopWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingTop).fill();\n\n  // Padding left\n  ctx.rect(left + borderLeftWidth, top + borderTopWidth, paddingLeft, height - borderTopWidth - borderBottomWidth).fill();\n\n  // Padding right\n  ctx.rect(left + width - paddingRight - borderRightWidth, top + borderTopWidth, paddingRight, height - borderTopWidth - borderBottomWidth).fill();\n\n  // Padding bottom\n  ctx.rect(left + paddingLeft + borderLeftWidth, top + height - paddingBottom - borderBottomWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingBottom).fill();\n};\nvar getMargin = function getMargin(box) {\n  var marginLeft = box.marginLeft === 'auto' ? 0 : box.marginLeft;\n  var marginTop = box.marginTop === 'auto' ? 0 : box.marginTop;\n  var marginRight = box.marginRight === 'auto' ? 0 : box.marginRight;\n  var marginBottom = box.marginBottom === 'auto' ? 0 : box.marginBottom;\n  return {\n    marginLeft: marginLeft,\n    marginTop: marginTop,\n    marginRight: marginRight,\n    marginBottom: marginBottom\n  };\n};\nvar debugMargin = function debugMargin(ctx, node) {\n  var _node$box3 = node.box,\n    left = _node$box3.left,\n    top = _node$box3.top,\n    width = _node$box3.width,\n    height = _node$box3.height;\n  var _getMargin = getMargin(node.box),\n    _getMargin$marginLeft = _getMargin.marginLeft,\n    marginLeft = _getMargin$marginLeft === void 0 ? 0 : _getMargin$marginLeft,\n    _getMargin$marginTop = _getMargin.marginTop,\n    marginTop = _getMargin$marginTop === void 0 ? 0 : _getMargin$marginTop,\n    _getMargin$marginRigh = _getMargin.marginRight,\n    marginRight = _getMargin$marginRigh === void 0 ? 0 : _getMargin$marginRigh,\n    _getMargin$marginBott = _getMargin.marginBottom,\n    marginBottom = _getMargin$marginBott === void 0 ? 0 : _getMargin$marginBott;\n  ctx.fillColor(MARGIN_COLOR).opacity(0.5);\n\n  // Margin top\n  ctx.rect(left, top - marginTop, width, marginTop).fill();\n\n  // Margin left\n  ctx.rect(left - marginLeft, top - marginTop, marginLeft, height + marginTop + marginBottom).fill();\n\n  // Margin right\n  ctx.rect(left + width, top - marginTop, marginRight, height + marginTop + marginBottom).fill();\n\n  // Margin bottom\n  ctx.rect(left, top + height, width, marginBottom).fill();\n};\nvar debugText = function debugText(ctx, node) {\n  var _node$box4 = node.box,\n    left = _node$box4.left,\n    top = _node$box4.top,\n    width = _node$box4.width,\n    height = _node$box4.height;\n  var _getMargin2 = getMargin(node.box),\n    _getMargin2$marginLef = _getMargin2.marginLeft,\n    marginLeft = _getMargin2$marginLef === void 0 ? 0 : _getMargin2$marginLef,\n    _getMargin2$marginTop = _getMargin2.marginTop,\n    marginTop = _getMargin2$marginTop === void 0 ? 0 : _getMargin2$marginTop,\n    _getMargin2$marginRig = _getMargin2.marginRight,\n    marginRight = _getMargin2$marginRig === void 0 ? 0 : _getMargin2$marginRig,\n    _getMargin2$marginBot = _getMargin2.marginBottom,\n    marginBottom = _getMargin2$marginBot === void 0 ? 0 : _getMargin2$marginBot;\n  var roundedWidth = Math.round(width + marginLeft + marginRight);\n  var roundedHeight = Math.round(height + marginTop + marginBottom);\n  ctx.fontSize(6).opacity(1).fillColor('black').text(roundedWidth + \" x \" + roundedHeight, left - marginLeft, Math.max(top - marginTop - 4, 1));\n};\nvar debugOrigin = function debugOrigin(ctx, node) {\n  if (node.origin) {\n    ctx.circle(node.origin.left, node.origin.top, 3).fill('red').circle(node.origin.left, node.origin.top, 5).stroke('red');\n  }\n};\nvar renderDebug = function renderDebug(ctx, node) {\n  var _node$props;\n  if (!((_node$props = node.props) !== null && _node$props !== void 0 && _node$props.debug)) return;\n  ctx.save();\n  debugContent(ctx, node);\n  debugPadding(ctx, node);\n  debugMargin(ctx, node);\n  debugText(ctx, node);\n  debugOrigin(ctx, node);\n  ctx.restore();\n};\nvar availableMethods = ['dash', 'clip', 'save', 'path', 'fill', 'font', 'text', 'rect', 'scale', 'moveTo', 'lineTo', 'stroke', 'rotate', 'circle', 'lineCap', 'opacity', 'ellipse', 'polygon', 'restore', 'lineJoin', 'fontSize', 'fillColor', 'lineWidth', 'translate', 'miterLimit', 'strokeColor', 'fillOpacity', 'roundedRect', 'fillAndStroke', 'strokeOpacity', 'bezierCurveTo', 'quadraticCurveTo', 'linearGradient', 'radialGradient'];\nvar painter = function painter(ctx) {\n  var p = availableMethods.reduce(function (acc, prop) {\n    var _extends2;\n    return _extends({}, acc, (_extends2 = {}, _extends2[prop] = function () {\n      ctx[prop].apply(ctx, arguments);\n      return p;\n    }, _extends2));\n  }, {});\n  return p;\n};\nvar renderCanvas = function renderCanvas(ctx, node) {\n  var _node$box = node.box,\n    top = _node$box.top,\n    left = _node$box.left,\n    width = _node$box.width,\n    height = _node$box.height;\n  var paddingTop = node.box.paddingTop || 0;\n  var paddingLeft = node.box.paddingLeft || 0;\n  var paddingRight = node.box.paddingRight || 0;\n  var paddingBottom = node.box.paddingBottom || 0;\n  var availableWidth = width - paddingLeft - paddingRight;\n  var availableHeight = height - paddingTop - paddingBottom;\n  if (!availableWidth || !availableHeight) {\n    console.warn('Canvas element has null width or height. Please provide valid values via the `style` prop in order to correctly render it.');\n  }\n  ctx.save().translate(left + paddingLeft, top + paddingTop);\n  if (node.props.paint) {\n    node.props.paint(painter(ctx), availableWidth, availableHeight);\n  }\n  ctx.restore();\n};\n\n// Ref: https://www.w3.org/TR/css-backgrounds-3/#borders\n\n// This constant is used to approximate a symmetrical arc using a cubic Bezier curve.\nvar KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nvar clipBorderTop = function clipBorderTop(ctx, layout, style, rtr, rtl) {\n  var top = layout.top,\n    left = layout.left,\n    width = layout.width,\n    height = layout.height;\n  var borderTopWidth = style.borderTopWidth,\n    borderRightWidth = style.borderRightWidth,\n    borderLeftWidth = style.borderLeftWidth;\n\n  // Clip outer top border edge\n  ctx.moveTo(left + rtl, top);\n  ctx.lineTo(left + width - rtr, top);\n\n  // Ellipse coefficients outer top right cap\n  var c0 = rtr * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + width - c0, top, left + width, top + c0, left + width, top + rtr);\n\n  // Move down in case the margin exceedes the radius\n  var topRightYCoord = top + Math.max(borderTopWidth, rtr);\n  ctx.lineTo(left + width, topRightYCoord);\n\n  // Clip inner top right cap\n  ctx.lineTo(left + width - borderRightWidth, topRightYCoord);\n\n  // Ellipse coefficients inner top right cap\n  var innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n  var innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n  var c1 = innerTopRightRadiusX * (1.0 - KAPPA);\n  var c2 = innerTopRightRadiusY * (1.0 - KAPPA);\n\n  // Clip inner top right cap\n  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c2, left + width - borderRightWidth - c1, top + borderTopWidth, left + width - borderRightWidth - innerTopRightRadiusX, top + borderTopWidth);\n\n  // Clip inner top border edge\n  ctx.lineTo(left + Math.max(rtl, borderLeftWidth), top + borderTopWidth);\n\n  // Ellipse coefficients inner top left cap\n  var innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n  var innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n  var c3 = innerTopLeftRadiusX * (1.0 - KAPPA);\n  var c4 = innerTopLeftRadiusY * (1.0 - KAPPA);\n  var topLeftYCoord = top + Math.max(borderTopWidth, rtl);\n\n  // Clip inner top left cap\n  ctx.bezierCurveTo(left + borderLeftWidth + c3, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c4, left + borderLeftWidth, topLeftYCoord);\n  ctx.lineTo(left, topLeftYCoord);\n\n  // Move down in case the margin exceedes the radius\n  ctx.lineTo(left, top + rtl);\n\n  // Ellipse coefficients outer top left cap\n  var c5 = rtl * (1.0 - KAPPA);\n\n  // Clip outer top left cap\n  ctx.bezierCurveTo(left, top + c5, left + c5, top, left + rtl, top);\n  ctx.closePath();\n  ctx.clip();\n\n  // Clip border top cap joins\n  if (borderRightWidth) {\n    var trSlope = -borderTopWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n  if (borderLeftWidth) {\n    var _trSlope = -borderTopWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, _trSlope * (-width / 2) + top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left + width, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\nvar fillBorderTop = function fillBorderTop(ctx, layout, style, rtr, rtl) {\n  var top = layout.top,\n    left = layout.left,\n    width = layout.width;\n  var borderTopColor = style.borderTopColor,\n    borderTopWidth = style.borderTopWidth,\n    borderTopStyle = style.borderTopStyle,\n    borderRightWidth = style.borderRightWidth,\n    borderLeftWidth = style.borderLeftWidth;\n  var c0 = rtl * (1.0 - KAPPA);\n  var c1 = rtr * (1.0 - KAPPA);\n  ctx.moveTo(left, top + Math.max(rtl, borderTopWidth));\n  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n  ctx.lineTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n  ctx.strokeColor(borderTopColor);\n  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderLeftWidth) * 2);\n  if (borderTopStyle === 'dashed') {\n    ctx.dash(borderTopWidth * 2, {\n      space: borderTopWidth * 1.2\n    });\n  } else if (borderTopStyle === 'dotted') {\n    ctx.dash(borderTopWidth, {\n      space: borderTopWidth * 1.2\n    });\n  }\n  ctx.stroke();\n  ctx.undash();\n};\nvar clipBorderRight = function clipBorderRight(ctx, layout, style, rtr, rbr) {\n  var top = layout.top,\n    left = layout.left,\n    width = layout.width,\n    height = layout.height;\n  var borderTopWidth = style.borderTopWidth,\n    borderRightWidth = style.borderRightWidth,\n    borderBottomWidth = style.borderBottomWidth;\n\n  // Clip outer right border edge\n  ctx.moveTo(left + width, top + rtr);\n  ctx.lineTo(left + width, top + height - rbr);\n\n  // Ellipse coefficients outer bottom right cap\n  var c0 = rbr * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height);\n\n  // Move left in case the margin exceedes the radius\n  var topBottomXCoord = left + width - Math.max(borderRightWidth, rbr);\n  ctx.lineTo(topBottomXCoord, top + height);\n\n  // Clip inner bottom right cap\n  ctx.lineTo(topBottomXCoord, top + height - borderBottomWidth);\n\n  // Ellipse coefficients inner bottom right cap\n  var innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n  var innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n  var c1 = innerBottomRightRadiusX * (1.0 - KAPPA);\n  var c2 = innerBottomRightRadiusY * (1.0 - KAPPA);\n\n  // Clip inner top right cap\n  ctx.bezierCurveTo(left + width - borderRightWidth - c1, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c2, left + width - borderRightWidth, top + height - Math.max(rbr, borderBottomWidth));\n\n  // Clip inner right border edge\n  ctx.lineTo(left + width - borderRightWidth, top + Math.max(rtr, borderTopWidth));\n\n  // Ellipse coefficients inner top right cap\n  var innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n  var innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n  var c3 = innerTopRightRadiusX * (1.0 - KAPPA);\n  var c4 = innerTopRightRadiusY * (1.0 - KAPPA);\n  var topRightXCoord = left + width - Math.max(rtr, borderRightWidth);\n\n  // Clip inner top left cap\n  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c4, left + width - borderRightWidth - c3, top + borderTopWidth, topRightXCoord, top + borderTopWidth);\n  ctx.lineTo(topRightXCoord, top);\n\n  // Move right in case the margin exceedes the radius\n  ctx.lineTo(left + width - rtr, top);\n\n  // Ellipse coefficients outer top right cap\n  var c5 = rtr * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + width - c5, top, left + width, top + c5, left + width, top + rtr);\n  ctx.closePath();\n  ctx.clip();\n\n  // Clip border right cap joins\n  if (borderTopWidth) {\n    var trSlope = -borderTopWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n  if (borderBottomWidth) {\n    var brSlope = borderBottomWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\nvar fillBorderRight = function fillBorderRight(ctx, layout, style, rtr, rbr) {\n  var top = layout.top,\n    left = layout.left,\n    width = layout.width,\n    height = layout.height;\n  var borderRightColor = style.borderRightColor,\n    borderRightStyle = style.borderRightStyle,\n    borderRightWidth = style.borderRightWidth,\n    borderTopWidth = style.borderTopWidth,\n    borderBottomWidth = style.borderBottomWidth;\n  var c0 = rbr * (1.0 - KAPPA);\n  var c1 = rtr * (1.0 - KAPPA);\n  ctx.moveTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n  ctx.lineTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height);\n  ctx.strokeColor(borderRightColor);\n  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderBottomWidth) * 2);\n  if (borderRightStyle === 'dashed') {\n    ctx.dash(borderRightWidth * 2, {\n      space: borderRightWidth * 1.2\n    });\n  } else if (borderRightStyle === 'dotted') {\n    ctx.dash(borderRightWidth, {\n      space: borderRightWidth * 1.2\n    });\n  }\n  ctx.stroke();\n  ctx.undash();\n};\nvar clipBorderBottom = function clipBorderBottom(ctx, layout, style, rbl, rbr) {\n  var top = layout.top,\n    left = layout.left,\n    width = layout.width,\n    height = layout.height;\n  var borderBottomWidth = style.borderBottomWidth,\n    borderRightWidth = style.borderRightWidth,\n    borderLeftWidth = style.borderLeftWidth;\n\n  // Clip outer top border edge\n  ctx.moveTo(left + width - rbr, top + height);\n  ctx.lineTo(left + rbl, top + height);\n\n  // Ellipse coefficients outer top right cap\n  var c0 = rbl * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n\n  // Move up in case the margin exceedes the radius\n  var bottomLeftYCoord = top + height - Math.max(borderBottomWidth, rbl);\n  ctx.lineTo(left, bottomLeftYCoord);\n\n  // Clip inner bottom left cap\n  ctx.lineTo(left + borderLeftWidth, bottomLeftYCoord);\n\n  // Ellipse coefficients inner top right cap\n  var innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n  var innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n  var c1 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n  var c2 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n\n  // Clip inner bottom left cap\n  ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c2, left + borderLeftWidth + c1, top + height - borderBottomWidth, left + borderLeftWidth + innerBottomLeftRadiusX, top + height - borderBottomWidth);\n\n  // Clip inner bottom border edge\n  ctx.lineTo(left + width - Math.max(rbr, borderRightWidth), top + height - borderBottomWidth);\n\n  // Ellipse coefficients inner top left cap\n  var innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n  var innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n  var c3 = innerBottomRightRadiusX * (1.0 - KAPPA);\n  var c4 = innerBottomRightRadiusY * (1.0 - KAPPA);\n  var bottomRightYCoord = top + height - Math.max(borderBottomWidth, rbr);\n\n  // Clip inner top left cap\n  ctx.bezierCurveTo(left + width - borderRightWidth - c3, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c4, left + width - borderRightWidth, bottomRightYCoord);\n  ctx.lineTo(left + width, bottomRightYCoord);\n\n  // Move down in case the margin exceedes the radius\n  ctx.lineTo(left + width, top + height - rbr);\n\n  // Ellipse coefficients outer top left cap\n  var c5 = rbr * (1.0 - KAPPA);\n\n  // Clip outer top left cap\n  ctx.bezierCurveTo(left + width, top + height - c5, left + width - c5, top + height, left + width - rbr, top + height);\n  ctx.closePath();\n  ctx.clip();\n\n  // Clip border bottom cap joins\n  if (borderRightWidth) {\n    var brSlope = borderBottomWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n  if (borderLeftWidth) {\n    var trSlope = -borderBottomWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left + width, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\nvar fillBorderBottom = function fillBorderBottom(ctx, layout, style, rbl, rbr) {\n  var top = layout.top,\n    left = layout.left,\n    width = layout.width,\n    height = layout.height;\n  var borderBottomColor = style.borderBottomColor,\n    borderBottomStyle = style.borderBottomStyle,\n    borderBottomWidth = style.borderBottomWidth,\n    borderRightWidth = style.borderRightWidth,\n    borderLeftWidth = style.borderLeftWidth;\n  var c0 = rbl * (1.0 - KAPPA);\n  var c1 = rbr * (1.0 - KAPPA);\n  ctx.moveTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - c1, left + width - c1, top + height, left + width - rbr, top + height);\n  ctx.lineTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n  ctx.strokeColor(borderBottomColor);\n  ctx.lineWidth(Math.max(borderBottomWidth, borderRightWidth, borderLeftWidth) * 2);\n  if (borderBottomStyle === 'dashed') {\n    ctx.dash(borderBottomWidth * 2, {\n      space: borderBottomWidth * 1.2\n    });\n  } else if (borderBottomStyle === 'dotted') {\n    ctx.dash(borderBottomWidth, {\n      space: borderBottomWidth * 1.2\n    });\n  }\n  ctx.stroke();\n  ctx.undash();\n};\nvar clipBorderLeft = function clipBorderLeft(ctx, layout, style, rbl, rtl) {\n  var top = layout.top,\n    left = layout.left,\n    width = layout.width,\n    height = layout.height;\n  var borderTopWidth = style.borderTopWidth,\n    borderLeftWidth = style.borderLeftWidth,\n    borderBottomWidth = style.borderBottomWidth;\n\n  // Clip outer left border edge\n  ctx.moveTo(left, top + height - rbl);\n  ctx.lineTo(left, top + rtl);\n\n  // Ellipse coefficients outer top left cap\n  var c0 = rtl * (1.0 - KAPPA);\n\n  // Clip outer top left cap\n  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n\n  // Move right in case the margin exceedes the radius\n  var topLeftCoordX = left + Math.max(borderLeftWidth, rtl);\n  ctx.lineTo(topLeftCoordX, top);\n\n  // Clip inner top left cap\n  ctx.lineTo(topLeftCoordX, top + borderTopWidth);\n\n  // Ellipse coefficients inner top left cap\n  var innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n  var innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n  var c1 = innerTopLeftRadiusX * (1.0 - KAPPA);\n  var c2 = innerTopLeftRadiusY * (1.0 - KAPPA);\n\n  // Clip inner top right cap\n  ctx.bezierCurveTo(left + borderLeftWidth + c1, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c2, left + borderLeftWidth, top + Math.max(rtl, borderTopWidth));\n\n  // Clip inner left border edge\n  ctx.lineTo(left + borderLeftWidth, top + height - Math.max(rbl, borderBottomWidth));\n\n  // Ellipse coefficients inner bottom left cap\n  var innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n  var innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n  var c3 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n  var c4 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n  var bottomLeftXCoord = left + Math.max(rbl, borderLeftWidth);\n\n  // Clip inner top left cap\n  ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c4, left + borderLeftWidth + c3, top + height - borderBottomWidth, bottomLeftXCoord, top + height - borderBottomWidth);\n  ctx.lineTo(bottomLeftXCoord, top + height);\n\n  // Move left in case the margin exceedes the radius\n  ctx.lineTo(left + rbl, top + height);\n\n  // Ellipse coefficients outer top right cap\n  var c5 = rbl * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + c5, top + height, left, top + height - c5, left, top + height - rbl);\n  ctx.closePath();\n  ctx.clip();\n\n  // Clip border right cap joins\n  if (borderBottomWidth) {\n    var trSlope = -borderBottomWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left + width, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n  if (borderBottomWidth) {\n    var _trSlope2 = -borderTopWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, _trSlope2 * (-width / 2) + top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\nvar fillBorderLeft = function fillBorderLeft(ctx, layout, style, rbl, rtl) {\n  var top = layout.top,\n    left = layout.left,\n    height = layout.height;\n  var borderLeftColor = style.borderLeftColor,\n    borderLeftStyle = style.borderLeftStyle,\n    borderLeftWidth = style.borderLeftWidth,\n    borderTopWidth = style.borderTopWidth,\n    borderBottomWidth = style.borderBottomWidth;\n  var c0 = rbl * (1.0 - KAPPA);\n  var c1 = rtl * (1.0 - KAPPA);\n  ctx.moveTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n  ctx.lineTo(left, top + rtl);\n  ctx.bezierCurveTo(left, top + c1, left + c1, top, left + rtl, top);\n  ctx.strokeColor(borderLeftColor);\n  ctx.lineWidth(Math.max(borderLeftWidth, borderTopWidth, borderBottomWidth) * 2);\n  if (borderLeftStyle === 'dashed') {\n    ctx.dash(borderLeftWidth * 2, {\n      space: borderLeftWidth * 1.2\n    });\n  } else if (borderLeftStyle === 'dotted') {\n    ctx.dash(borderLeftWidth, {\n      space: borderLeftWidth * 1.2\n    });\n  }\n  ctx.stroke();\n  ctx.undash();\n};\nvar shouldRenderBorders = function shouldRenderBorders(node) {\n  return node.box && (node.box.borderTopWidth || node.box.borderRightWidth || node.box.borderBottomWidth || node.box.borderLeftWidth);\n};\nvar renderBorders = function renderBorders(ctx, node) {\n  if (!shouldRenderBorders(node)) return;\n  var _node$box = node.box,\n    width = _node$box.width,\n    height = _node$box.height,\n    borderTopWidth = _node$box.borderTopWidth,\n    borderLeftWidth = _node$box.borderLeftWidth,\n    borderRightWidth = _node$box.borderRightWidth,\n    borderBottomWidth = _node$box.borderBottomWidth;\n  var _node$style = node.style,\n    opacity = _node$style.opacity,\n    _node$style$borderTop = _node$style.borderTopLeftRadius,\n    borderTopLeftRadius = _node$style$borderTop === void 0 ? 0 : _node$style$borderTop,\n    _node$style$borderTop2 = _node$style.borderTopRightRadius,\n    borderTopRightRadius = _node$style$borderTop2 === void 0 ? 0 : _node$style$borderTop2,\n    _node$style$borderBot = _node$style.borderBottomLeftRadius,\n    borderBottomLeftRadius = _node$style$borderBot === void 0 ? 0 : _node$style$borderBot,\n    _node$style$borderBot2 = _node$style.borderBottomRightRadius,\n    borderBottomRightRadius = _node$style$borderBot2 === void 0 ? 0 : _node$style$borderBot2,\n    _node$style$borderTop3 = _node$style.borderTopColor,\n    borderTopColor = _node$style$borderTop3 === void 0 ? 'black' : _node$style$borderTop3,\n    _node$style$borderTop4 = _node$style.borderTopStyle,\n    borderTopStyle = _node$style$borderTop4 === void 0 ? 'solid' : _node$style$borderTop4,\n    _node$style$borderLef = _node$style.borderLeftColor,\n    borderLeftColor = _node$style$borderLef === void 0 ? 'black' : _node$style$borderLef,\n    _node$style$borderLef2 = _node$style.borderLeftStyle,\n    borderLeftStyle = _node$style$borderLef2 === void 0 ? 'solid' : _node$style$borderLef2,\n    _node$style$borderRig = _node$style.borderRightColor,\n    borderRightColor = _node$style$borderRig === void 0 ? 'black' : _node$style$borderRig,\n    _node$style$borderRig2 = _node$style.borderRightStyle,\n    borderRightStyle = _node$style$borderRig2 === void 0 ? 'solid' : _node$style$borderRig2,\n    _node$style$borderBot3 = _node$style.borderBottomColor,\n    borderBottomColor = _node$style$borderBot3 === void 0 ? 'black' : _node$style$borderBot3,\n    _node$style$borderBot4 = _node$style.borderBottomStyle,\n    borderBottomStyle = _node$style$borderBot4 === void 0 ? 'solid' : _node$style$borderBot4;\n  var style = {\n    borderTopColor: borderTopColor,\n    borderTopWidth: borderTopWidth,\n    borderTopStyle: borderTopStyle,\n    borderLeftColor: borderLeftColor,\n    borderLeftWidth: borderLeftWidth,\n    borderLeftStyle: borderLeftStyle,\n    borderRightColor: borderRightColor,\n    borderRightWidth: borderRightWidth,\n    borderRightStyle: borderRightStyle,\n    borderBottomColor: borderBottomColor,\n    borderBottomWidth: borderBottomWidth,\n    borderBottomStyle: borderBottomStyle,\n    borderTopLeftRadius: borderTopLeftRadius,\n    borderTopRightRadius: borderTopRightRadius,\n    borderBottomLeftRadius: borderBottomLeftRadius,\n    borderBottomRightRadius: borderBottomRightRadius\n  };\n  var rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n  var rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n  var rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n  var rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n  ctx.save();\n  ctx.strokeOpacity(opacity);\n  if (borderTopWidth) {\n    ctx.save();\n    clipBorderTop(ctx, node.box, style, rtr, rtl);\n    fillBorderTop(ctx, node.box, style, rtr, rtl);\n    ctx.restore();\n  }\n  if (borderRightWidth) {\n    ctx.save();\n    clipBorderRight(ctx, node.box, style, rtr, rbr);\n    fillBorderRight(ctx, node.box, style, rtr, rbr);\n    ctx.restore();\n  }\n  if (borderBottomWidth) {\n    ctx.save();\n    clipBorderBottom(ctx, node.box, style, rbl, rbr);\n    fillBorderBottom(ctx, node.box, style, rbl, rbr);\n    ctx.restore();\n  }\n  if (borderLeftWidth) {\n    ctx.save();\n    clipBorderLeft(ctx, node.box, style, rbl, rtl);\n    fillBorderLeft(ctx, node.box, style, rbl, rtl);\n    ctx.restore();\n  }\n  ctx.restore();\n};\nvar drawBackground = function drawBackground(ctx, node) {\n  var _node$style;\n  var _node$box = node.box,\n    top = _node$box.top,\n    left = _node$box.left,\n    width = _node$box.width,\n    height = _node$box.height;\n  var color = parseColor(node.style.backgroundColor);\n  var nodeOpacity = isNil((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.opacity) ? 1 : node.style.opacity;\n  var opacity = Math.min(color.opacity, nodeOpacity);\n  ctx.fillOpacity(opacity).fillColor(color.value).rect(left, top, width, height).fill();\n};\nvar renderBackground = function renderBackground(ctx, node) {\n  var _node$style2;\n  var hasBackground = !!node.box && !!((_node$style2 = node.style) !== null && _node$style2 !== void 0 && _node$style2.backgroundColor);\n  if (hasBackground) {\n    ctx.save();\n    clipNode(ctx, node);\n    drawBackground(ctx, node);\n    ctx.restore();\n  }\n};\nvar isSrcId = function isSrcId(value) {\n  return /^#.+/.test(value);\n};\nvar setLink = function setLink(ctx, node) {\n  var props = node.props || {};\n  var _node$box = node.box,\n    top = _node$box.top,\n    left = _node$box.left,\n    width = _node$box.width,\n    height = _node$box.height;\n  var src = props.src || props.href;\n  if (src) {\n    var isId = isSrcId(src);\n    var method = isId ? 'goTo' : 'link';\n    var value = isId ? src.slice(1) : src;\n    ctx[method](left, top, width, height, value);\n  }\n};\nvar setDestination = function setDestination(ctx, node) {\n  var _node$props;\n  if ((_node$props = node.props) !== null && _node$props !== void 0 && _node$props.id) {\n    ctx.addNamedDestination(node.props.id, 'XYZ', null, node.box.top, null);\n  }\n};\nvar _renderFns;\nvar isRecursiveNode = function isRecursiveNode(node) {\n  return node.type !== P.Text && node.type !== P.Svg;\n};\nvar renderChildren = function renderChildren(ctx, node, options) {\n  ctx.save();\n  if (node.box) {\n    ctx.translate(node.box.left, node.box.top);\n  }\n  var children = node.children || [];\n  var renderChild = function renderChild(child) {\n    return renderNode(ctx, child, options);\n  };\n  children.forEach(renderChild);\n  ctx.restore();\n};\nvar renderFns = (_renderFns = {}, _renderFns[P.Text] = renderText, _renderFns[P.Note] = renderNote, _renderFns[P.Image] = renderImage, _renderFns[P.Canvas] = renderCanvas, _renderFns[P.Svg] = renderSvg, _renderFns[P.Link] = setLink, _renderFns);\nvar renderNode = function renderNode(ctx, node, options) {\n  var _node$style;\n  var overflowHidden = ((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.overflow) === 'hidden';\n  var shouldRenderChildren = isRecursiveNode(node);\n  if (node.type === P.Page) renderPage(ctx, node);\n  ctx.save();\n  if (overflowHidden) clipNode(ctx, node);\n  applyTransformations(ctx, node);\n  renderBackground(ctx, node);\n  renderBorders(ctx, node);\n  var renderFn = renderFns[node.type];\n  if (renderFn) renderFn(ctx, node, options);\n  if (shouldRenderChildren) renderChildren(ctx, node, options);\n  setDestination(ctx, node);\n  renderDebug(ctx, node);\n  ctx.restore();\n};\n\n/* eslint-disable no-param-reassign */\n\nvar setPDFMetadata = function setPDFMetadata(target) {\n  return function (key, value) {\n    if (value) target.info[key] = value;\n  };\n};\n\n/**\n * Set document instance metadata\n *\n * @param {Object} ctx document instance\n * @param {Object} doc document root\n */\nvar addMetadata = function addMetadata(ctx, doc) {\n  var setProp = setPDFMetadata(ctx);\n  var props = doc.props || {};\n  var title = props.title || null;\n  var author = props.author || null;\n  var subject = props.subject || null;\n  var keywords = props.keywords || null;\n  var creator = props.creator || 'react-pdf';\n  var producer = props.producer || 'react-pdf';\n  setProp('Title', title);\n  setProp('Author', author);\n  setProp('Subject', subject);\n  setProp('Keywords', keywords);\n  setProp('Creator', creator);\n  setProp('Producer', producer);\n};\n\n/* eslint-disable no-param-reassign */\n\nvar addNodeBookmark = function addNodeBookmark(ctx, node, pageNumber, registry) {\n  var _node$props;\n  var bookmark = (_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.bookmark;\n  if (bookmark) {\n    var title = bookmark.title,\n      parent = bookmark.parent,\n      expanded = bookmark.expanded,\n      zoom = bookmark.zoom,\n      fit = bookmark.fit;\n    var outline = registry[parent] || ctx.outline;\n    var top = bookmark.top || node.box.top;\n    var left = bookmark.left || node.box.left;\n    var instance = outline.addItem(title, {\n      pageNumber: pageNumber,\n      expanded: expanded,\n      top: top,\n      left: left,\n      zoom: zoom,\n      fit: fit\n    });\n    registry[bookmark.ref] = instance;\n  }\n  if (!node.children) return;\n  node.children.forEach(function (child) {\n    return addNodeBookmark(ctx, child, pageNumber, registry);\n  });\n};\nvar addBookmarks = function addBookmarks(ctx, root) {\n  var registry = {};\n  var pages = root.children || [];\n  pages.forEach(function (page, i) {\n    addNodeBookmark(ctx, page, i, registry);\n  });\n};\nvar render = function render(ctx, doc) {\n  var pages = doc.children || [];\n  var options = {\n    imageCache: new Map()\n  };\n  addMetadata(ctx, doc);\n  pages.forEach(function (page) {\n    return renderNode(ctx, page, options);\n  });\n  addBookmarks(ctx, doc);\n  ctx.end();\n  return ctx;\n};\nexport { render as default };","map":null,"metadata":{},"sourceType":"module"}