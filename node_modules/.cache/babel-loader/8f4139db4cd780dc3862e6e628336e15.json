{"ast":null,"code":"//\n//                              list\n//                            ┌──────┐\n//             ┌──────────────┼─head │\n//             │              │ tail─┼──────────────┐\n//             │              └──────┘              │\n//             ▼                                    ▼\n//            item        item        item        item\n//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐\n//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │\n//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null\n//          ├──────┤    ├──────┤    ├──────┤    ├──────┤\n//          │ data │    │ data │    │ data │    │ data │\n//          └──────┘    └──────┘    └──────┘    └──────┘\n//\n\nfunction createItem(data) {\n  return {\n    prev: null,\n    next: null,\n    data: data\n  };\n}\nfunction allocateCursor(node, prev, next) {\n  var cursor;\n  if (cursors !== null) {\n    cursor = cursors;\n    cursors = cursors.cursor;\n    cursor.prev = prev;\n    cursor.next = next;\n    cursor.cursor = node.cursor;\n  } else {\n    cursor = {\n      prev: prev,\n      next: next,\n      cursor: node.cursor\n    };\n  }\n  node.cursor = cursor;\n  return cursor;\n}\nfunction releaseCursor(node) {\n  var cursor = node.cursor;\n  node.cursor = cursor.cursor;\n  cursor.prev = null;\n  cursor.next = null;\n  cursor.cursor = cursors;\n  cursors = cursor;\n}\nvar cursors = null;\nvar List = function List() {\n  this.cursor = null;\n  this.head = null;\n  this.tail = null;\n};\nList.createItem = createItem;\nList.prototype.createItem = createItem;\nList.prototype.updateCursors = function (prevOld, prevNew, nextOld, nextNew) {\n  var cursor = this.cursor;\n  while (cursor !== null) {\n    if (cursor.prev === prevOld) {\n      cursor.prev = prevNew;\n    }\n    if (cursor.next === nextOld) {\n      cursor.next = nextNew;\n    }\n    cursor = cursor.cursor;\n  }\n};\nList.prototype.getSize = function () {\n  var size = 0;\n  var cursor = this.head;\n  while (cursor) {\n    size++;\n    cursor = cursor.next;\n  }\n  return size;\n};\nList.prototype.fromArray = function (array) {\n  var cursor = null;\n  this.head = null;\n  for (var i = 0; i < array.length; i++) {\n    var item = createItem(array[i]);\n    if (cursor !== null) {\n      cursor.next = item;\n    } else {\n      this.head = item;\n    }\n    item.prev = cursor;\n    cursor = item;\n  }\n  this.tail = cursor;\n  return this;\n};\nList.prototype.toArray = function () {\n  var cursor = this.head;\n  var result = [];\n  while (cursor) {\n    result.push(cursor.data);\n    cursor = cursor.next;\n  }\n  return result;\n};\nList.prototype.toJSON = List.prototype.toArray;\nList.prototype.isEmpty = function () {\n  return this.head === null;\n};\nList.prototype.first = function () {\n  return this.head && this.head.data;\n};\nList.prototype.last = function () {\n  return this.tail && this.tail.data;\n};\nList.prototype.each = function (fn, context) {\n  var item;\n  if (context === undefined) {\n    context = this;\n  }\n\n  // push cursor\n  var cursor = allocateCursor(this, null, this.head);\n  while (cursor.next !== null) {\n    item = cursor.next;\n    cursor.next = item.next;\n    fn.call(context, item.data, item, this);\n  }\n\n  // pop cursor\n  releaseCursor(this);\n};\nList.prototype.forEach = List.prototype.each;\nList.prototype.eachRight = function (fn, context) {\n  var item;\n  if (context === undefined) {\n    context = this;\n  }\n\n  // push cursor\n  var cursor = allocateCursor(this, this.tail, null);\n  while (cursor.prev !== null) {\n    item = cursor.prev;\n    cursor.prev = item.prev;\n    fn.call(context, item.data, item, this);\n  }\n\n  // pop cursor\n  releaseCursor(this);\n};\nList.prototype.forEachRight = List.prototype.eachRight;\nList.prototype.reduce = function (fn, initialValue, context) {\n  var item;\n  if (context === undefined) {\n    context = this;\n  }\n\n  // push cursor\n  var cursor = allocateCursor(this, null, this.head);\n  var acc = initialValue;\n  while (cursor.next !== null) {\n    item = cursor.next;\n    cursor.next = item.next;\n    acc = fn.call(context, acc, item.data, item, this);\n  }\n\n  // pop cursor\n  releaseCursor(this);\n  return acc;\n};\nList.prototype.reduceRight = function (fn, initialValue, context) {\n  var item;\n  if (context === undefined) {\n    context = this;\n  }\n\n  // push cursor\n  var cursor = allocateCursor(this, this.tail, null);\n  var acc = initialValue;\n  while (cursor.prev !== null) {\n    item = cursor.prev;\n    cursor.prev = item.prev;\n    acc = fn.call(context, acc, item.data, item, this);\n  }\n\n  // pop cursor\n  releaseCursor(this);\n  return acc;\n};\nList.prototype.nextUntil = function (start, fn, context) {\n  if (start === null) {\n    return;\n  }\n  var item;\n  if (context === undefined) {\n    context = this;\n  }\n\n  // push cursor\n  var cursor = allocateCursor(this, null, start);\n  while (cursor.next !== null) {\n    item = cursor.next;\n    cursor.next = item.next;\n    if (fn.call(context, item.data, item, this)) {\n      break;\n    }\n  }\n\n  // pop cursor\n  releaseCursor(this);\n};\nList.prototype.prevUntil = function (start, fn, context) {\n  if (start === null) {\n    return;\n  }\n  var item;\n  if (context === undefined) {\n    context = this;\n  }\n\n  // push cursor\n  var cursor = allocateCursor(this, start, null);\n  while (cursor.prev !== null) {\n    item = cursor.prev;\n    cursor.prev = item.prev;\n    if (fn.call(context, item.data, item, this)) {\n      break;\n    }\n  }\n\n  // pop cursor\n  releaseCursor(this);\n};\nList.prototype.some = function (fn, context) {\n  var cursor = this.head;\n  if (context === undefined) {\n    context = this;\n  }\n  while (cursor !== null) {\n    if (fn.call(context, cursor.data, cursor, this)) {\n      return true;\n    }\n    cursor = cursor.next;\n  }\n  return false;\n};\nList.prototype.map = function (fn, context) {\n  var result = new List();\n  var cursor = this.head;\n  if (context === undefined) {\n    context = this;\n  }\n  while (cursor !== null) {\n    result.appendData(fn.call(context, cursor.data, cursor, this));\n    cursor = cursor.next;\n  }\n  return result;\n};\nList.prototype.filter = function (fn, context) {\n  var result = new List();\n  var cursor = this.head;\n  if (context === undefined) {\n    context = this;\n  }\n  while (cursor !== null) {\n    if (fn.call(context, cursor.data, cursor, this)) {\n      result.appendData(cursor.data);\n    }\n    cursor = cursor.next;\n  }\n  return result;\n};\nList.prototype.clear = function () {\n  this.head = null;\n  this.tail = null;\n};\nList.prototype.copy = function () {\n  var result = new List();\n  var cursor = this.head;\n  while (cursor !== null) {\n    result.insert(createItem(cursor.data));\n    cursor = cursor.next;\n  }\n  return result;\n};\nList.prototype.prepend = function (item) {\n  //      head\n  //    ^\n  // item\n  this.updateCursors(null, item, this.head, item);\n\n  // insert to the beginning of the list\n  if (this.head !== null) {\n    // new item <- first item\n    this.head.prev = item;\n\n    // new item -> first item\n    item.next = this.head;\n  } else {\n    // if list has no head, then it also has no tail\n    // in this case tail points to the new item\n    this.tail = item;\n  }\n\n  // head always points to new item\n  this.head = item;\n  return this;\n};\nList.prototype.prependData = function (data) {\n  return this.prepend(createItem(data));\n};\nList.prototype.append = function (item) {\n  return this.insert(item);\n};\nList.prototype.appendData = function (data) {\n  return this.insert(createItem(data));\n};\nList.prototype.insert = function (item, before) {\n  if (before !== undefined && before !== null) {\n    // prev   before\n    //      ^\n    //     item\n    this.updateCursors(before.prev, item, before, item);\n    if (before.prev === null) {\n      // insert to the beginning of list\n      if (this.head !== before) {\n        throw new Error('before doesn\\'t belong to list');\n      }\n\n      // since head points to before therefore list doesn't empty\n      // no need to check tail\n      this.head = item;\n      before.prev = item;\n      item.next = before;\n      this.updateCursors(null, item);\n    } else {\n      // insert between two items\n      before.prev.next = item;\n      item.prev = before.prev;\n      before.prev = item;\n      item.next = before;\n    }\n  } else {\n    // tail\n    //      ^\n    //      item\n    this.updateCursors(this.tail, item, null, item);\n\n    // insert to the ending of the list\n    if (this.tail !== null) {\n      // last item -> new item\n      this.tail.next = item;\n\n      // last item <- new item\n      item.prev = this.tail;\n    } else {\n      // if list has no tail, then it also has no head\n      // in this case head points to new item\n      this.head = item;\n    }\n\n    // tail always points to new item\n    this.tail = item;\n  }\n  return this;\n};\nList.prototype.insertData = function (data, before) {\n  return this.insert(createItem(data), before);\n};\nList.prototype.remove = function (item) {\n  //      item\n  //       ^\n  // prev     next\n  this.updateCursors(item, item.prev, item, item.next);\n  if (item.prev !== null) {\n    item.prev.next = item.next;\n  } else {\n    if (this.head !== item) {\n      throw new Error('item doesn\\'t belong to list');\n    }\n    this.head = item.next;\n  }\n  if (item.next !== null) {\n    item.next.prev = item.prev;\n  } else {\n    if (this.tail !== item) {\n      throw new Error('item doesn\\'t belong to list');\n    }\n    this.tail = item.prev;\n  }\n  item.prev = null;\n  item.next = null;\n  return item;\n};\nList.prototype.push = function (data) {\n  this.insert(createItem(data));\n};\nList.prototype.pop = function () {\n  if (this.tail !== null) {\n    return this.remove(this.tail);\n  }\n};\nList.prototype.unshift = function (data) {\n  this.prepend(createItem(data));\n};\nList.prototype.shift = function () {\n  if (this.head !== null) {\n    return this.remove(this.head);\n  }\n};\nList.prototype.prependList = function (list) {\n  return this.insertList(list, this.head);\n};\nList.prototype.appendList = function (list) {\n  return this.insertList(list);\n};\nList.prototype.insertList = function (list, before) {\n  // ignore empty lists\n  if (list.head === null) {\n    return this;\n  }\n  if (before !== undefined && before !== null) {\n    this.updateCursors(before.prev, list.tail, before, list.head);\n\n    // insert in the middle of dist list\n    if (before.prev !== null) {\n      // before.prev <-> list.head\n      before.prev.next = list.head;\n      list.head.prev = before.prev;\n    } else {\n      this.head = list.head;\n    }\n    before.prev = list.tail;\n    list.tail.next = before;\n  } else {\n    this.updateCursors(this.tail, list.tail, null, list.head);\n\n    // insert to end of the list\n    if (this.tail !== null) {\n      // if destination list has a tail, then it also has a head,\n      // but head doesn't change\n\n      // dest tail -> source head\n      this.tail.next = list.head;\n\n      // dest tail <- source head\n      list.head.prev = this.tail;\n    } else {\n      // if list has no a tail, then it also has no a head\n      // in this case points head to new item\n      this.head = list.head;\n    }\n\n    // tail always start point to new item\n    this.tail = list.tail;\n  }\n  list.head = null;\n  list.tail = null;\n  return this;\n};\nList.prototype.replace = function (oldItem, newItemOrList) {\n  if ('head' in newItemOrList) {\n    this.insertList(newItemOrList, oldItem);\n  } else {\n    this.insert(newItemOrList, oldItem);\n  }\n  this.remove(oldItem);\n};\nmodule.exports = List;","map":null,"metadata":{},"sourceType":"script"}