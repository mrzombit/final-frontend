{"ast":null,"code":"var charCodeDef = require('./char-code-definitions');\nvar isDigit = charCodeDef.isDigit;\nvar isHexDigit = charCodeDef.isHexDigit;\nvar isUppercaseLetter = charCodeDef.isUppercaseLetter;\nvar isName = charCodeDef.isName;\nvar isWhiteSpace = charCodeDef.isWhiteSpace;\nvar isValidEscape = charCodeDef.isValidEscape;\nfunction getCharCode(source, offset) {\n  return offset < source.length ? source.charCodeAt(offset) : 0;\n}\nfunction getNewlineLength(source, offset, code) {\n  if (code === 13 /* \\r */ && getCharCode(source, offset + 1) === 10 /* \\n */) {\n    return 2;\n  }\n  return 1;\n}\nfunction cmpChar(testStr, offset, referenceCode) {\n  var code = testStr.charCodeAt(offset);\n\n  // code.toLowerCase() for A..Z\n  if (isUppercaseLetter(code)) {\n    code = code | 32;\n  }\n  return code === referenceCode;\n}\nfunction cmpStr(testStr, start, end, referenceStr) {\n  if (end - start !== referenceStr.length) {\n    return false;\n  }\n  if (start < 0 || end > testStr.length) {\n    return false;\n  }\n  for (var i = start; i < end; i++) {\n    var testCode = testStr.charCodeAt(i);\n    var referenceCode = referenceStr.charCodeAt(i - start);\n\n    // testCode.toLowerCase() for A..Z\n    if (isUppercaseLetter(testCode)) {\n      testCode = testCode | 32;\n    }\n    if (testCode !== referenceCode) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction findWhiteSpaceStart(source, offset) {\n  for (; offset >= 0; offset--) {\n    if (!isWhiteSpace(source.charCodeAt(offset))) {\n      break;\n    }\n  }\n  return offset + 1;\n}\nfunction findWhiteSpaceEnd(source, offset) {\n  for (; offset < source.length; offset++) {\n    if (!isWhiteSpace(source.charCodeAt(offset))) {\n      break;\n    }\n  }\n  return offset;\n}\nfunction findDecimalNumberEnd(source, offset) {\n  for (; offset < source.length; offset++) {\n    if (!isDigit(source.charCodeAt(offset))) {\n      break;\n    }\n  }\n  return offset;\n}\n\n// ยง 4.3.7. Consume an escaped code point\nfunction consumeEscaped(source, offset) {\n  // It assumes that the U+005C REVERSE SOLIDUS (\\) has already been consumed and\n  // that the next input code point has already been verified to be part of a valid escape.\n  offset += 2;\n\n  // hex digit\n  if (isHexDigit(getCharCode(source, offset - 1))) {\n    // Consume as many hex digits as possible, but no more than 5.\n    // Note that this means 1-6 hex digits have been consumed in total.\n    for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {\n      if (!isHexDigit(getCharCode(source, offset))) {\n        break;\n      }\n    }\n\n    // If the next input code point is whitespace, consume it as well.\n    var code = getCharCode(source, offset);\n    if (isWhiteSpace(code)) {\n      offset += getNewlineLength(source, offset, code);\n    }\n  }\n  return offset;\n}\n\n// ยง4.3.11. Consume a name\n// Note: This algorithm does not do the verification of the first few code points that are necessary\n// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,\n// ensure that the stream starts with an identifier before calling this algorithm.\nfunction consumeName(source, offset) {\n  // Let result initially be an empty string.\n  // Repeatedly consume the next input code point from the stream:\n  for (; offset < source.length; offset++) {\n    var code = source.charCodeAt(offset);\n\n    // name code point\n    if (isName(code)) {\n      // Append the code point to result.\n      continue;\n    }\n\n    // the stream starts with a valid escape\n    if (isValidEscape(code, getCharCode(source, offset + 1))) {\n      // Consume an escaped code point. Append the returned code point to result.\n      offset = consumeEscaped(source, offset) - 1;\n      continue;\n    }\n\n    // anything else\n    // Reconsume the current input code point. Return result.\n    break;\n  }\n  return offset;\n}\n\n// ยง4.3.12. Consume a number\nfunction consumeNumber(source, offset) {\n  var code = source.charCodeAt(offset);\n\n  // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),\n  // consume it and append it to repr.\n  if (code === 0x002B || code === 0x002D) {\n    code = source.charCodeAt(offset += 1);\n  }\n\n  // 3. While the next input code point is a digit, consume it and append it to repr.\n  if (isDigit(code)) {\n    offset = findDecimalNumberEnd(source, offset + 1);\n    code = source.charCodeAt(offset);\n  }\n\n  // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:\n  if (code === 0x002E && isDigit(source.charCodeAt(offset + 1))) {\n    // 4.1 Consume them.\n    // 4.2 Append them to repr.\n    code = source.charCodeAt(offset += 2);\n\n    // 4.3 Set type to \"number\".\n    // TODO\n\n    // 4.4 While the next input code point is a digit, consume it and append it to repr.\n\n    offset = findDecimalNumberEnd(source, offset);\n  }\n\n  // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)\n  // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:\n  if (cmpChar(source, offset, 101 /* e */)) {\n    var sign = 0;\n    code = source.charCodeAt(offset + 1);\n\n    // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...\n    if (code === 0x002D || code === 0x002B) {\n      sign = 1;\n      code = source.charCodeAt(offset + 2);\n    }\n\n    // ... followed by a digit\n    if (isDigit(code)) {\n      // 5.1 Consume them.\n      // 5.2 Append them to repr.\n\n      // 5.3 Set type to \"number\".\n      // TODO\n\n      // 5.4 While the next input code point is a digit, consume it and append it to repr.\n      offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);\n    }\n  }\n  return offset;\n}\n\n// ยง 4.3.14. Consume the remnants of a bad url\n// ... its sole use is to consume enough of the input stream to reach a recovery point\n// where normal tokenizing can resume.\nfunction consumeBadUrlRemnants(source, offset) {\n  // Repeatedly consume the next input code point from the stream:\n  for (; offset < source.length; offset++) {\n    var code = source.charCodeAt(offset);\n\n    // U+0029 RIGHT PARENTHESIS ())\n    // EOF\n    if (code === 0x0029) {\n      // Return.\n      offset++;\n      break;\n    }\n    if (isValidEscape(code, getCharCode(source, offset + 1))) {\n      // Consume an escaped code point.\n      // Note: This allows an escaped right parenthesis (\"\\)\") to be encountered\n      // without ending the <bad-url-token>. This is otherwise identical to\n      // the \"anything else\" clause.\n      offset = consumeEscaped(source, offset);\n    }\n  }\n  return offset;\n}\nmodule.exports = {\n  consumeEscaped: consumeEscaped,\n  consumeName: consumeName,\n  consumeNumber: consumeNumber,\n  consumeBadUrlRemnants: consumeBadUrlRemnants,\n  cmpChar: cmpChar,\n  cmpStr: cmpStr,\n  getNewlineLength: getNewlineLength,\n  findWhiteSpaceStart: findWhiteSpaceStart,\n  findWhiteSpaceEnd: findWhiteSpaceEnd\n};","map":null,"metadata":{},"sourceType":"script"}