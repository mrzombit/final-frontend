{"ast":null,"code":"import _slicedToArray from \"/Users/koonk/Documents/GitHub/CE65-20/packages/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"/Users/koonk/Documents/GitHub/CE65-20/packages/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _toConsumableArray from \"/Users/koonk/Documents/GitHub/CE65-20/packages/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _possibleConstructorReturn from \"/Users/koonk/Documents/GitHub/CE65-20/packages/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/koonk/Documents/GitHub/CE65-20/packages/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/koonk/Documents/GitHub/CE65-20/packages/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _classCallCheck from \"/Users/koonk/Documents/GitHub/CE65-20/packages/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/koonk/Documents/GitHub/CE65-20/packages/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport he from 'he';\nimport { selectAll, selectOne } from 'css-select';\nimport Node from './node';\nimport NodeType from './type';\nimport TextNode from './text';\nimport Matcher from '../matcher';\nimport arr_back from '../back';\nimport CommentNode from './comment';\n// const { decode } = he;\nfunction decode(val) {\n  // clone string\n  return JSON.parse(JSON.stringify(he.decode(val)));\n}\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements\nvar kBlockElements = new Set();\nkBlockElements.add('address');\nkBlockElements.add('ADDRESS');\nkBlockElements.add('article');\nkBlockElements.add('ARTICLE');\nkBlockElements.add('aside');\nkBlockElements.add('ASIDE');\nkBlockElements.add('blockquote');\nkBlockElements.add('BLOCKQUOTE');\nkBlockElements.add('br');\nkBlockElements.add('BR');\nkBlockElements.add('details');\nkBlockElements.add('DETAILS');\nkBlockElements.add('dialog');\nkBlockElements.add('DIALOG');\nkBlockElements.add('dd');\nkBlockElements.add('DD');\nkBlockElements.add('div');\nkBlockElements.add('DIV');\nkBlockElements.add('dl');\nkBlockElements.add('DL');\nkBlockElements.add('dt');\nkBlockElements.add('DT');\nkBlockElements.add('fieldset');\nkBlockElements.add('FIELDSET');\nkBlockElements.add('figcaption');\nkBlockElements.add('FIGCAPTION');\nkBlockElements.add('figure');\nkBlockElements.add('FIGURE');\nkBlockElements.add('footer');\nkBlockElements.add('FOOTER');\nkBlockElements.add('form');\nkBlockElements.add('FORM');\nkBlockElements.add('h1');\nkBlockElements.add('H1');\nkBlockElements.add('h2');\nkBlockElements.add('H2');\nkBlockElements.add('h3');\nkBlockElements.add('H3');\nkBlockElements.add('h4');\nkBlockElements.add('H4');\nkBlockElements.add('h5');\nkBlockElements.add('H5');\nkBlockElements.add('h6');\nkBlockElements.add('H6');\nkBlockElements.add('header');\nkBlockElements.add('HEADER');\nkBlockElements.add('hgroup');\nkBlockElements.add('HGROUP');\nkBlockElements.add('hr');\nkBlockElements.add('HR');\nkBlockElements.add('li');\nkBlockElements.add('LI');\nkBlockElements.add('main');\nkBlockElements.add('MAIN');\nkBlockElements.add('nav');\nkBlockElements.add('NAV');\nkBlockElements.add('ol');\nkBlockElements.add('OL');\nkBlockElements.add('p');\nkBlockElements.add('P');\nkBlockElements.add('pre');\nkBlockElements.add('PRE');\nkBlockElements.add('section');\nkBlockElements.add('SECTION');\nkBlockElements.add('table');\nkBlockElements.add('TABLE');\nkBlockElements.add('td');\nkBlockElements.add('TD');\nkBlockElements.add('tr');\nkBlockElements.add('TR');\nkBlockElements.add('ul');\nkBlockElements.add('UL');\nvar DOMTokenList = /*#__PURE__*/function () {\n  function DOMTokenList() {\n    var valuesInit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var afterUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n      return null;\n    };\n    _classCallCheck(this, DOMTokenList);\n    this._set = new Set(valuesInit);\n    this._afterUpdate = afterUpdate;\n  }\n  _createClass(DOMTokenList, [{\n    key: \"_validate\",\n    value: function _validate(c) {\n      if (/\\s/.test(c)) {\n        throw new Error(\"DOMException in DOMTokenList.add: The token '\".concat(c, \"' contains HTML space characters, which are not valid in tokens.\"));\n      }\n    }\n  }, {\n    key: \"add\",\n    value: function add(c) {\n      this._validate(c);\n      this._set.add(c);\n      this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\n    }\n  }, {\n    key: \"replace\",\n    value: function replace(c1, c2) {\n      this._validate(c2);\n      this._set.delete(c1);\n      this._set.add(c2);\n      this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(c) {\n      this._set.delete(c) && this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\n    }\n  }, {\n    key: \"toggle\",\n    value: function toggle(c) {\n      this._validate(c);\n      if (this._set.has(c)) this._set.delete(c);else this._set.add(c);\n      this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call\n    }\n  }, {\n    key: \"contains\",\n    value: function contains(c) {\n      return this._set.has(c);\n    }\n  }, {\n    key: \"values\",\n    value: function values() {\n      return this._set.values();\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return Array.from(this._set.values()).join(' ');\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._set.size;\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      return Array.from(this._set.values());\n    }\n  }]);\n  return DOMTokenList;\n}();\n/**\n * HTMLElement, which contains a set of children.\n *\n * Note: this is a minimalist implementation, no complete tree\n *   structure provided (no parentNode, nextSibling,\n *   previousSibling etc).\n * @class HTMLElement\n * @extends {Node}\n */\nvar HTMLElement = /*#__PURE__*/function (_Node) {\n  _inherits(HTMLElement, _Node);\n  /**\n   * Creates an instance of HTMLElement.\n   * @param keyAttrs\tid and class attribute\n   * @param [rawAttrs]\tattributes in string\n   *\n   * @memberof HTMLElement\n   */\n  function HTMLElement(tagName, keyAttrs) {\n    var _this;\n    var rawAttrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    var parentNode = arguments.length > 3 ? arguments[3] : undefined;\n    _classCallCheck(this, HTMLElement);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(HTMLElement).call(this, parentNode));\n    _this.rawAttrs = rawAttrs;\n    /**\n     * Node Type declaration.\n     */\n    _this.nodeType = NodeType.ELEMENT_NODE;\n    _this.rawTagName = tagName;\n    _this.rawAttrs = rawAttrs || '';\n    _this.id = keyAttrs.id || '';\n    _this.childNodes = [];\n    _this.classList = new DOMTokenList(keyAttrs.class ? keyAttrs.class.split(/\\s+/) : [], function (classList) {\n      return _this.setAttribute('class', classList.toString()) // eslint-disable-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n      ;\n    });\n\n    if (keyAttrs.id) {\n      if (!rawAttrs) {\n        _this.rawAttrs = \"id=\\\"\".concat(keyAttrs.id, \"\\\"\");\n      }\n    }\n    if (keyAttrs.class) {\n      if (!rawAttrs) {\n        var cls = \"class=\\\"\".concat(_this.classList.toString(), \"\\\"\");\n        if (_this.rawAttrs) {\n          _this.rawAttrs += \" \".concat(cls);\n        } else {\n          _this.rawAttrs = cls;\n        }\n      }\n    }\n    return _this;\n  }\n  /**\n   * Quote attribute values\n   * @param attr attribute value\n   * @returns {string} quoted value\n   */\n  _createClass(HTMLElement, [{\n    key: \"quoteAttribute\",\n    value: function quoteAttribute(attr) {\n      if (attr === null) {\n        return \"null\";\n      }\n      return JSON.stringify(attr.replace(/\"/g, '&quot;'));\n    }\n    /**\n     * Remove current element\n     */\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var _this2 = this;\n      if (this.parentNode) {\n        var children = this.parentNode.childNodes;\n        this.parentNode.childNodes = children.filter(function (child) {\n          return _this2 !== child;\n        });\n      }\n    }\n    /**\n     * Remove Child element from childNodes array\n     * @param {HTMLElement} node     node to remove\n     */\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(node) {\n      this.childNodes = this.childNodes.filter(function (child) {\n        return child !== node;\n      });\n    }\n    /**\n     * Exchanges given child with new child\n     * @param {HTMLElement} oldNode     node to exchange\n     * @param {HTMLElement} newNode     new node\n     */\n  }, {\n    key: \"exchangeChild\",\n    value: function exchangeChild(oldNode, newNode) {\n      var children = this.childNodes;\n      this.childNodes = children.map(function (child) {\n        if (child === oldNode) {\n          return newNode;\n        }\n        return child;\n      });\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var tag = this.rawTagName;\n      if (tag) {\n        // const void_tags = new Set('area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr'.split('|'));\n        // const is_void = void_tags.has(tag);\n        var is_void = /^(area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr)$/i.test(tag);\n        var attrs = this.rawAttrs ? \" \".concat(this.rawAttrs) : '';\n        if (is_void) {\n          return \"<\".concat(tag).concat(attrs, \">\");\n        }\n        return \"<\".concat(tag).concat(attrs, \">\").concat(this.innerHTML, \"</\").concat(tag, \">\");\n      }\n      return this.innerHTML;\n    }\n  }, {\n    key: \"set_content\",\n    value: function set_content(content) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (content instanceof Node) {\n        content = [content];\n      } else if (typeof content == 'string') {\n        var r = parse(content, options);\n        content = r.childNodes.length ? r.childNodes : [new TextNode(content, this)];\n      }\n      this.childNodes = content;\n    }\n  }, {\n    key: \"replaceWith\",\n    value: function replaceWith() {\n      var _this3 = this;\n      for (var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++) {\n        nodes[_key] = arguments[_key];\n      }\n      var content = nodes.map(function (node) {\n        if (node instanceof Node) {\n          return [node];\n        } else if (typeof node == 'string') {\n          // const r = parse(content, global.options); // TODO global.options ?\n          var r = parse(node);\n          return r.childNodes.length ? r.childNodes : [new TextNode(node, _this3)];\n        }\n        return [];\n      }).flat();\n      var idx = this.parentNode.childNodes.findIndex(function (child) {\n        return child === _this3;\n      });\n      this.parentNode.childNodes = [].concat(_toConsumableArray(this.parentNode.childNodes.slice(0, idx)), _toConsumableArray(content), _toConsumableArray(this.parentNode.childNodes.slice(idx + 1)));\n    }\n  }, {\n    key: \"trimRight\",\n    /**\n     * Trim element from right (in block) after seeing pattern in a TextNode.\n     * @param  {RegExp} pattern pattern to find\n     * @return {HTMLElement}    reference to current node\n     */\n    value: function trimRight(pattern) {\n      for (var i = 0; i < this.childNodes.length; i++) {\n        var childNode = this.childNodes[i];\n        if (childNode.nodeType === NodeType.ELEMENT_NODE) {\n          childNode.trimRight(pattern);\n        } else {\n          var index = childNode.rawText.search(pattern);\n          if (index > -1) {\n            childNode.rawText = childNode.rawText.substr(0, index);\n            // trim all following nodes.\n            this.childNodes.length = i + 1;\n          }\n        }\n      }\n      return this;\n    }\n    /**\n     * Get DOM structure\n     * @return {string} strucutre\n     */\n  }, {\n    key: \"removeWhitespace\",\n    /**\n     * Remove whitespaces in this sub tree.\n     * @return {HTMLElement} pointer to this\n     */\n    value: function removeWhitespace() {\n      var _this4 = this;\n      var o = 0;\n      this.childNodes.forEach(function (node) {\n        if (node.nodeType === NodeType.TEXT_NODE) {\n          if (node.isWhitespace) {\n            return;\n          }\n          node.rawText = node.trimmedText;\n        } else if (node.nodeType === NodeType.ELEMENT_NODE) {\n          node.removeWhitespace();\n        }\n        _this4.childNodes[o++] = node;\n      });\n      this.childNodes.length = o;\n      return this;\n    }\n    /**\n     * Query CSS selector to find matching nodes.\n     * @param  {string}         selector Simplified CSS selector\n     * @return {HTMLElement[]}  matching elements\n     */\n  }, {\n    key: \"querySelectorAll\",\n    value: function querySelectorAll(selector) {\n      return selectAll(selector, this, {\n        xmlMode: true,\n        adapter: Matcher\n      });\n      // let matcher: Matcher;\n      // if (selector instanceof Matcher) {\n      // \tmatcher = selector;\n      // \tmatcher.reset();\n      // } else {\n      // \tif (selector.includes(',')) {\n      // \t\tconst selectors = selector.split(',');\n      // \t\treturn Array.from(selectors.reduce((pre, cur) => {\n      // \t\t\tconst result = this.querySelectorAll(cur.trim());\n      // \t\t\treturn result.reduce((p, c) => {\n      // \t\t\t\treturn p.add(c);\n      // \t\t\t}, pre);\n      // \t\t}, new Set<HTMLElement>()));\n      // \t}\n      // \tmatcher = new Matcher(selector);\n      // }\n      // interface IStack {\n      // \t0: Node;\t// node\n      // \t1: number;\t// children\n      // \t2: boolean;\t// found flag\n      // }\n      // const stack = [] as IStack[];\n      // return this.childNodes.reduce((res, cur) => {\n      // \tstack.push([cur, 0, false]);\n      // \twhile (stack.length) {\n      // \t\tconst state = arr_back(stack);\t// get last element\n      // \t\tconst el = state[0];\n      // \t\tif (state[1] === 0) {\n      // \t\t\t// Seen for first time.\n      // \t\t\tif (el.nodeType !== NodeType.ELEMENT_NODE) {\n      // \t\t\t\tstack.pop();\n      // \t\t\t\tcontinue;\n      // \t\t\t}\n      // \t\t\tconst html_el = el as HTMLElement;\n      // \t\t\tstate[2] = matcher.advance(html_el);\n      // \t\t\tif (state[2]) {\n      // \t\t\t\tif (matcher.matched) {\n      // \t\t\t\t\tres.push(html_el);\n      // \t\t\t\t\tres.push(...(html_el.querySelectorAll(selector)));\n      // \t\t\t\t\t// no need to go further.\n      // \t\t\t\t\tmatcher.rewind();\n      // \t\t\t\t\tstack.pop();\n      // \t\t\t\t\tcontinue;\n      // \t\t\t\t}\n      // \t\t\t}\n      // \t\t}\n      // \t\tif (state[1] < el.childNodes.length) {\n      // \t\t\tstack.push([el.childNodes[state[1]++], 0, false]);\n      // \t\t} else {\n      // \t\t\tif (state[2]) {\n      // \t\t\t\tmatcher.rewind();\n      // \t\t\t}\n      // \t\t\tstack.pop();\n      // \t\t}\n      // \t}\n      // \treturn res;\n      // }, [] as HTMLElement[]);\n    }\n    /**\n     * Query CSS Selector to find matching node.\n     * @param  {string}         selector Simplified CSS selector\n     * @return {HTMLElement}    matching node\n     */\n  }, {\n    key: \"querySelector\",\n    value: function querySelector(selector) {\n      return selectOne(selector, this, {\n        xmlMode: true,\n        adapter: Matcher\n      });\n      // let matcher: Matcher;\n      // if (selector instanceof Matcher) {\n      // \tmatcher = selector;\n      // \tmatcher.reset();\n      // } else {\n      // \tmatcher = new Matcher(selector);\n      // }\n      // const stack = [] as { 0: Node; 1: 0 | 1; 2: boolean }[];\n      // for (const node of this.childNodes) {\n      // \tstack.push([node, 0, false]);\n      // \twhile (stack.length) {\n      // \t\tconst state = arr_back(stack);\n      // \t\tconst el = state[0];\n      // \t\tif (state[1] === 0) {\n      // \t\t\t// Seen for first time.\n      // \t\t\tif (el.nodeType !== NodeType.ELEMENT_NODE) {\n      // \t\t\t\tstack.pop();\n      // \t\t\t\tcontinue;\n      // \t\t\t}\n      // \t\t\tstate[2] = matcher.advance(el as HTMLElement);\n      // \t\t\tif (state[2]) {\n      // \t\t\t\tif (matcher.matched) {\n      // \t\t\t\t\treturn el as HTMLElement;\n      // \t\t\t\t}\n      // \t\t\t}\n      // \t\t}\n      // \t\tif (state[1] < el.childNodes.length) {\n      // \t\t\tstack.push([el.childNodes[state[1]++], 0, false]);\n      // \t\t} else {\n      // \t\t\tif (state[2]) {\n      // \t\t\t\tmatcher.rewind();\n      // \t\t\t}\n      // \t\t\tstack.pop();\n      // \t\t}\n      // \t}\n      // }\n      // return null;\n    }\n    /**\n     * traverses the Element and its parents (heading toward the document root) until it finds a node that matches the provided selector string. Will return itself or the matching ancestor. If no such element exists, it returns null.\n     * @param selector a DOMString containing a selector list\n     */\n  }, {\n    key: \"closest\",\n    value: function closest(selector) {\n      var mapChild = new Map();\n      var el = this;\n      var old = null;\n      function findOne(test, elems) {\n        var elem = null;\n        for (var i = 0, l = elems.length; i < l && !elem; i++) {\n          var _el = elems[i];\n          if (test(_el)) {\n            elem = _el;\n          } else {\n            var child = mapChild.get(_el);\n            if (child) {\n              elem = findOne(test, [child]);\n            }\n          }\n        }\n        return elem;\n      }\n      while (el) {\n        mapChild.set(el, old);\n        old = el;\n        el = el.parentNode;\n      }\n      el = this;\n      while (el) {\n        var e = selectOne(selector, el, {\n          xmlMode: true,\n          adapter: _objectSpread({}, Matcher, {\n            getChildren: function getChildren(node) {\n              var child = mapChild.get(node);\n              return child && [child];\n            },\n            getSiblings: function getSiblings(node) {\n              return [node];\n            },\n            findOne: findOne,\n            findAll: function findAll() {\n              return [];\n            }\n          })\n        });\n        if (e) {\n          return e;\n        }\n        el = el.parentNode;\n      }\n      return null;\n    }\n    /**\n     * Append a child node to childNodes\n     * @param  {Node} node node to append\n     * @return {Node}      node appended\n     */\n  }, {\n    key: \"appendChild\",\n    value: function appendChild(node) {\n      // node.parentNode = this;\n      this.childNodes.push(node);\n      node.parentNode = this;\n      return node;\n    }\n    /**\n     * Get first child node\n     * @return {Node} first child node\n     */\n  }, {\n    key: \"removeAttribute\",\n    value: function removeAttribute(key) {\n      var attrs = this.rawAttributes;\n      delete attrs[key];\n      // Update this.attribute\n      if (this._attrs) {\n        delete this._attrs[key];\n      }\n      // Update rawString\n      this.rawAttrs = Object.keys(attrs).map(function (name) {\n        var val = JSON.stringify(attrs[name]);\n        if (val === undefined || val === 'null') {\n          return name;\n        }\n        return \"\".concat(name, \"=\").concat(val);\n      }).join(' ');\n      // Update this.id\n      if (key === 'id') {\n        this.id = '';\n      }\n    }\n  }, {\n    key: \"hasAttribute\",\n    value: function hasAttribute(key) {\n      return key.toLowerCase() in this.attrs;\n    }\n    /**\n     * Get an attribute\n     * @return {string} value of the attribute\n     */\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute(key) {\n      return this.attrs[key.toLowerCase()];\n    }\n    /**\n     * Set an attribute value to the HTMLElement\n     * @param {string} key The attribute name\n     * @param {string} value The value to set, or null / undefined to remove an attribute\n     */\n  }, {\n    key: \"setAttribute\",\n    value: function setAttribute(key, value) {\n      var _this5 = this;\n      if (arguments.length < 2) {\n        throw new Error('Failed to execute \\'setAttribute\\' on \\'Element\\'');\n      }\n      var k2 = key.toLowerCase();\n      var attrs = this.rawAttributes;\n      for (var k in attrs) {\n        if (k.toLowerCase() === k2) {\n          key = k;\n          break;\n        }\n      }\n      attrs[key] = String(value);\n      // update this.attrs\n      if (this._attrs) {\n        this._attrs[k2] = decode(attrs[key]);\n      }\n      // Update rawString\n      this.rawAttrs = Object.keys(attrs).map(function (name) {\n        var val = _this5.quoteAttribute(attrs[name]);\n        if (val === 'null' || val === '\"\"') {\n          return name;\n        }\n        return \"\".concat(name, \"=\").concat(val);\n      }).join(' ');\n      // Update this.id\n      if (key === 'id') {\n        this.id = value;\n      }\n    }\n    /**\n     * Replace all the attributes of the HTMLElement by the provided attributes\n     * @param {Attributes} attributes the new attribute set\n     */\n  }, {\n    key: \"setAttributes\",\n    value: function setAttributes(attributes) {\n      var _this6 = this;\n      // Invalidate current this.attributes\n      if (this._attrs) {\n        delete this._attrs;\n      }\n      // Invalidate current this.rawAttributes\n      if (this._rawAttrs) {\n        delete this._rawAttrs;\n      }\n      // Update rawString\n      this.rawAttrs = Object.keys(attributes).map(function (name) {\n        var val = attributes[name];\n        if (val === 'null' || val === '\"\"') {\n          return name;\n        }\n        return \"\".concat(name, \"=\").concat(_this6.quoteAttribute(String(val)));\n      }).join(' ');\n    }\n  }, {\n    key: \"insertAdjacentHTML\",\n    value: function insertAdjacentHTML(where, html) {\n      var _this7 = this;\n      if (arguments.length < 2) {\n        throw new Error('2 arguments required');\n      }\n      var p = parse(html);\n      if (where === 'afterend') {\n        var _this$parentNode$chil;\n        var idx = this.parentNode.childNodes.findIndex(function (child) {\n          return child === _this7;\n        });\n        (_this$parentNode$chil = this.parentNode.childNodes).splice.apply(_this$parentNode$chil, [idx + 1, 0].concat(_toConsumableArray(p.childNodes)));\n        p.childNodes.forEach(function (n) {\n          if (n instanceof HTMLElement) {\n            n.parentNode = _this7.parentNode;\n          }\n        });\n      } else if (where === 'afterbegin') {\n        var _this$childNodes;\n        (_this$childNodes = this.childNodes).unshift.apply(_this$childNodes, _toConsumableArray(p.childNodes));\n      } else if (where === 'beforeend') {\n        p.childNodes.forEach(function (n) {\n          _this7.appendChild(n);\n        });\n      } else if (where === 'beforebegin') {\n        var _this$parentNode$chil2;\n        var _idx = this.parentNode.childNodes.findIndex(function (child) {\n          return child === _this7;\n        });\n        (_this$parentNode$chil2 = this.parentNode.childNodes).splice.apply(_this$parentNode$chil2, [_idx, 0].concat(_toConsumableArray(p.childNodes)));\n        p.childNodes.forEach(function (n) {\n          if (n instanceof HTMLElement) {\n            n.parentNode = _this7.parentNode;\n          }\n        });\n      } else {\n        throw new Error(\"The value provided ('\".concat(where, \"') is not one of 'beforebegin', 'afterbegin', 'beforeend', or 'afterend'\"));\n      }\n      // if (!where || html === undefined || html === null) {\n      // \treturn;\n      // }\n    }\n  }, {\n    key: \"tagName\",\n    get: function get() {\n      return this.rawTagName ? this.rawTagName.toUpperCase() : this.rawTagName;\n    }\n  }, {\n    key: \"localName\",\n    get: function get() {\n      return this.rawTagName.toLowerCase();\n    }\n    /**\n     * Get escpaed (as-it) text value of current node and its children.\n     * @return {string} text content\n     */\n  }, {\n    key: \"rawText\",\n    get: function get() {\n      return this.childNodes.reduce(function (pre, cur) {\n        return pre += cur.rawText;\n      }, '');\n    }\n  }, {\n    key: \"textContent\",\n    get: function get() {\n      return this.rawText;\n    },\n    set: function set(val) {\n      var content = [new TextNode(val, this)];\n      this.childNodes = content;\n    }\n    /**\n     * Get unescaped text value of current node and its children.\n     * @return {string} text content\n     */\n  }, {\n    key: \"text\",\n    get: function get() {\n      return decode(this.rawText);\n    }\n    /**\n     * Get structured Text (with '\\n' etc.)\n     * @return {string} structured text\n     */\n  }, {\n    key: \"structuredText\",\n    get: function get() {\n      var currentBlock = [];\n      var blocks = [currentBlock];\n      function dfs(node) {\n        if (node.nodeType === NodeType.ELEMENT_NODE) {\n          if (kBlockElements.has(node.rawTagName)) {\n            if (currentBlock.length > 0) {\n              blocks.push(currentBlock = []);\n            }\n            node.childNodes.forEach(dfs);\n            if (currentBlock.length > 0) {\n              blocks.push(currentBlock = []);\n            }\n          } else {\n            node.childNodes.forEach(dfs);\n          }\n        } else if (node.nodeType === NodeType.TEXT_NODE) {\n          if (node.isWhitespace) {\n            // Whitespace node, postponed output\n            currentBlock.prependWhitespace = true;\n          } else {\n            var text = node.trimmedText;\n            if (currentBlock.prependWhitespace) {\n              text = \" \".concat(text);\n              currentBlock.prependWhitespace = false;\n            }\n            currentBlock.push(text);\n          }\n        }\n      }\n      dfs(this);\n      return blocks.map(function (block) {\n        // Normalize each line's whitespace\n        return block.join('').replace(/\\s{2,}/g, ' ');\n      }).join('\\n').replace(/\\s+$/, ''); // trimRight;\n    }\n  }, {\n    key: \"innerHTML\",\n    get: function get() {\n      return this.childNodes.map(function (child) {\n        return child.toString();\n      }).join('');\n    },\n    set: function set(content) {\n      //const r = parse(content, global.options); // TODO global.options ?\n      var r = parse(content);\n      this.childNodes = r.childNodes.length ? r.childNodes : [new TextNode(content, this)];\n    }\n  }, {\n    key: \"outerHTML\",\n    get: function get() {\n      return this.toString();\n    }\n  }, {\n    key: \"structure\",\n    get: function get() {\n      var res = [];\n      var indention = 0;\n      function write(str) {\n        res.push('  '.repeat(indention) + str);\n      }\n      function dfs(node) {\n        var idStr = node.id ? \"#\".concat(node.id) : '';\n        var classStr = node.classList.length ? \".\".concat(node.classList.value.join('.')) : ''; // eslint-disable-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-unsafe-call\n        write(\"\".concat(node.rawTagName).concat(idStr).concat(classStr));\n        indention++;\n        node.childNodes.forEach(function (childNode) {\n          if (childNode.nodeType === NodeType.ELEMENT_NODE) {\n            dfs(childNode);\n          } else if (childNode.nodeType === NodeType.TEXT_NODE) {\n            if (!childNode.isWhitespace) {\n              write('#text');\n            }\n          }\n        });\n        indention--;\n      }\n      dfs(this);\n      return res.join('\\n');\n    }\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      return this.childNodes[0];\n    }\n    /**\n     * Get last child node\n     * @return {Node} last child node\n     */\n  }, {\n    key: \"lastChild\",\n    get: function get() {\n      return arr_back(this.childNodes);\n    }\n    /**\n     * Get attributes\n     * @access private\n     * @return {Object} parsed and unescaped attributes\n     */\n  }, {\n    key: \"attrs\",\n    get: function get() {\n      if (this._attrs) {\n        return this._attrs;\n      }\n      this._attrs = {};\n      var attrs = this.rawAttributes;\n      for (var key in attrs) {\n        var val = attrs[key] || '';\n        this._attrs[key.toLowerCase()] = decode(val);\n      }\n      return this._attrs;\n    }\n  }, {\n    key: \"attributes\",\n    get: function get() {\n      var ret_attrs = {};\n      var attrs = this.rawAttributes;\n      for (var key in attrs) {\n        var val = attrs[key] || '';\n        ret_attrs[key] = decode(val);\n      }\n      return ret_attrs;\n    }\n    /**\n     * Get escaped (as-it) attributes\n     * @return {Object} parsed attributes\n     */\n  }, {\n    key: \"rawAttributes\",\n    get: function get() {\n      if (this._rawAttrs) {\n        return this._rawAttrs;\n      }\n      var attrs = {};\n      if (this.rawAttrs) {\n        var re = /\\b([a-z][a-z0-9-_:]*)(?:\\s*=\\s*(?:\"([^\"]*)\"|'([^']*)'|(\\S+)))?/ig;\n        var match;\n        while (match = re.exec(this.rawAttrs)) {\n          attrs[match[1]] = match[2] || match[3] || match[4] || null;\n        }\n      }\n      this._rawAttrs = attrs;\n      return attrs;\n    }\n  }, {\n    key: \"nextSibling\",\n    get: function get() {\n      if (this.parentNode) {\n        var children = this.parentNode.childNodes;\n        var i = 0;\n        while (i < children.length) {\n          var child = children[i++];\n          if (this === child) {\n            return children[i] || null;\n          }\n        }\n        return null;\n      }\n    }\n  }, {\n    key: \"nextElementSibling\",\n    get: function get() {\n      if (this.parentNode) {\n        var children = this.parentNode.childNodes;\n        var i = 0;\n        var find = false;\n        while (i < children.length) {\n          var child = children[i++];\n          if (find) {\n            if (child instanceof HTMLElement) {\n              return child || null;\n            }\n          } else if (this === child) {\n            find = true;\n          }\n        }\n        return null;\n      }\n    }\n  }, {\n    key: \"classNames\",\n    get: function get() {\n      return this.classList.toString();\n    }\n  }]);\n  return HTMLElement;\n}(Node); // https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\nexport { HTMLElement as default };\nvar kMarkupPattern = /<!--[^]*?(?=-->)-->|<(\\/?)([a-z][-.:0-9_a-z]*)\\s*([^>]*?)(\\/?)>/ig;\n// <(?<tag>[^\\s]*)(.*)>(.*)</\\k<tag>>\n// <([a-z][-.:0-9_a-z]*)\\s*\\/>\n// <(area|base|br|col|hr|img|input|link|meta|source)\\s*(.*)\\/?>\n// <(area|base|br|col|hr|img|input|link|meta|source)\\s*(.*)\\/?>|<(?<tag>[^\\s]*)(.*)>(.*)</\\k<tag>>\nvar kAttributePattern = /(^|\\s)(id|class)\\s*=\\s*(\"([^\"]*)\"|'([^']*)'|(\\S+))/ig;\nvar kSelfClosingElements = {\n  area: true,\n  AREA: true,\n  base: true,\n  BASE: true,\n  br: true,\n  BR: true,\n  col: true,\n  COL: true,\n  hr: true,\n  HR: true,\n  img: true,\n  IMG: true,\n  input: true,\n  INPUT: true,\n  link: true,\n  LINK: true,\n  meta: true,\n  META: true,\n  source: true,\n  SOURCE: true,\n  embed: true,\n  EMBED: true,\n  param: true,\n  PARAM: true,\n  track: true,\n  TRACK: true,\n  wbr: true,\n  WBR: true\n};\nvar kElementsClosedByOpening = {\n  li: {\n    li: true,\n    LI: true\n  },\n  LI: {\n    li: true,\n    LI: true\n  },\n  p: {\n    p: true,\n    div: true,\n    P: true,\n    DIV: true\n  },\n  P: {\n    p: true,\n    div: true,\n    P: true,\n    DIV: true\n  },\n  b: {\n    div: true,\n    DIV: true\n  },\n  B: {\n    div: true,\n    DIV: true\n  },\n  td: {\n    td: true,\n    th: true,\n    TD: true,\n    TH: true\n  },\n  TD: {\n    td: true,\n    th: true,\n    TD: true,\n    TH: true\n  },\n  th: {\n    td: true,\n    th: true,\n    TD: true,\n    TH: true\n  },\n  TH: {\n    td: true,\n    th: true,\n    TD: true,\n    TH: true\n  },\n  h1: {\n    h1: true,\n    H1: true\n  },\n  H1: {\n    h1: true,\n    H1: true\n  },\n  h2: {\n    h2: true,\n    H2: true\n  },\n  H2: {\n    h2: true,\n    H2: true\n  },\n  h3: {\n    h3: true,\n    H3: true\n  },\n  H3: {\n    h3: true,\n    H3: true\n  },\n  h4: {\n    h4: true,\n    H4: true\n  },\n  H4: {\n    h4: true,\n    H4: true\n  },\n  h5: {\n    h5: true,\n    H5: true\n  },\n  H5: {\n    h5: true,\n    H5: true\n  },\n  h6: {\n    h6: true,\n    H6: true\n  },\n  H6: {\n    h6: true,\n    H6: true\n  }\n};\nvar kElementsClosedByClosing = {\n  li: {\n    ul: true,\n    ol: true,\n    UL: true,\n    OL: true\n  },\n  LI: {\n    ul: true,\n    ol: true,\n    UL: true,\n    OL: true\n  },\n  a: {\n    div: true,\n    DIV: true\n  },\n  A: {\n    div: true,\n    DIV: true\n  },\n  b: {\n    div: true,\n    DIV: true\n  },\n  B: {\n    div: true,\n    DIV: true\n  },\n  i: {\n    div: true,\n    DIV: true\n  },\n  I: {\n    div: true,\n    DIV: true\n  },\n  p: {\n    div: true,\n    DIV: true\n  },\n  P: {\n    div: true,\n    DIV: true\n  },\n  td: {\n    tr: true,\n    table: true,\n    TR: true,\n    TABLE: true\n  },\n  TD: {\n    tr: true,\n    table: true,\n    TR: true,\n    TABLE: true\n  },\n  th: {\n    tr: true,\n    table: true,\n    TR: true,\n    TABLE: true\n  },\n  TH: {\n    tr: true,\n    table: true,\n    TR: true,\n    TABLE: true\n  }\n};\nvar frameflag = 'documentfragmentcontainer';\n/**\n * Parses HTML and returns a root element\n * Parse a chuck of HTML source.\n * @param  {string} data      html\n * @return {HTMLElement}      root element\n */\nexport function base_parse(data) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    lowerCaseTagName: false,\n    comment: false\n  };\n  var elements = options.blockTextElements || {\n    script: true,\n    noscript: true,\n    style: true,\n    pre: true\n  };\n  var element_names = Object.keys(elements);\n  var kBlockTextElements = element_names.map(function (it) {\n    return new RegExp(it, 'i');\n  });\n  var kIgnoreElements = element_names.filter(function (it) {\n    return elements[it];\n  }).map(function (it) {\n    return new RegExp(it, 'i');\n  });\n  function element_should_be_ignore(tag) {\n    return kIgnoreElements.some(function (it) {\n      return it.test(tag);\n    });\n  }\n  function is_block_text_element(tag) {\n    return kBlockTextElements.some(function (it) {\n      return it.test(tag);\n    });\n  }\n  var root = new HTMLElement(null, {}, '', null);\n  var currentParent = root;\n  var stack = [root];\n  var lastTextPos = -1;\n  var match;\n  // https://github.com/taoqf/node-html-parser/issues/38\n  data = \"<\".concat(frameflag, \">\").concat(data, \"</\").concat(frameflag, \">\");\n  var _loop = function _loop() {\n    if (lastTextPos > -1) {\n      if (lastTextPos + match[0].length < kMarkupPattern.lastIndex) {\n        // if has content\n        var text = data.substring(lastTextPos, kMarkupPattern.lastIndex - match[0].length);\n        currentParent.appendChild(new TextNode(text, currentParent));\n      }\n    }\n    lastTextPos = kMarkupPattern.lastIndex;\n    if (match[2] === frameflag) {\n      return \"continue\";\n    }\n    if (match[0][1] === '!') {\n      // this is a comment\n      if (options.comment) {\n        // Only keep what is in between <!-- and -->\n        var _text = data.substring(lastTextPos - 3, lastTextPos - match[0].length + 4);\n        currentParent.appendChild(new CommentNode(_text, currentParent));\n      }\n      return \"continue\";\n    }\n    if (options.lowerCaseTagName) {\n      match[2] = match[2].toLowerCase();\n    }\n    if (!match[1]) {\n      // not </ tags\n      var attrs = {};\n      for (var attMatch; attMatch = kAttributePattern.exec(match[3]);) {\n        attrs[attMatch[2].toLowerCase()] = attMatch[4] || attMatch[5] || attMatch[6];\n      }\n      var tagName = currentParent.rawTagName;\n      if (!match[4] && kElementsClosedByOpening[tagName]) {\n        if (kElementsClosedByOpening[tagName][match[2]]) {\n          stack.pop();\n          currentParent = arr_back(stack);\n        }\n      }\n      // ignore container tag we add above\n      // https://github.com/taoqf/node-html-parser/issues/38\n      currentParent = currentParent.appendChild(new HTMLElement(match[2], attrs, match[3], null));\n      stack.push(currentParent);\n      if (is_block_text_element(match[2])) {\n        // a little test to find next </script> or </style> ...\n        var closeMarkup = \"</\".concat(match[2], \">\");\n        var index = function () {\n          if (options.lowerCaseTagName) {\n            return data.toLocaleLowerCase().indexOf(closeMarkup, kMarkupPattern.lastIndex);\n          }\n          return data.indexOf(closeMarkup, kMarkupPattern.lastIndex);\n        }();\n        if (element_should_be_ignore(match[2])) {\n          var _text2;\n          if (index === -1) {\n            // there is no matching ending for the text element.\n            _text2 = data.substr(kMarkupPattern.lastIndex);\n          } else {\n            _text2 = data.substring(kMarkupPattern.lastIndex, index);\n          }\n          if (_text2.length > 0) {\n            currentParent.appendChild(new TextNode(_text2, currentParent));\n          }\n        }\n        if (index === -1) {\n          lastTextPos = kMarkupPattern.lastIndex = data.length + 1;\n        } else {\n          lastTextPos = kMarkupPattern.lastIndex = index + closeMarkup.length;\n          match[1] = 'true';\n        }\n      }\n    }\n    if (match[1] || match[4] || kSelfClosingElements[match[2]]) {\n      // </ or /> or <br> etc.\n      while (true) {\n        if (currentParent.rawTagName === match[2]) {\n          stack.pop();\n          currentParent = arr_back(stack);\n          break;\n        } else {\n          var _tagName = currentParent.tagName;\n          // Trying to close current tag, and move on\n          if (kElementsClosedByClosing[_tagName]) {\n            if (kElementsClosedByClosing[_tagName][match[2]]) {\n              stack.pop();\n              currentParent = arr_back(stack);\n              continue;\n            }\n          }\n          // Use aggressive strategy to handle unmatching markups.\n          break;\n        }\n      }\n    }\n  };\n  while (match = kMarkupPattern.exec(data)) {\n    var _ret = _loop();\n    if (_ret === \"continue\") continue;\n  }\n  return stack;\n}\n/**\n * Parses HTML and returns a root element\n * Parse a chuck of HTML source.\n */\nexport function parse(data) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    lowerCaseTagName: false,\n    comment: false\n  };\n  var stack = base_parse(data, options);\n  var _stack = _slicedToArray(stack, 1),\n    root = _stack[0];\n  var _loop2 = function _loop2() {\n    // Handle each error elements.\n    var last = stack.pop();\n    var oneBefore = arr_back(stack);\n    if (last.parentNode && last.parentNode.parentNode) {\n      if (last.parentNode === oneBefore && last.tagName === oneBefore.tagName) {\n        // Pair error case <h3> <h3> handle : Fixes to <h3> </h3>\n        oneBefore.removeChild(last);\n        last.childNodes.forEach(function (child) {\n          oneBefore.parentNode.appendChild(child);\n        });\n        stack.pop();\n      } else {\n        // Single error  <div> <h3> </div> handle: Just removes <h3>\n        oneBefore.removeChild(last);\n        last.childNodes.forEach(function (child) {\n          oneBefore.appendChild(child);\n        });\n      }\n    } else {\n      // If it's final element just skip.\n    }\n  };\n  while (stack.length > 1) {\n    _loop2();\n  }\n  // response.childNodes.forEach((node) => {\n  // \tif (node instanceof HTMLElement) {\n  // \t\tnode.parentNode = null;\n  // \t}\n  // });\n  return root;\n}","map":null,"metadata":{},"sourceType":"module"}