{"ast":null,"code":"var createCustomError = require('../utils/createCustomError');\nvar generate = require('../definition-syntax/generate');\nvar defaultLoc = {\n  offset: 0,\n  line: 1,\n  column: 1\n};\nfunction locateMismatch(matchResult, node) {\n  var tokens = matchResult.tokens;\n  var longestMatch = matchResult.longestMatch;\n  var mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;\n  var badNode = mismatchNode !== node ? mismatchNode : null;\n  var mismatchOffset = 0;\n  var mismatchLength = 0;\n  var entries = 0;\n  var css = '';\n  var start;\n  var end;\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i].value;\n    if (i === longestMatch) {\n      mismatchLength = token.length;\n      mismatchOffset = css.length;\n    }\n    if (badNode !== null && tokens[i].node === badNode) {\n      if (i <= longestMatch) {\n        entries++;\n      } else {\n        entries = 0;\n      }\n    }\n    css += token;\n  }\n  if (longestMatch === tokens.length || entries > 1) {\n    // last\n    start = fromLoc(badNode || node, 'end') || buildLoc(defaultLoc, css);\n    end = buildLoc(start);\n  } else {\n    start = fromLoc(badNode, 'start') || buildLoc(fromLoc(node, 'start') || defaultLoc, css.slice(0, mismatchOffset));\n    end = fromLoc(badNode, 'end') || buildLoc(start, css.substr(mismatchOffset, mismatchLength));\n  }\n  return {\n    css: css,\n    mismatchOffset: mismatchOffset,\n    mismatchLength: mismatchLength,\n    start: start,\n    end: end\n  };\n}\nfunction fromLoc(node, point) {\n  var value = node && node.loc && node.loc[point];\n  if (value) {\n    return 'line' in value ? buildLoc(value) : value;\n  }\n  return null;\n}\nfunction buildLoc(_ref, extra) {\n  var offset = _ref.offset,\n    line = _ref.line,\n    column = _ref.column;\n  var loc = {\n    offset: offset,\n    line: line,\n    column: column\n  };\n  if (extra) {\n    var lines = extra.split(/\\n|\\r\\n?|\\f/);\n    loc.offset += extra.length;\n    loc.line += lines.length - 1;\n    loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;\n  }\n  return loc;\n}\nvar SyntaxReferenceError = function SyntaxReferenceError(type, referenceName) {\n  var error = createCustomError('SyntaxReferenceError', type + (referenceName ? ' `' + referenceName + '`' : ''));\n  error.reference = referenceName;\n  return error;\n};\nvar SyntaxMatchError = function SyntaxMatchError(message, syntax, node, matchResult) {\n  var error = createCustomError('SyntaxMatchError', message);\n  var _locateMismatch = locateMismatch(matchResult, node),\n    css = _locateMismatch.css,\n    mismatchOffset = _locateMismatch.mismatchOffset,\n    mismatchLength = _locateMismatch.mismatchLength,\n    start = _locateMismatch.start,\n    end = _locateMismatch.end;\n  error.rawMessage = message;\n  error.syntax = syntax ? generate(syntax) : '<generic>';\n  error.css = css;\n  error.mismatchOffset = mismatchOffset;\n  error.mismatchLength = mismatchLength;\n  error.message = message + '\\n' + '  syntax: ' + error.syntax + '\\n' + '   value: ' + (css || '<empty string>') + '\\n' + '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';\n  Object.assign(error, start);\n  error.loc = {\n    source: node && node.loc && node.loc.source || '<unknown>',\n    start: start,\n    end: end\n  };\n  return error;\n};\nmodule.exports = {\n  SyntaxReferenceError: SyntaxReferenceError,\n  SyntaxMatchError: SyntaxMatchError\n};","map":null,"metadata":{},"sourceType":"script"}