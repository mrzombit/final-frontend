{"ast":null,"code":"import { compose, castArray } from '@react-pdf/fns';\nimport parse$1 from 'postcss-value-parser/lib/parse';\nimport parseUnit from 'postcss-value-parser/lib/unit';\nimport hlsToHex from 'hsl-to-hex';\nimport colorString from 'color-string';\nimport _extends from '@babel/runtime/helpers/extends';\nimport matchMedia from 'media-engine';\n\n// https://developer.mozilla.org/en-US/docs/Web/CSS/flex#values\n\n// TODO: change flex defaults to [0, 1, 'auto'] as in spec in next major release\nvar flexDefaults = [1, 1, 0];\nvar flexAuto = [1, 1, 'auto'];\nvar expandFlex = function expandFlex(key, value) {\n  var defaults = flexDefaults;\n  var matches = [];\n  if (value === 'auto') {\n    defaults = flexAuto;\n  } else {\n    matches = (\"\" + value).split(' ');\n  }\n  var flexGrow = matches[0] || defaults[0];\n  var flexShrink = matches[1] || defaults[1];\n  var flexBasis = matches[2] || defaults[2];\n  return {\n    flexGrow: flexGrow,\n    flexShrink: flexShrink,\n    flexBasis: flexBasis\n  };\n};\n\n/* eslint-disable no-plusplus */\nvar BOX_MODEL_UNITS = 'px,in,mm,cm,pt,%,vw,vh';\nvar logError = function logError(style, value) {\n  console.error(\"\\n    @react-pdf/stylesheet parsing error:\\n\\n    \" + style + \": \" + value + \",\\n    \" + ' '.repeat(style.length + 2) + \"^\\n    Unsupported \" + style + \" value format\\n  \");\n};\nvar expandBoxModel = function expandBoxModel(_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n    expandsTo = _ref.expandsTo,\n    _ref$maxValues = _ref.maxValues,\n    maxValues = _ref$maxValues === void 0 ? 1 : _ref$maxValues,\n    _ref$autoSupported = _ref.autoSupported,\n    autoSupported = _ref$autoSupported === void 0 ? false : _ref$autoSupported;\n  return function (model, value) {\n    var _ref2;\n    var nodes = parse$1(\"\" + value);\n    var parts = [];\n    for (var i = 0; i < nodes.length; i++) {\n      var node = nodes[i];\n\n      // value contains `calc`, `url` or other css function\n      // `,`, `/` or strings that unsupported by margin and padding\n      if (node.type === 'function' || node.type === 'string' || node.type === 'div') {\n        logError(model, value);\n        return {};\n      }\n      if (node.type === 'word') {\n        if (node.value === 'auto' && autoSupported) {\n          parts.push(node.value);\n        } else {\n          var result = parseUnit(node.value);\n\n          // when unit isn't specified this condition is true\n          if (result && BOX_MODEL_UNITS.includes(result.unit)) {\n            parts.push(node.value);\n          } else {\n            logError(model, value);\n            return {};\n          }\n        }\n      }\n    }\n\n    // checks that we have enough parsed values\n    if (parts.length > maxValues) {\n      logError(model, value);\n      return {};\n    }\n    var first = parts[0];\n    if (expandsTo) {\n      var second = parts[1] || parts[0];\n      var third = parts[2] || parts[0];\n      var fourth = parts[3] || parts[1] || parts[0];\n      return expandsTo({\n        first: first,\n        second: second,\n        third: third,\n        fourth: fourth\n      });\n    }\n    return _ref2 = {}, _ref2[model] = first, _ref2;\n  };\n};\nvar processMargin = expandBoxModel({\n  expandsTo: function expandsTo(_ref) {\n    var first = _ref.first,\n      second = _ref.second,\n      third = _ref.third,\n      fourth = _ref.fourth;\n    return {\n      marginTop: first,\n      marginRight: second,\n      marginBottom: third,\n      marginLeft: fourth\n    };\n  },\n  maxValues: 4,\n  autoSupported: true\n});\nvar processMarginVertical = expandBoxModel({\n  expandsTo: function expandsTo(_ref2) {\n    var first = _ref2.first,\n      second = _ref2.second;\n    return {\n      marginTop: first,\n      marginBottom: second\n    };\n  },\n  maxValues: 2,\n  autoSupported: true\n});\nvar processMarginHorizontal = expandBoxModel({\n  expandsTo: function expandsTo(_ref3) {\n    var first = _ref3.first,\n      second = _ref3.second;\n    return {\n      marginRight: first,\n      marginLeft: second\n    };\n  },\n  maxValues: 2,\n  autoSupported: true\n});\nvar processMarginSingle = expandBoxModel({\n  autoSupported: true\n});\nvar BORDER_SHORTHAND_REGEX = /(-?\\d+(\\.\\d+)?(px|in|mm|cm|pt|vw|vh|px)?)\\s(\\S+)\\s(.+)/;\nvar matchBorderShorthand = function matchBorderShorthand(value) {\n  return value.match(BORDER_SHORTHAND_REGEX) || [];\n};\nvar expandBorders = function expandBorders(key, value) {\n  var match = matchBorderShorthand(\"\" + value);\n  if (match) {\n    var color = match[5] || value;\n    var style = match[4] || value;\n    var width = match[1] || value;\n    if (key.match(/(Top|Right|Bottom|Left)$/)) {\n      var _ref;\n      return _ref = {}, _ref[key + \"Color\"] = color, _ref[key + \"Style\"] = style, _ref[key + \"Width\"] = width, _ref;\n    }\n    if (key.match(/Color$/)) {\n      return {\n        borderTopColor: color,\n        borderRightColor: color,\n        borderBottomColor: color,\n        borderLeftColor: color\n      };\n    }\n    if (key.match(/Style$/)) {\n      return {\n        borderTopStyle: style,\n        borderRightStyle: style,\n        borderBottomStyle: style,\n        borderLeftStyle: style\n      };\n    }\n    if (key.match(/Width$/)) {\n      return {\n        borderTopWidth: width,\n        borderRightWidth: width,\n        borderBottomWidth: width,\n        borderLeftWidth: width\n      };\n    }\n    if (key.match(/Radius$/)) {\n      return {\n        borderTopLeftRadius: value,\n        borderTopRightRadius: value,\n        borderBottomRightRadius: value,\n        borderBottomLeftRadius: value\n      };\n    }\n    return {\n      borderTopColor: color,\n      borderTopStyle: style,\n      borderTopWidth: width,\n      borderRightColor: color,\n      borderRightStyle: style,\n      borderRightWidth: width,\n      borderBottomColor: color,\n      borderBottomStyle: style,\n      borderBottomWidth: width,\n      borderLeftColor: color,\n      borderLeftStyle: style,\n      borderLeftWidth: width\n    };\n  }\n  return value;\n};\nvar processPadding = expandBoxModel({\n  expandsTo: function expandsTo(_ref) {\n    var first = _ref.first,\n      second = _ref.second,\n      third = _ref.third,\n      fourth = _ref.fourth;\n    return {\n      paddingTop: first,\n      paddingRight: second,\n      paddingBottom: third,\n      paddingLeft: fourth\n    };\n  },\n  maxValues: 4\n});\nvar processPaddingVertical = expandBoxModel({\n  expandsTo: function expandsTo(_ref2) {\n    var first = _ref2.first,\n      second = _ref2.second;\n    return {\n      paddingTop: first,\n      paddingBottom: second\n    };\n  },\n  maxValues: 2\n});\nvar processPaddingHorizontal = expandBoxModel({\n  expandsTo: function expandsTo(_ref3) {\n    var first = _ref3.first,\n      second = _ref3.second;\n    return {\n      paddingRight: first,\n      paddingLeft: second\n    };\n  },\n  maxValues: 2\n});\nvar processPaddingSingle = expandBoxModel();\nvar expandObjectPosition = function expandObjectPosition(key, value) {\n  var match = (\"\" + value).split(' ');\n  return {\n    objectPositionX: (match === null || match === void 0 ? void 0 : match[0]) || value,\n    objectPositionY: (match === null || match === void 0 ? void 0 : match[1]) || value\n  };\n};\nvar Y_AXIS_SHORTHANDS = {\n  top: true,\n  bottom: true\n};\nvar sortTransformOriginPair = function sortTransformOriginPair(a, b) {\n  if (Y_AXIS_SHORTHANDS[a]) return 1;\n  if (Y_AXIS_SHORTHANDS[b]) return -1;\n  return 0;\n};\nvar getTransformOriginPair = function getTransformOriginPair(values) {\n  if (!values || values.length === 0) return ['center', 'center'];\n  var pair = values.length === 1 ? [values[0], 'center'] : values;\n  return pair.sort(sortTransformOriginPair);\n};\n\n// Transforms shorthand transformOrigin values\nvar expandTransformOrigin = function expandTransformOrigin(key, value) {\n  var match = (\"\" + value).split(' ');\n  var pair = getTransformOriginPair(match);\n  return {\n    transformOriginX: pair[0],\n    transformOriginY: pair[1]\n  };\n};\nvar expandGap = function expandGap(key, value) {\n  var match = (\"\" + value).split(' ');\n  return {\n    rowGap: (match === null || match === void 0 ? void 0 : match[0]) || value,\n    columnGap: (match === null || match === void 0 ? void 0 : match[1]) || value\n  };\n};\nvar shorthands = {\n  flex: expandFlex,\n  gap: expandGap,\n  margin: processMargin,\n  marginHorizontal: processMarginHorizontal,\n  marginVertical: processMarginVertical,\n  marginTop: processMarginSingle,\n  marginRight: processMarginSingle,\n  marginBottom: processMarginSingle,\n  marginLeft: processMarginSingle,\n  padding: processPadding,\n  paddingHorizontal: processPaddingHorizontal,\n  paddingVertical: processPaddingVertical,\n  paddingTop: processPaddingSingle,\n  paddingRight: processPaddingSingle,\n  paddingBottom: processPaddingSingle,\n  paddingLeft: processPaddingSingle,\n  border: expandBorders,\n  borderTop: expandBorders,\n  borderRight: expandBorders,\n  borderBottom: expandBorders,\n  borderLeft: expandBorders,\n  borderColor: expandBorders,\n  borderRadius: expandBorders,\n  borderStyle: expandBorders,\n  borderWidth: expandBorders,\n  objectPosition: expandObjectPosition,\n  transformOrigin: expandTransformOrigin\n};\n\n/**\n * Transforms style key-value\n *\n * @param {String} key style key\n * @param {String} value style value\n * @returns {String | Number} transformed style values\n */\nvar expandStyle = function expandStyle(key, value) {\n  var _ref;\n  return shorthands[key] ? shorthands[key](key, value) : (_ref = {}, _ref[key] = value, _ref);\n};\n\n/**\n * Expand the shorthand properties.\n *\n * @param { Object } style object\n * @returns { Object } expanded style object\n */\nvar expand = function expand(style) {\n  if (!style) return style;\n  var propsArray = Object.keys(style);\n  var resolvedStyle = {};\n  for (var i = 0; i < propsArray.length; i += 1) {\n    var key = propsArray[i];\n    var value = style[key];\n    var extended = expandStyle(key, value);\n    var keys = Object.keys(extended);\n    for (var j = 0; j < keys.length; j += 1) {\n      var propName = keys[j];\n      var propValue = extended[propName];\n      resolvedStyle[propName] = propValue;\n    }\n  }\n  return resolvedStyle;\n};\n\n/**\n * Remove nil values from array\n *\n * @param {Array} array\n * @returns {Array} array without nils\n */\nvar compact = function compact(array) {\n  return array.filter(Boolean);\n};\n\n/**\n * Merges style objects array\n *\n * @param {Array} style objects array\n * @returns {Object} merged style object\n */\nvar mergeStyles = function mergeStyles(styles) {\n  return styles.reduce(function (acc, style) {\n    var s = Array.isArray(style) ? flatten(style) : style;\n    Object.keys(s).forEach(function (key) {\n      if (s[key] !== null && s[key] !== undefined) {\n        acc[key] = s[key];\n      }\n    });\n    return acc;\n  }, {});\n};\n\n/**\n * Flattens an array of style objects, into one aggregated style object.\n *\n * @param {Array} style objects array\n * @returns {Object} flatted style object\n */\nvar flatten = compose(mergeStyles, compact, castArray);\n\n/**\n * Parses scalar value in value and unit pairs\n *\n * @param {String} scalar value\n * @returns {Object} parsed value\n */\nvar parseValue = function parseValue(value) {\n  var match = /^(-?\\d*\\.?\\d+)(in|mm|cm|pt|vh|vw|px)?$/g.exec(value);\n  return match ? {\n    value: parseFloat(match[1], 10),\n    unit: match[2] || 'pt'\n  } : {\n    value: value,\n    unit: undefined\n  };\n};\n\n/**\n * Transform given scalar value\n *\n * @param {Object} container\n * @param {String} styles value\n * @returns {Object} transformed value\n */\nvar transformUnit = function transformUnit(container, value) {\n  var scalar = parseValue(value);\n  var dpi = container.dpi || 72;\n  var mmFactor = 1 / 25.4 * dpi;\n  var cmFactor = 1 / 2.54 * dpi;\n  switch (scalar.unit) {\n    case 'in':\n      return scalar.value * dpi;\n    case 'mm':\n      return scalar.value * mmFactor;\n    case 'cm':\n      return scalar.value * cmFactor;\n    case 'vh':\n      return scalar.value * (container.height / 100);\n    case 'vw':\n      return scalar.value * (container.width / 100);\n    default:\n      return scalar.value;\n  }\n};\nvar isRgb = function isRgb(value) {\n  return /rgba?/g.test(value);\n};\nvar isHsl = function isHsl(value) {\n  return /hsla?/g.test(value);\n};\n\n/**\n * Transform rgb color to hexa\n *\n * @param {String} styles value\n * @returns {Object} transformed value\n */\nvar parseRgb = function parseRgb(value) {\n  var rgb = colorString.get.rgb(value);\n  return colorString.to.hex(rgb);\n};\n\n/**\n * Transform Hsl color to hexa\n *\n * @param {String} styles value\n * @returns {Object} transformed value\n */\nvar parseHsl = function parseHsl(value) {\n  var hsl = colorString.get.hsl(value).map(Math.round);\n  var hex = hlsToHex.apply(void 0, hsl);\n  return hex.toUpperCase();\n};\n\n/**\n * Transform given color to hexa\n *\n * @param {String} styles value\n * @returns {Object} transformed value\n */\nvar transformColor = function transformColor(value) {\n  if (isRgb(value)) return parseRgb(value);\n  if (isHsl(value)) return parseHsl(value);\n  return value;\n};\nvar parse = function parse(transformString) {\n  var transforms = transformString.trim().split(/\\) |\\)/);\n\n  // Handle \"initial\", \"inherit\", \"unset\".\n  if (transforms.length === 1) {\n    return [[transforms[0], true]];\n  }\n  var parsed = [];\n  for (var i = 0; i < transforms.length; i += 1) {\n    var transform = transforms[i];\n    if (transform) {\n      var _transform$split = transform.split('('),\n        name = _transform$split[0],\n        rawValue = _transform$split[1];\n      var splitChar = rawValue.indexOf(',') >= 0 ? ',' : ' ';\n      var value = rawValue.split(splitChar).map(function (val) {\n        return val.trim();\n      });\n      parsed.push({\n        operation: name,\n        value: value\n      });\n    }\n  }\n  return parsed;\n};\nvar parseAngle = function parseAngle(value) {\n  var unitsRegexp = /(-?\\d*\\.?\\d*)(\\w*)?/i;\n  var _unitsRegexp$exec = unitsRegexp.exec(value),\n    angle = _unitsRegexp$exec[1],\n    unit = _unitsRegexp$exec[2];\n  var number = Number.parseFloat(angle);\n  return unit === 'rad' ? number * 180 / Math.PI : number;\n};\nvar normalizeTransformOperation = function normalizeTransformOperation(_ref) {\n  var operation = _ref.operation,\n    value = _ref.value;\n  switch (operation) {\n    case 'scale':\n      {\n        var _value$map = value.map(function (num) {\n            return Number.parseFloat(num);\n          }),\n          scaleX = _value$map[0],\n          _value$map$ = _value$map[1],\n          scaleY = _value$map$ === void 0 ? scaleX : _value$map$;\n        return {\n          operation: 'scale',\n          value: [scaleX, scaleY]\n        };\n      }\n    case 'scaleX':\n      {\n        return {\n          operation: 'scale',\n          value: [Number.parseFloat(value), 1]\n        };\n      }\n    case 'scaleY':\n      {\n        return {\n          operation: 'scale',\n          value: [1, Number.parseFloat(value)]\n        };\n      }\n    case 'rotate':\n      {\n        return {\n          operation: 'rotate',\n          value: [parseAngle(value)]\n        };\n      }\n    case 'translate':\n      {\n        return {\n          operation: 'translate',\n          value: value.map(function (num) {\n            return Number.parseFloat(num);\n          })\n        };\n      }\n    case 'translateX':\n      {\n        return {\n          operation: 'translate',\n          value: [Number.parseFloat(value), 0]\n        };\n      }\n    case 'translateY':\n      {\n        return {\n          operation: 'translate',\n          value: [0, Number.parseFloat(value)]\n        };\n      }\n    case 'skew':\n      {\n        return {\n          operation: 'skew',\n          value: value.map(parseAngle)\n        };\n      }\n    case 'skewX':\n      {\n        return {\n          operation: 'skew',\n          value: [parseAngle(value), 0]\n        };\n      }\n    case 'skewY':\n      {\n        return {\n          operation: 'skew',\n          value: [0, parseAngle(value)]\n        };\n      }\n    default:\n      {\n        return {\n          operation: operation,\n          value: value.map(function (num) {\n            return Number.parseFloat(num);\n          })\n        };\n      }\n  }\n};\nvar normalize = function normalize(operations) {\n  return operations.map(function (operation) {\n    return normalizeTransformOperation(operation);\n  });\n};\nvar processTransform = function processTransform(value) {\n  if (typeof value !== 'string') return value;\n  return normalize(parse(value));\n};\nvar FONT_WEIGHTS = {\n  thin: 100,\n  hairline: 100,\n  ultralight: 200,\n  extralight: 200,\n  light: 300,\n  normal: 400,\n  medium: 500,\n  semibold: 600,\n  demibold: 600,\n  bold: 700,\n  ultrabold: 800,\n  extrabold: 800,\n  heavy: 900,\n  black: 900\n};\nvar processFontWeight = function processFontWeight(value) {\n  if (!value) return FONT_WEIGHTS.normal;\n  if (typeof value === 'number') return value;\n  var lv = value.toLowerCase();\n  if (FONT_WEIGHTS[lv]) return FONT_WEIGHTS[lv];\n  return value;\n};\nvar matchNumber = function matchNumber(value) {\n  return typeof value === 'string' && /^-?\\d*\\.?\\d*$/.test(value);\n};\nvar castFloat = function castFloat(value) {\n  if (typeof value !== 'string') return value;\n  if (matchNumber(value)) return parseFloat(value, 10);\n  return value;\n};\nvar offsetKeyword = function offsetKeyword(value) {\n  switch (value) {\n    case 'top':\n    case 'left':\n      return '0%';\n    case 'right':\n    case 'bottom':\n      return '100%';\n    case 'center':\n      return '50%';\n    default:\n      return null;\n  }\n};\nvar transformObjectPosition = function transformObjectPosition(value) {\n  return offsetKeyword(value) || castFloat(value);\n};\nvar transformTransformOrigin = function transformTransformOrigin(value) {\n  return offsetKeyword(value) || castFloat(value);\n};\nvar handlers = {\n  transform: processTransform,\n  fontWeight: processFontWeight,\n  objectPositionX: transformObjectPosition,\n  objectPositionY: transformObjectPosition,\n  transformOriginX: transformTransformOrigin,\n  transformOriginY: transformTransformOrigin\n};\nvar transformStyle = function transformStyle(key, value, container) {\n  var result = handlers[key] ? handlers[key](value) : value;\n  return transformColor(transformUnit(container, castFloat(result)));\n};\n\n/**\n * Transform styles values\n *\n * @param {Object} styles object\n * @returns {Object} transformed styles\n */\nvar transform = function transform(container) {\n  return function (style) {\n    if (!style) return style;\n    var propsArray = Object.keys(style);\n    var resolvedStyle = {};\n    for (var i = 0; i < propsArray.length; i += 1) {\n      var key = propsArray[i];\n      var value = style[key];\n      var transformed = transformStyle(key, value, container);\n      resolvedStyle[key] = transformed;\n    }\n    return resolvedStyle;\n  };\n};\n\n/**\n * Resolves media queries in styles object\n *\n * @param {Object} container\n * @param {Object} styles object\n */\nvar resolveMediaQueries = function resolveMediaQueries(container, styles) {\n  return Object.keys(styles).reduce(function (acc, key) {\n    var _extends2;\n    if (/@media/.test(key)) {\n      var _matchMedia;\n      return _extends({}, acc, matchMedia((_matchMedia = {}, _matchMedia[key] = styles[key], _matchMedia), container));\n    }\n    return _extends({}, acc, (_extends2 = {}, _extends2[key] = styles[key], _extends2));\n  }, {});\n};\n\n/**\n * Resolves styles\n *\n * @param {Object} container\n * @param {Object} style object\n * @returns {Object} resolved style object\n */\nvar resolveStyles = function resolveStyles(container, style) {\n  var computeMediaQueries = function computeMediaQueries(value) {\n    return resolveMediaQueries(container, value);\n  };\n  return compose(transform(container), expand, computeMediaQueries, flatten)(style);\n};\nexport { resolveStyles as default, flatten, processTransform, transformColor };","map":null,"metadata":{},"sourceType":"module"}