{"ast":null,"code":"import _toConsumableArray from \"/Users/koonk/Documents/GitHub/CE65-20/packages/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/koonk/Documents/GitHub/CE65-20/packages/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/koonk/Documents/GitHub/CE65-20/packages/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/koonk/Documents/GitHub/CE65-20/packages/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/koonk/Documents/GitHub/CE65-20/packages/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/koonk/Documents/GitHub/CE65-20/packages/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { map } from '../../utils/array.js';\nimport { getSafeProperty } from '../../utils/customs.js';\nimport { factory } from '../../utils/factory.js';\nimport { isArray, isConstantNode, isMatrix, isNode, isString, typeOf } from '../../utils/is.js';\nimport { escape } from '../../utils/string.js';\nvar name = 'IndexNode';\nvar dependencies = ['Node', 'size'];\nexport var createIndexNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var Node = _ref.Node,\n    size = _ref.size;\n  var IndexNode = /*#__PURE__*/function (_Node) {\n    _inherits(IndexNode, _Node);\n    /**\n     * @constructor IndexNode\n     * @extends Node\n     *\n     * Describes a subset of a matrix or an object property.\n     * Cannot be used on its own, needs to be used within an AccessorNode or\n     * AssignmentNode.\n     *\n     * @param {Node[]} dimensions\n     * @param {boolean} [dotNotation=false]\n     *     Optional property describing whether this index was written using dot\n     *     notation like `a.b`, or using bracket notation like `a[\"b\"]`\n     *     (which is the default). This property is used for string conversion.\n     */\n    function IndexNode(dimensions, dotNotation) {\n      var _this;\n      _classCallCheck(this, IndexNode);\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(IndexNode).call(this));\n      _this.dimensions = dimensions;\n      _this.dotNotation = dotNotation || false;\n\n      // validate input\n      if (!Array.isArray(dimensions) || !dimensions.every(isNode)) {\n        throw new TypeError('Array containing Nodes expected for parameter \"dimensions\"');\n      }\n      if (_this.dotNotation && !_this.isObjectProperty()) {\n        throw new Error('dotNotation only applicable for object properties');\n      }\n      return _this;\n    }\n    _createClass(IndexNode, [{\n      key: \"_compile\",\n      /**\n       * Compile a node into a JavaScript function.\n       * This basically pre-calculates as much as possible and only leaves open\n       * calculations which depend on a dynamic scope with variables.\n       * @param {Object} math     Math.js namespace with functions and constants.\n       * @param {Object} argNames An object with argument names as key and `true`\n       *                          as value. Used in the SymbolNode to optimize\n       *                          for arguments from user assigned functions\n       *                          (see FunctionAssignmentNode) or special symbols\n       *                          like `end` (see IndexNode).\n       * @return {function} Returns a function which can be called like:\n       *                        evalNode(scope: Object, args: Object, context: *)\n       */\n      value: function _compile(math, argNames) {\n        // TODO: implement support for bignumber (currently bignumbers are silently\n        //       reduced to numbers when changing the value to zero-based)\n\n        // TODO: Optimization: when the range values are ConstantNodes,\n        //       we can beforehand resolve the zero-based value\n\n        // optimization for a simple object property\n        var evalDimensions = map(this.dimensions, function (dimension, i) {\n          var needsEnd = dimension.filter(function (node) {\n            return node.isSymbolNode && node.name === 'end';\n          }).length > 0;\n          if (needsEnd) {\n            // SymbolNode 'end' is used inside the index,\n            // like in `A[end]` or `A[end - 2]`\n            var childArgNames = Object.create(argNames);\n            childArgNames.end = true;\n            var _evalDimension = dimension._compile(math, childArgNames);\n            return function evalDimension(scope, args, context) {\n              if (!isMatrix(context) && !isArray(context) && !isString(context)) {\n                throw new TypeError('Cannot resolve \"end\": ' + 'context must be a Matrix, Array, or string but is ' + typeOf(context));\n              }\n              var s = size(context).valueOf();\n              var childArgs = Object.create(args);\n              childArgs.end = s[i];\n              return _evalDimension(scope, childArgs, context);\n            };\n          } else {\n            // SymbolNode `end` not used\n            return dimension._compile(math, argNames);\n          }\n        });\n        var index = getSafeProperty(math, 'index');\n        return function evalIndexNode(scope, args, context) {\n          var dimensions = map(evalDimensions, function (evalDimension) {\n            return evalDimension(scope, args, context);\n          });\n          return index.apply(void 0, _toConsumableArray(dimensions));\n        };\n      }\n      /**\n       * Execute a callback for each of the child nodes of this node\n       * @param {function(child: Node, path: string, parent: Node)} callback\n       */\n    }, {\n      key: \"forEach\",\n      value: function forEach(callback) {\n        for (var i = 0; i < this.dimensions.length; i++) {\n          callback(this.dimensions[i], 'dimensions[' + i + ']', this);\n        }\n      }\n      /**\n       * Create a new IndexNode whose children are the results of calling\n       * the provided callback function for each child of the original node.\n       * @param {function(child: Node, path: string, parent: Node): Node} callback\n       * @returns {IndexNode} Returns a transformed copy of the node\n       */\n    }, {\n      key: \"map\",\n      value: function map(callback) {\n        var dimensions = [];\n        for (var i = 0; i < this.dimensions.length; i++) {\n          dimensions[i] = this._ifNode(callback(this.dimensions[i], 'dimensions[' + i + ']', this));\n        }\n        return new IndexNode(dimensions, this.dotNotation);\n      }\n      /**\n       * Create a clone of this node, a shallow copy\n       * @return {IndexNode}\n       */\n    }, {\n      key: \"clone\",\n      value: function clone() {\n        return new IndexNode(this.dimensions.slice(0), this.dotNotation);\n      }\n      /**\n       * Test whether this IndexNode contains a single property name\n       * @return {boolean}\n       */\n    }, {\n      key: \"isObjectProperty\",\n      value: function isObjectProperty() {\n        return this.dimensions.length === 1 && isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === 'string';\n      }\n      /**\n       * Returns the property name if IndexNode contains a property.\n       * If not, returns null.\n       * @return {string | null}\n       */\n    }, {\n      key: \"getObjectProperty\",\n      value: function getObjectProperty() {\n        return this.isObjectProperty() ? this.dimensions[0].value : null;\n      }\n      /**\n       * Get string representation\n       * @param {Object} options\n       * @return {string} str\n       */\n    }, {\n      key: \"_toString\",\n      value: function _toString(options) {\n        // format the parameters like \"[1, 0:5]\"\n        return this.dotNotation ? '.' + this.getObjectProperty() : '[' + this.dimensions.join(', ') + ']';\n      }\n      /**\n       * Get a JSON representation of the node\n       * @returns {Object}\n       */\n    }, {\n      key: \"toJSON\",\n      value: function toJSON() {\n        return {\n          mathjs: name,\n          dimensions: this.dimensions,\n          dotNotation: this.dotNotation\n        };\n      }\n      /**\n       * Instantiate an IndexNode from its JSON representation\n       * @param {Object} json\n       *     An object structured like\n       *     `{\"mathjs\": \"IndexNode\", dimensions: [...], dotNotation: false}`,\n       *     where mathjs is optional\n       * @returns {IndexNode}\n       */\n    }, {\n      key: \"toHTML\",\n      /**\n       * Get HTML representation\n       * @param {Object} options\n       * @return {string} str\n       */\n      value: function toHTML(options) {\n        // format the parameters like \"[1, 0:5]\"\n        var dimensions = [];\n        for (var i = 0; i < this.dimensions.length; i++) {\n          dimensions[i] = this.dimensions[i].toHTML();\n        }\n        if (this.dotNotation) {\n          return '<span class=\"math-operator math-accessor-operator\">.</span>' + '<span class=\"math-symbol math-property\">' + escape(this.getObjectProperty()) + '</span>';\n        } else {\n          return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + dimensions.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n        }\n      }\n      /**\n       * Get LaTeX representation\n       * @param {Object} options\n       * @return {string} str\n       */\n    }, {\n      key: \"_toTex\",\n      value: function _toTex(options) {\n        var dimensions = this.dimensions.map(function (range) {\n          return range.toTex(options);\n        });\n        return this.dotNotation ? '.' + this.getObjectProperty() + '' : '_{' + dimensions.join(',') + '}';\n      }\n    }, {\n      key: \"type\",\n      get: function get() {\n        return name;\n      }\n    }, {\n      key: \"isIndexNode\",\n      get: function get() {\n        return true;\n      }\n    }], [{\n      key: \"fromJSON\",\n      value: function fromJSON(json) {\n        return new IndexNode(json.dimensions, json.dotNotation);\n      }\n    }]);\n    return IndexNode;\n  }(Node);\n  _defineProperty(IndexNode, \"name\", name);\n  return IndexNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":null,"metadata":{},"sourceType":"module"}