{"ast":null,"code":"var hasOwnProperty = Object.prototype.hasOwnProperty;\nvar matchGraph = require('./match-graph');\nvar MATCH = matchGraph.MATCH;\nvar MISMATCH = matchGraph.MISMATCH;\nvar DISALLOW_EMPTY = matchGraph.DISALLOW_EMPTY;\nvar TYPE = require('../tokenizer/const').TYPE;\nvar STUB = 0;\nvar TOKEN = 1;\nvar OPEN_SYNTAX = 2;\nvar CLOSE_SYNTAX = 3;\nvar EXIT_REASON_MATCH = 'Match';\nvar EXIT_REASON_MISMATCH = 'Mismatch';\nvar EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';\nvar ITERATION_LIMIT = 15000;\nvar totalIterationCount = 0;\nfunction reverseList(list) {\n  var prev = null;\n  var next = null;\n  var item = list;\n  while (item !== null) {\n    next = item.prev;\n    item.prev = prev;\n    prev = item;\n    item = next;\n  }\n  return prev;\n}\nfunction areStringsEqualCaseInsensitive(testStr, referenceStr) {\n  if (testStr.length !== referenceStr.length) {\n    return false;\n  }\n  for (var i = 0; i < testStr.length; i++) {\n    var testCode = testStr.charCodeAt(i);\n    var referenceCode = referenceStr.charCodeAt(i);\n\n    // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).\n    if (testCode >= 0x0041 && testCode <= 0x005A) {\n      testCode = testCode | 32;\n    }\n    if (testCode !== referenceCode) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isContextEdgeDelim(token) {\n  if (token.type !== TYPE.Delim) {\n    return false;\n  }\n\n  // Fix matching for unicode-range: U+30??, U+FF00-FF9F\n  // Probably we need to check out previous match instead\n  return token.value !== '?';\n}\nfunction isCommaContextStart(token) {\n  if (token === null) {\n    return true;\n  }\n  return token.type === TYPE.Comma || token.type === TYPE.Function || token.type === TYPE.LeftParenthesis || token.type === TYPE.LeftSquareBracket || token.type === TYPE.LeftCurlyBracket || isContextEdgeDelim(token);\n}\nfunction isCommaContextEnd(token) {\n  if (token === null) {\n    return true;\n  }\n  return token.type === TYPE.RightParenthesis || token.type === TYPE.RightSquareBracket || token.type === TYPE.RightCurlyBracket || token.type === TYPE.Delim;\n}\nfunction internalMatch(tokens, state, syntaxes) {\n  function moveToNextToken() {\n    do {\n      tokenIndex++;\n      token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;\n    } while (token !== null && (token.type === TYPE.WhiteSpace || token.type === TYPE.Comment));\n  }\n  function getNextToken(offset) {\n    var nextIndex = tokenIndex + offset;\n    return nextIndex < tokens.length ? tokens[nextIndex] : null;\n  }\n  function stateSnapshotFromSyntax(nextState, prev) {\n    return {\n      nextState: nextState,\n      matchStack: matchStack,\n      syntaxStack: syntaxStack,\n      thenStack: thenStack,\n      tokenIndex: tokenIndex,\n      prev: prev\n    };\n  }\n  function pushThenStack(nextState) {\n    thenStack = {\n      nextState: nextState,\n      matchStack: matchStack,\n      syntaxStack: syntaxStack,\n      prev: thenStack\n    };\n  }\n  function pushElseStack(nextState) {\n    elseStack = stateSnapshotFromSyntax(nextState, elseStack);\n  }\n  function addTokenToMatch() {\n    matchStack = {\n      type: TOKEN,\n      syntax: state.syntax,\n      token: token,\n      prev: matchStack\n    };\n    moveToNextToken();\n    syntaxStash = null;\n    if (tokenIndex > longestMatch) {\n      longestMatch = tokenIndex;\n    }\n  }\n  function openSyntax() {\n    syntaxStack = {\n      syntax: state.syntax,\n      opts: state.syntax.opts || syntaxStack !== null && syntaxStack.opts || null,\n      prev: syntaxStack\n    };\n    matchStack = {\n      type: OPEN_SYNTAX,\n      syntax: state.syntax,\n      token: matchStack.token,\n      prev: matchStack\n    };\n  }\n  function closeSyntax() {\n    if (matchStack.type === OPEN_SYNTAX) {\n      matchStack = matchStack.prev;\n    } else {\n      matchStack = {\n        type: CLOSE_SYNTAX,\n        syntax: syntaxStack.syntax,\n        token: matchStack.token,\n        prev: matchStack\n      };\n    }\n    syntaxStack = syntaxStack.prev;\n  }\n  var syntaxStack = null;\n  var thenStack = null;\n  var elseStack = null;\n\n  // null – stashing allowed, nothing stashed\n  // false – stashing disabled, nothing stashed\n  // anithing else – fail stashable syntaxes, some syntax stashed\n  var syntaxStash = null;\n  var iterationCount = 0; // count iterations and prevent infinite loop\n  var exitReason = null;\n  var token = null;\n  var tokenIndex = -1;\n  var longestMatch = 0;\n  var matchStack = {\n    type: STUB,\n    syntax: null,\n    token: null,\n    prev: null\n  };\n  moveToNextToken();\n  while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {\n    // function mapList(list, fn) {\n    //     var result = [];\n    //     while (list) {\n    //         result.unshift(fn(list));\n    //         list = list.prev;\n    //     }\n    //     return result;\n    // }\n    // console.log('--\\n',\n    //     '#' + iterationCount,\n    //     require('util').inspect({\n    //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),\n    //         token: token && token.value,\n    //         tokenIndex,\n    //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')\n    //     }, { depth: null })\n    // );\n    switch (state.type) {\n      case 'Match':\n        if (thenStack === null) {\n          // turn to MISMATCH when some tokens left unmatched\n          if (token !== null) {\n            // doesn't mismatch if just one token left and it's an IE hack\n            if (tokenIndex !== tokens.length - 1 || token.value !== '\\\\0' && token.value !== '\\\\9') {\n              state = MISMATCH;\n              break;\n            }\n          }\n\n          // break the main loop, return a result - MATCH\n          exitReason = EXIT_REASON_MATCH;\n          break;\n        }\n\n        // go to next syntax (`then` branch)\n        state = thenStack.nextState;\n\n        // check match is not empty\n        if (state === DISALLOW_EMPTY) {\n          if (thenStack.matchStack === matchStack) {\n            state = MISMATCH;\n            break;\n          } else {\n            state = MATCH;\n          }\n        }\n\n        // close syntax if needed\n        while (thenStack.syntaxStack !== syntaxStack) {\n          closeSyntax();\n        }\n\n        // pop stack\n        thenStack = thenStack.prev;\n        break;\n      case 'Mismatch':\n        // when some syntax is stashed\n        if (syntaxStash !== null && syntaxStash !== false) {\n          // there is no else branches or a branch reduce match stack\n          if (elseStack === null || tokenIndex > elseStack.tokenIndex) {\n            // restore state from the stash\n            elseStack = syntaxStash;\n            syntaxStash = false; // disable stashing\n          }\n        } else if (elseStack === null) {\n          // no else branches -> break the main loop\n          // return a result - MISMATCH\n          exitReason = EXIT_REASON_MISMATCH;\n          break;\n        }\n\n        // go to next syntax (`else` branch)\n        state = elseStack.nextState;\n\n        // restore all the rest stack states\n        thenStack = elseStack.thenStack;\n        syntaxStack = elseStack.syntaxStack;\n        matchStack = elseStack.matchStack;\n        tokenIndex = elseStack.tokenIndex;\n        token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;\n\n        // pop stack\n        elseStack = elseStack.prev;\n        break;\n      case 'MatchGraph':\n        state = state.match;\n        break;\n      case 'If':\n        // IMPORTANT: else stack push must go first,\n        // since it stores the state of thenStack before changes\n        if (state.else !== MISMATCH) {\n          pushElseStack(state.else);\n        }\n        if (state.then !== MATCH) {\n          pushThenStack(state.then);\n        }\n        state = state.match;\n        break;\n      case 'MatchOnce':\n        state = {\n          type: 'MatchOnceBuffer',\n          syntax: state,\n          index: 0,\n          mask: 0\n        };\n        break;\n      case 'MatchOnceBuffer':\n        var terms = state.syntax.terms;\n        if (state.index === terms.length) {\n          // no matches at all or it's required all terms to be matched\n          if (state.mask === 0 || state.syntax.all) {\n            state = MISMATCH;\n            break;\n          }\n\n          // a partial match is ok\n          state = MATCH;\n          break;\n        }\n\n        // all terms are matched\n        if (state.mask === (1 << terms.length) - 1) {\n          state = MATCH;\n          break;\n        }\n        for (; state.index < terms.length; state.index++) {\n          var matchFlag = 1 << state.index;\n          if ((state.mask & matchFlag) === 0) {\n            // IMPORTANT: else stack push must go first,\n            // since it stores the state of thenStack before changes\n            pushElseStack(state);\n            pushThenStack({\n              type: 'AddMatchOnce',\n              syntax: state.syntax,\n              mask: state.mask | matchFlag\n            });\n\n            // match\n            state = terms[state.index++];\n            break;\n          }\n        }\n        break;\n      case 'AddMatchOnce':\n        state = {\n          type: 'MatchOnceBuffer',\n          syntax: state.syntax,\n          index: 0,\n          mask: state.mask\n        };\n        break;\n      case 'Enum':\n        if (token !== null) {\n          var name = token.value.toLowerCase();\n\n          // drop \\0 and \\9 hack from keyword name\n          if (name.indexOf('\\\\') !== -1) {\n            name = name.replace(/\\\\[09].*$/, '');\n          }\n          if (hasOwnProperty.call(state.map, name)) {\n            state = state.map[name];\n            break;\n          }\n        }\n        state = MISMATCH;\n        break;\n      case 'Generic':\n        var opts = syntaxStack !== null ? syntaxStack.opts : null;\n        var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));\n        if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {\n          while (tokenIndex < lastTokenIndex) {\n            addTokenToMatch();\n          }\n          state = MATCH;\n        } else {\n          state = MISMATCH;\n        }\n        break;\n      case 'Type':\n      case 'Property':\n        var syntaxDict = state.type === 'Type' ? 'types' : 'properties';\n        var dictSyntax = hasOwnProperty.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;\n        if (!dictSyntax || !dictSyntax.match) {\n          throw new Error('Bad syntax reference: ' + (state.type === 'Type' ? '<' + state.name + '>' : '<\\'' + state.name + '\\'>'));\n        }\n\n        // stash a syntax for types with low priority\n        if (syntaxStash !== false && token !== null && state.type === 'Type') {\n          var lowPriorityMatching =\n          // https://drafts.csswg.org/css-values-4/#custom-idents\n          // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production\n          // can only claim the keyword if no other unfulfilled production can claim it.\n          state.name === 'custom-ident' && token.type === TYPE.Ident ||\n          // https://drafts.csswg.org/css-values-4/#lengths\n          // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),\n          // it must parse as a <number>\n          state.name === 'length' && token.value === '0';\n          if (lowPriorityMatching) {\n            if (syntaxStash === null) {\n              syntaxStash = stateSnapshotFromSyntax(state, elseStack);\n            }\n            state = MISMATCH;\n            break;\n          }\n        }\n        openSyntax();\n        state = dictSyntax.match;\n        break;\n      case 'Keyword':\n        var name = state.name;\n        if (token !== null) {\n          var keywordName = token.value;\n\n          // drop \\0 and \\9 hack from keyword name\n          if (keywordName.indexOf('\\\\') !== -1) {\n            keywordName = keywordName.replace(/\\\\[09].*$/, '');\n          }\n          if (areStringsEqualCaseInsensitive(keywordName, name)) {\n            addTokenToMatch();\n            state = MATCH;\n            break;\n          }\n        }\n        state = MISMATCH;\n        break;\n      case 'AtKeyword':\n      case 'Function':\n        if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {\n          addTokenToMatch();\n          state = MATCH;\n          break;\n        }\n        state = MISMATCH;\n        break;\n      case 'Token':\n        if (token !== null && token.value === state.value) {\n          addTokenToMatch();\n          state = MATCH;\n          break;\n        }\n        state = MISMATCH;\n        break;\n      case 'Comma':\n        if (token !== null && token.type === TYPE.Comma) {\n          if (isCommaContextStart(matchStack.token)) {\n            state = MISMATCH;\n          } else {\n            addTokenToMatch();\n            state = isCommaContextEnd(token) ? MISMATCH : MATCH;\n          }\n        } else {\n          state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH : MISMATCH;\n        }\n        break;\n      case 'String':\n        var string = '';\n        for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {\n          string += tokens[lastTokenIndex].value;\n        }\n        if (areStringsEqualCaseInsensitive(string, state.value)) {\n          while (tokenIndex < lastTokenIndex) {\n            addTokenToMatch();\n          }\n          state = MATCH;\n        } else {\n          state = MISMATCH;\n        }\n        break;\n      default:\n        throw new Error('Unknown node type: ' + state.type);\n    }\n  }\n  totalIterationCount += iterationCount;\n  switch (exitReason) {\n    case null:\n      console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');\n      exitReason = EXIT_REASON_ITERATION_LIMIT;\n      matchStack = null;\n      break;\n    case EXIT_REASON_MATCH:\n      while (syntaxStack !== null) {\n        closeSyntax();\n      }\n      break;\n    default:\n      matchStack = null;\n  }\n  return {\n    tokens: tokens,\n    reason: exitReason,\n    iterations: iterationCount,\n    match: matchStack,\n    longestMatch: longestMatch\n  };\n}\nfunction matchAsList(tokens, matchGraph, syntaxes) {\n  var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});\n  if (matchResult.match !== null) {\n    var item = reverseList(matchResult.match).prev;\n    matchResult.match = [];\n    while (item !== null) {\n      switch (item.type) {\n        case STUB:\n          break;\n        case OPEN_SYNTAX:\n        case CLOSE_SYNTAX:\n          matchResult.match.push({\n            type: item.type,\n            syntax: item.syntax\n          });\n          break;\n        default:\n          matchResult.match.push({\n            token: item.token.value,\n            node: item.token.node\n          });\n          break;\n      }\n      item = item.prev;\n    }\n  }\n  return matchResult;\n}\nfunction matchAsTree(tokens, matchGraph, syntaxes) {\n  var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});\n  if (matchResult.match === null) {\n    return matchResult;\n  }\n  var item = matchResult.match;\n  var host = matchResult.match = {\n    syntax: matchGraph.syntax || null,\n    match: []\n  };\n  var hostStack = [host];\n\n  // revert a list and start with 2nd item since 1st is a stub item\n  item = reverseList(item).prev;\n\n  // build a tree\n  while (item !== null) {\n    switch (item.type) {\n      case OPEN_SYNTAX:\n        host.match.push(host = {\n          syntax: item.syntax,\n          match: []\n        });\n        hostStack.push(host);\n        break;\n      case CLOSE_SYNTAX:\n        hostStack.pop();\n        host = hostStack[hostStack.length - 1];\n        break;\n      default:\n        host.match.push({\n          syntax: item.syntax || null,\n          token: item.token.value,\n          node: item.token.node\n        });\n    }\n    item = item.prev;\n  }\n  return matchResult;\n}\nmodule.exports = {\n  matchAsList: matchAsList,\n  matchAsTree: matchAsTree,\n  getTotalIterationCount: function getTotalIterationCount() {\n    return totalIterationCount;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}