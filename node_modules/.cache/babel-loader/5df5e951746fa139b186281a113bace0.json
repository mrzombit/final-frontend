{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Base, Event, getUniqueID, NotifyPropertyChanges, Property } from '@syncfusion/ej2-base';\nimport { closest, Draggable, remove, compareElementParent } from '@syncfusion/ej2-base';\nimport { addClass, isNullOrUndefined, getComponent, isBlazor } from '@syncfusion/ej2-base';\n/**\n * Sortable Module provides support to enable sortable functionality in Dom Elements.\n * ```html\n * <div id=\"sortable\">\n *   <div>Item 1</div>\n *   <div>Item 2</div>\n *   <div>Item 3</div>\n *   <div>Item 4</div>\n *   <div>Item 5</div>\n * </div>\n * ```\n * ```typescript\n *   let ele: HTMLElement = document.getElementById('sortable');\n *   let sortObj: Sortable = new Sortable(ele, {});\n * ```\n */\nvar Sortable = /** @class */function (_super) {\n  __extends(Sortable, _super);\n  /* es-lint enable  */\n  function Sortable(element, options) {\n    var _this = _super.call(this, options, element) || this;\n    // eslint-disable-next-line\n    _this.getHelper = function (e) {\n      // eslint-disable-next-line prefer-const\n      var target = _this.getSortableElement(e.sender.target);\n      if (!_this.isValidTarget(target, _this)) {\n        return false;\n      }\n      var element;\n      if (_this.helper) {\n        element = _this.helper({\n          sender: target,\n          element: e.element\n        });\n      } else {\n        element = target.cloneNode(true);\n        element.style.width = target.offsetWidth + \"px\";\n        element.style.height = target.offsetHeight + \"px\";\n      }\n      addClass([element], ['e-sortableclone']);\n      document.body.appendChild(element);\n      return element;\n    };\n    // eslint-disable-next-line\n    _this.onDrag = function (e) {\n      if (!e.target) return;\n      _this.trigger('drag', {\n        event: e.event,\n        element: _this.element,\n        target: e.target\n      });\n      var newInst = _this.getSortableInstance(e.target);\n      var target = _this.getSortableElement(e.target, newInst);\n      if ((_this.isValidTarget(target, newInst) || e.target.className.indexOf('e-list-group-item') > -1) && (_this.curTarget !== target || !isNullOrUndefined(newInst.placeHolder)) && (newInst.placeHolderElement ? newInst.placeHolderElement !== e.target : true)) {\n        if (e.target.className.indexOf('e-list-group-item') > -1) {\n          target = e.target;\n        }\n        _this.curTarget = target;\n        if (_this.target === target) {\n          return;\n        }\n        var oldIdx = _this.getIndex(newInst.placeHolderElement, newInst);\n        var placeHolder = _this.getPlaceHolder(target, newInst);\n        var newIdx = void 0;\n        if (placeHolder) {\n          oldIdx = isNullOrUndefined(oldIdx) ? _this.getIndex(_this.target) : oldIdx;\n          newIdx = _this.getIndex(target, newInst, e.event);\n          var isPlaceHolderPresent = _this.isPlaceHolderPresent(newInst);\n          if (isPlaceHolderPresent && oldIdx === newIdx) {\n            return;\n          }\n          if (isPlaceHolderPresent) {\n            remove(newInst.placeHolderElement);\n          }\n          newInst.placeHolderElement = placeHolder;\n          if (e.target.className.indexOf('e-list-group-item') > -1) {\n            newInst.element.insertBefore(newInst.placeHolderElement, newInst.element.children[newIdx]);\n          } else if (newInst.element !== _this.element && newIdx === newInst.element.childElementCount) {\n            newInst.element.appendChild(newInst.placeHolderElement);\n          } else {\n            newInst.element.insertBefore(newInst.placeHolderElement, newInst.element.children[newIdx]);\n          }\n          _this.refreshDisabled(oldIdx, newIdx, newInst);\n        } else {\n          oldIdx = isNullOrUndefined(oldIdx) ? _this.getIndex(_this.target) : _this.getIndex(target, newInst) < oldIdx || !oldIdx ? oldIdx : oldIdx - 1;\n          newIdx = _this.getIndex(target, newInst);\n          var idx = newInst.element !== _this.element ? newIdx : oldIdx < newIdx ? newIdx + 1 : newIdx;\n          _this.updateItemClass(newInst);\n          newInst.element.insertBefore(_this.target, newInst.element.children[idx]);\n          _this.refreshDisabled(oldIdx, newIdx, newInst);\n          _this.curTarget = _this.target;\n          _this.trigger('drop', {\n            droppedElement: _this.target,\n            element: newInst.element,\n            previousIndex: oldIdx,\n            currentIndex: newIdx,\n            target: e.target,\n            helper: document.getElementsByClassName('e-sortableclone')[0],\n            event: e.event,\n            scope: _this.scope\n          });\n        }\n      } else if (_this.curTarget !== _this.target && _this.scope && _this.curTarget !== target && !isNullOrUndefined(newInst.placeHolder)) {\n        remove(_this.getSortableInstance(_this.curTarget).placeHolderElement);\n        _this.curTarget = _this.target;\n      }\n      newInst = _this.getSortableInstance(_this.curTarget);\n      if (isNullOrUndefined(target) && e.target !== newInst.placeHolderElement) {\n        if (_this.isPlaceHolderPresent(newInst)) {\n          _this.removePlaceHolder(newInst);\n        }\n      } else {\n        var placeHolders = [].slice.call(document.getElementsByClassName('e-sortable-placeholder'));\n        var inst_1;\n        placeHolders.forEach(function (placeHolder) {\n          inst_1 = _this.getSortableInstance(placeHolder);\n          if (inst_1.element && inst_1 !== newInst) {\n            _this.removePlaceHolder(inst_1);\n          }\n        });\n      }\n    };\n    // eslint-disable-next-line\n    _this.onDragStart = function (e) {\n      _this.target = _this.getSortableElement(e.target);\n      var cancelDrag = false;\n      _this.target.classList.add('e-grabbed');\n      _this.curTarget = _this.target;\n      e.helper = document.getElementsByClassName('e-sortableclone')[0];\n      var args = {\n        cancel: false,\n        element: _this.element,\n        target: _this.target\n      };\n      _this.trigger('beforeDragStart', args, function (observedArgs) {\n        if (observedArgs.cancel) {\n          cancelDrag = observedArgs.cancel;\n          _this.onDragStop(e);\n        }\n      });\n      if (cancelDrag) {\n        return;\n      }\n      if (isBlazor) {\n        _this.trigger('dragStart', {\n          event: e.event,\n          element: _this.element,\n          target: _this.target,\n          bindEvents: e.bindEvents,\n          dragElement: e.dragElement\n        });\n      } else {\n        _this.trigger('dragStart', {\n          event: e.event,\n          element: _this.element,\n          target: _this.target\n        });\n      }\n    };\n    // eslint-disable-next-line\n    _this.onDragStop = function (e) {\n      var dropInst = _this.getSortableInstance(_this.curTarget);\n      var prevIdx;\n      var curIdx;\n      var handled;\n      prevIdx = _this.getIndex(_this.target);\n      var isPlaceHolderPresent = _this.isPlaceHolderPresent(dropInst);\n      if (isPlaceHolderPresent) {\n        var curIdx_1 = _this.getIndex(dropInst.placeHolderElement, dropInst);\n        var args = {\n          previousIndex: prevIdx,\n          currentIndex: curIdx_1,\n          target: e.target,\n          droppedElement: _this.target,\n          helper: e.helper,\n          cancel: false,\n          handled: false\n        };\n        _this.trigger('beforeDrop', args, function (observedArgs) {\n          if (!observedArgs.cancel) {\n            handled = observedArgs.handled;\n            _this.updateItemClass(dropInst);\n            if (observedArgs.handled) {\n              var ele = _this.target.cloneNode(true);\n              _this.target.classList.remove('e-grabbed');\n              _this.target = ele;\n            }\n            dropInst.element.insertBefore(_this.target, dropInst.placeHolderElement);\n            var curIdx_2 = _this.getIndex(_this.target, dropInst);\n            prevIdx = _this === dropInst && prevIdx - curIdx_2 > 1 ? prevIdx - 1 : prevIdx;\n            _this.trigger('drop', {\n              event: e.event,\n              element: dropInst.element,\n              previousIndex: prevIdx,\n              currentIndex: curIdx_2,\n              target: e.target,\n              helper: e.helper,\n              droppedElement: _this.target,\n              scopeName: _this.scope,\n              handled: handled\n            });\n          }\n          remove(dropInst.placeHolderElement);\n        });\n      }\n      dropInst = _this.getSortableInstance(e.target);\n      // eslint-disable-next-line prefer-const\n      curIdx = dropInst.element.childElementCount;\n      prevIdx = _this.getIndex(_this.target);\n      if (dropInst.element === e.target || !isPlaceHolderPresent && _this.curTarget === _this.target) {\n        var beforeDropArgs = {\n          previousIndex: prevIdx,\n          currentIndex: _this.curTarget === _this.target ? prevIdx : curIdx,\n          target: e.target,\n          droppedElement: _this.target,\n          helper: e.helper,\n          cancel: false\n        };\n        _this.trigger('beforeDrop', beforeDropArgs, function (observedArgs) {\n          if (dropInst.element === e.target && !observedArgs.cancel) {\n            _this.updateItemClass(dropInst);\n            dropInst.element.appendChild(_this.target);\n            _this.trigger('drop', {\n              event: e.event,\n              element: dropInst.element,\n              previousIndex: prevIdx,\n              currentIndex: curIdx,\n              target: e.target,\n              helper: e.helper,\n              droppedElement: _this.target,\n              scopeName: _this.scope\n            });\n          }\n        });\n      }\n      _this.target.classList.remove('e-grabbed');\n      _this.target = null;\n      _this.curTarget = null;\n      remove(e.helper);\n      getComponent(_this.element, 'draggable').intDestroy(e.event);\n    };\n    _this.bind();\n    return _this;\n  }\n  Sortable_1 = Sortable;\n  Sortable.prototype.bind = function () {\n    if (!this.element.id) {\n      this.element.id = getUniqueID('sortable');\n    }\n    if (!this.itemClass) {\n      this.itemClass = 'e-sort-item';\n      this.dataBind();\n    }\n    this.initializeDraggable();\n  };\n  Sortable.prototype.initializeDraggable = function () {\n    new Draggable(this.element, {\n      helper: this.getHelper,\n      dragStart: this.onDragStart,\n      drag: this.onDrag,\n      dragStop: this.onDragStop,\n      dragTarget: \".\" + this.itemClass,\n      enableTapHold: true,\n      tapHoldThreshold: 200,\n      queryPositionInfo: this.queryPositionInfo,\n      distance: 5\n    });\n  };\n  Sortable.prototype.getPlaceHolder = function (target, instance) {\n    if (instance.placeHolder) {\n      var placeHolderElement = instance.placeHolder({\n        element: instance.element,\n        grabbedElement: this.target,\n        target: target\n      });\n      placeHolderElement.classList.add('e-sortable-placeholder');\n      return placeHolderElement;\n    }\n    return null;\n  };\n  Sortable.prototype.isValidTarget = function (target, instance) {\n    return target && compareElementParent(target, instance.element) && target.classList.contains(instance.itemClass) && !target.classList.contains('e-disabled');\n  };\n  Sortable.prototype.removePlaceHolder = function (instance) {\n    remove(instance.placeHolderElement);\n    instance.placeHolderElement = null;\n  };\n  Sortable.prototype.updateItemClass = function (instance) {\n    if (this !== instance) {\n      this.target.classList.remove(this.itemClass);\n      this.target.classList.add(instance.itemClass);\n    }\n  };\n  Sortable.prototype.getSortableInstance = function (element) {\n    element = closest(element, \".e-\" + this.getModuleName());\n    if (element) {\n      var inst = getComponent(element, Sortable_1);\n      return inst.scope && this.scope && inst.scope === this.scope ? inst : this;\n    } else {\n      return this;\n    }\n  };\n  Sortable.prototype.refreshDisabled = function (oldIdx, newIdx, instance) {\n    if (instance === this) {\n      var element = void 0;\n      var increased = oldIdx < newIdx;\n      var disabledIdx = void 0;\n      var start = increased ? oldIdx : newIdx;\n      var end = increased ? newIdx : oldIdx;\n      while (start <= end) {\n        element = this.element.children[start];\n        if (element.classList.contains('e-disabled')) {\n          disabledIdx = this.getIndex(element);\n          this.element.insertBefore(element, this.element.children[increased ? disabledIdx + 2 : disabledIdx - 1]);\n          start = increased ? disabledIdx + 2 : disabledIdx + 1;\n        } else {\n          start++;\n        }\n      }\n    }\n  };\n  Sortable.prototype.getIndex = function (target, instance, e) {\n    if (instance === void 0) {\n      instance = this;\n    }\n    var idx;\n    var placeHolderPresent;\n    [].slice.call(instance.element.children).forEach(function (element, index) {\n      if (element.classList.contains('e-sortable-placeholder')) {\n        placeHolderPresent = true;\n      }\n      if (element === target) {\n        idx = index;\n        if (!isNullOrUndefined(e)) {\n          if (placeHolderPresent) {\n            idx -= 1;\n          }\n          var offset = target.getBoundingClientRect();\n          var clientY = offset.bottom - (offset.bottom - offset.top) / 2;\n          idx = e.clientY <= clientY ? idx : idx + 1;\n        }\n        return;\n      }\n    });\n    return idx;\n  };\n  Sortable.prototype.getSortableElement = function (element, instance) {\n    if (instance === void 0) {\n      instance = this;\n    }\n    return closest(element, \".\" + instance.itemClass);\n  };\n  Sortable.prototype.queryPositionInfo = function (value) {\n    value.left = pageXOffset ? parseFloat(value.left) - pageXOffset + \"px\" : value.left;\n    value.top = pageYOffset ? parseFloat(value.top) - pageYOffset + \"px\" : value.top;\n    return value;\n  };\n  Sortable.prototype.isPlaceHolderPresent = function (instance) {\n    return instance.placeHolderElement && !!closest(instance.placeHolderElement, \"#\" + instance.element.id);\n  };\n  /**\n   * It is used to sort array of elements from source element to destination element.\n   *\n   * @param destination - Defines the destination element to which the sortable elements needs to be appended.\n   *\n   * If it is null, then the Sortable library element will be considered as destination.\n   * @param targetIndexes - Specifies the sortable elements indexes which needs to be sorted.\n   * @param insertBefore - Specifies the index before which the sortable elements needs to be appended.\n   * If it is null, elements will be appended as last child.\n   * @function moveTo\n   * @returns {void}\n   */\n  Sortable.prototype.moveTo = function (destination, targetIndexes, insertBefore) {\n    moveTo(this.element, destination, targetIndexes, insertBefore);\n  };\n  /**\n   * It is used to destroy the Sortable library.\n   */\n  Sortable.prototype.destroy = function () {\n    if (this.itemClass === 'e-sort-item') {\n      this.itemClass = null;\n      this.dataBind();\n    }\n    getComponent(this.element, Draggable).destroy();\n    _super.prototype.destroy.call(this);\n  };\n  Sortable.prototype.getModuleName = function () {\n    return 'sortable';\n  };\n  Sortable.prototype.onPropertyChanged = function (newProp, oldProp) {\n    for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {\n      var prop = _a[_i];\n      switch (prop) {\n        case 'itemClass':\n          [].slice.call(this.element.children).forEach(function (element) {\n            if (element.classList.contains(oldProp.itemClass)) {\n              element.classList.remove(oldProp.itemClass);\n            }\n            if (newProp.itemClass) {\n              element.classList.add(newProp.itemClass);\n            }\n          });\n          break;\n      }\n    }\n  };\n  var Sortable_1;\n  __decorate([Property(false)], Sortable.prototype, \"enableAnimation\", void 0);\n  __decorate([Property(null)], Sortable.prototype, \"itemClass\", void 0);\n  __decorate([Property(null)], Sortable.prototype, \"scope\", void 0);\n  __decorate([Property()], Sortable.prototype, \"helper\", void 0);\n  __decorate([Property()], Sortable.prototype, \"placeHolder\", void 0);\n  __decorate([Event()], Sortable.prototype, \"drag\", void 0);\n  __decorate([Event()], Sortable.prototype, \"beforeDragStart\", void 0);\n  __decorate([Event()], Sortable.prototype, \"dragStart\", void 0);\n  __decorate([Event()], Sortable.prototype, \"beforeDrop\", void 0);\n  __decorate([Event()], Sortable.prototype, \"drop\", void 0);\n  Sortable = Sortable_1 = __decorate([NotifyPropertyChanges], Sortable);\n  return Sortable;\n}(Base);\nexport { Sortable };\n/**\n * It is used to sort array of elements from source element to destination element.\n *\n * @private\n */\nexport function moveTo(from, to, targetIndexes, insertBefore) {\n  var targetElements = [];\n  if (!to) {\n    to = from;\n  }\n  if (targetIndexes && targetIndexes.length) {\n    targetIndexes.forEach(function (index) {\n      targetElements.push(from.children[index]);\n    });\n  } else {\n    targetElements = [].slice.call(from.children);\n  }\n  if (isNullOrUndefined(insertBefore)) {\n    targetElements.forEach(function (target) {\n      to.appendChild(target);\n    });\n  } else {\n    var insertElement_1 = to.children[insertBefore];\n    targetElements.forEach(function (target) {\n      to.insertBefore(target, insertElement_1);\n    });\n  }\n}","map":null,"metadata":{},"sourceType":"module"}