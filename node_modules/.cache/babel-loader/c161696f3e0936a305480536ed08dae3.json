{"ast":null,"code":"import { upperFirst, capitalize, last, pick, compose, mapValues, matchPercent, evolve, isNil, get, castArray, omit, asyncCompose } from '@react-pdf/fns';\nimport * as P from '@react-pdf/primitives';\nimport { TextInstance } from '@react-pdf/primitives';\nimport stylesheet, { transformColor, processTransform, flatten } from '@react-pdf/stylesheet';\nimport layoutEngine, { linebreaker, justification, textDecoration, scriptItemizer, wordHyphenation } from '@react-pdf/textkit';\nimport _createClass from '@babel/runtime/helpers/createClass';\nimport { PDFFont } from '@react-pdf/pdfkit';\nimport _regeneratorRuntime from '@babel/runtime/helpers/regeneratorRuntime';\nimport _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';\nimport _extends from '@babel/runtime/helpers/extends';\nimport emojiRegex from 'emoji-regex';\nimport resolveImage from '@react-pdf/image';\nimport Yoga from '@react-pdf/yoga';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/objectWithoutPropertiesLoose';\n\n/**\n * Create attributed string from text fragments\n *\n * @param  {Array}  fragments\n * @return {Object} attributed string\n */\nvar fromFragments = function fromFragments(fragments) {\n  var offset = 0;\n  var string = '';\n  var runs = [];\n  fragments.forEach(function (fragment) {\n    string += fragment.string;\n    runs.push({\n      start: offset,\n      end: offset + fragment.string.length,\n      attributes: fragment.attributes || {}\n    });\n    offset += fragment.string.length;\n  });\n  return {\n    string: string,\n    runs: runs\n  };\n};\n\n/**\n * Apply transformation to text string\n *\n * @param {String} text\n * @param {String} transformation type\n * @returns {String} transformed text\n */\nvar transformText = function transformText(text, transformation) {\n  switch (transformation) {\n    case 'uppercase':\n      return text.toUpperCase();\n    case 'lowercase':\n      return text.toLowerCase();\n    case 'capitalize':\n      return capitalize(text);\n    case 'upperfirst':\n      return upperFirst(text);\n    default:\n      return text;\n  }\n};\nvar StandardFont = /*#__PURE__*/function () {\n  function StandardFont(src) {\n    this.name = src;\n    this.src = PDFFont.open(null, src);\n  }\n  var _proto = StandardFont.prototype;\n  _proto.encode = function encode(str) {\n    return this.src.encode(str);\n  };\n  _proto.layout = function layout(str) {\n    var _this = this;\n    var _this$encode = this.encode(str),\n      encoded = _this$encode[0],\n      positions = _this$encode[1];\n    return {\n      positions: positions,\n      stringIndices: positions.map(function (_, i) {\n        return i;\n      }),\n      glyphs: encoded.map(function (g, i) {\n        var glyph = _this.getGlyph(parseInt(g, 16));\n        glyph.advanceWidth = positions[i].advanceWidth;\n        return glyph;\n      })\n    };\n  };\n  _proto.glyphForCodePoint = function glyphForCodePoint(codePoint) {\n    var glyph = this.getGlyph(codePoint);\n    glyph.advanceWidth = 400;\n    return glyph;\n  };\n  _proto.getGlyph = function getGlyph(id) {\n    return {\n      id: id,\n      _font: this.src,\n      codePoints: [id],\n      isLigature: false,\n      name: this.src.font.characterToGlyph(id)\n    };\n  };\n  _proto.hasGlyphForCodePoint = function hasGlyphForCodePoint(codePoint) {\n    return this.src.font.characterToGlyph(codePoint) !== '.notdef';\n  }\n\n  // Based on empirical observation\n  ;\n\n  _createClass(StandardFont, [{\n    key: \"ascent\",\n    get: function get() {\n      return 900;\n    }\n\n    // Based on empirical observation\n  }, {\n    key: \"capHeight\",\n    get: function get() {\n      switch (this.name) {\n        case 'Times-Roman':\n        case 'Times-Bold':\n        case 'Times-Italic':\n        case 'Times-BoldItalic':\n          return 650;\n        case 'Courier':\n        case 'Courier-Bold':\n        case 'Courier-Oblique':\n        case 'Courier-BoldOblique':\n          return 550;\n        default:\n          return 690;\n      }\n    }\n\n    // Based on empirical observation\n  }, {\n    key: \"xHeight\",\n    get: function get() {\n      switch (this.name) {\n        case 'Times-Roman':\n        case 'Times-Bold':\n        case 'Times-Italic':\n        case 'Times-BoldItalic':\n          return 440;\n        case 'Courier':\n        case 'Courier-Bold':\n        case 'Courier-Oblique':\n        case 'Courier-BoldOblique':\n          return 390;\n        default:\n          return 490;\n      }\n    }\n\n    // Based on empirical observation\n  }, {\n    key: \"descent\",\n    get: function get() {\n      switch (this.name) {\n        case 'Times-Roman':\n        case 'Times-Bold':\n        case 'Times-Italic':\n        case 'Times-BoldItalic':\n          return -220;\n        case 'Courier':\n        case 'Courier-Bold':\n        case 'Courier-Oblique':\n        case 'Courier-BoldOblique':\n          return -230;\n        default:\n          return -200;\n      }\n    }\n  }, {\n    key: \"lineGap\",\n    get: function get() {\n      return 0;\n    }\n  }, {\n    key: \"unitsPerEm\",\n    get: function get() {\n      return 1000;\n    }\n  }]);\n  return StandardFont;\n}();\nvar fontCache = {};\nvar IGNORED_CODE_POINTS = [173];\nvar getFontSize = function getFontSize(node) {\n  return node.attributes.fontSize || 12;\n};\nvar getOrCreateFont = function getOrCreateFont(name) {\n  if (fontCache[name]) return fontCache[name];\n  var font = new StandardFont(name);\n  fontCache[name] = font;\n  return font;\n};\nvar getFallbackFont = function getFallbackFont() {\n  return getOrCreateFont('Helvetica');\n};\nvar shouldFallbackToFont = function shouldFallbackToFont(codePoint, font) {\n  return !font || !IGNORED_CODE_POINTS.includes(codePoint) && !font.hasGlyphForCodePoint(codePoint) && getFallbackFont().hasGlyphForCodePoint(codePoint);\n};\nvar fontSubstitution = function fontSubstitution() {\n  return function (_ref) {\n    var string = _ref.string,\n      runs = _ref.runs;\n    var lastFont = null;\n    var lastFontSize = null;\n    var lastIndex = 0;\n    var index = 0;\n    var res = [];\n    for (var i = 0; i < runs.length; i += 1) {\n      var run = runs[i];\n      var defaultFont = typeof run.attributes.font === 'string' ? getOrCreateFont(run.attributes.font) : run.attributes.font;\n      if (string.length === 0) {\n        res.push({\n          start: 0,\n          end: 0,\n          attributes: {\n            font: defaultFont\n          }\n        });\n        break;\n      }\n      var chars = string.slice(run.start, run.end);\n      for (var j = 0; j < chars.length; j += 1) {\n        var char = chars[j];\n        var codePoint = char.codePointAt();\n        var shouldFallback = shouldFallbackToFont(codePoint, defaultFont);\n        // If the default font does not have a glyph and the fallback font does, we use it\n        var font = shouldFallback ? getFallbackFont() : defaultFont;\n        var fontSize = getFontSize(run);\n\n        // If anything that would impact res has changed, update it\n        if (font !== lastFont || fontSize !== lastFontSize || font.unitsPerEm !== lastFont.unitsPerEm) {\n          if (lastFont) {\n            res.push({\n              start: lastIndex,\n              end: index,\n              attributes: {\n                font: lastFont,\n                scale: lastFontSize / lastFont.unitsPerEm\n              }\n            });\n          }\n          lastFont = font;\n          lastFontSize = fontSize;\n          lastIndex = index;\n        }\n        index += char.length;\n      }\n    }\n    if (lastIndex < string.length) {\n      var _fontSize = getFontSize(last(runs));\n      res.push({\n        start: lastIndex,\n        end: string.length,\n        attributes: {\n          font: lastFont,\n          scale: _fontSize / lastFont.unitsPerEm\n        }\n      });\n    }\n    return {\n      string: string,\n      runs: res\n    };\n  };\n};\nvar isTextInstance$4 = function isTextInstance(node) {\n  return node.type === P.TextInstance;\n};\nvar engines$1 = {\n  linebreaker: linebreaker,\n  justification: justification,\n  textDecoration: textDecoration,\n  scriptItemizer: scriptItemizer,\n  wordHyphenation: wordHyphenation,\n  fontSubstitution: fontSubstitution\n};\nvar engine$1 = layoutEngine(engines$1);\nvar getFragments$1 = function getFragments(fontStore, instance) {\n  if (!instance) return [{\n    string: ''\n  }];\n  var fragments = [];\n  var _instance$props = instance.props,\n    _instance$props$fill = _instance$props.fill,\n    fill = _instance$props$fill === void 0 ? 'black' : _instance$props$fill,\n    _instance$props$fontF = _instance$props.fontFamily,\n    fontFamily = _instance$props$fontF === void 0 ? 'Helvetica' : _instance$props$fontF,\n    fontWeight = _instance$props.fontWeight,\n    fontStyle = _instance$props.fontStyle,\n    _instance$props$fontS = _instance$props.fontSize,\n    fontSize = _instance$props$fontS === void 0 ? 18 : _instance$props$fontS,\n    textDecorationColor = _instance$props.textDecorationColor,\n    textDecorationStyle = _instance$props.textDecorationStyle,\n    textTransform = _instance$props.textTransform,\n    opacity = _instance$props.opacity;\n  var _textDecoration = instance.props.textDecoration;\n  var obj = fontStore ? fontStore.getFont({\n    fontFamily: fontFamily,\n    fontWeight: fontWeight,\n    fontStyle: fontStyle\n  }) : null;\n  var font = obj ? obj.data : fontFamily;\n  var attributes = {\n    font: font,\n    opacity: opacity,\n    fontSize: fontSize,\n    color: fill,\n    underlineStyle: textDecorationStyle,\n    underline: _textDecoration === 'underline' || _textDecoration === 'underline line-through' || _textDecoration === 'line-through underline',\n    underlineColor: textDecorationColor || fill,\n    strike: _textDecoration === 'line-through' || _textDecoration === 'underline line-through' || _textDecoration === 'line-through underline',\n    strikeStyle: textDecorationStyle,\n    strikeColor: textDecorationColor || fill\n  };\n  for (var i = 0; i < instance.children.length; i += 1) {\n    var child = instance.children[i];\n    if (isTextInstance$4(child)) {\n      fragments.push({\n        string: transformText(child.value, textTransform),\n        attributes: attributes\n      });\n    } else if (child) {\n      fragments.push.apply(fragments, getFragments(child));\n    }\n  }\n  return fragments;\n};\nvar getAttributedString$1 = function getAttributedString(fontStore, instance) {\n  return fromFragments(getFragments$1(fontStore, instance));\n};\nvar AlmostInfinity = 999999999999;\nvar shrinkWhitespaceFactor = {\n  before: -0.5,\n  after: -0.5\n};\nvar layoutTspan = function layoutTspan(fontStore) {\n  return function (node) {\n    var _node$props, _node$props2;\n    var attributedString = getAttributedString$1(fontStore, node);\n    var x = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.x) || 0;\n    var y = ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.y) || 0;\n    var container = {\n      x: x,\n      y: y,\n      width: AlmostInfinity,\n      height: AlmostInfinity\n    };\n    var hyphenationCallback = node.props.hyphenationCallback || (fontStore === null || fontStore === void 0 ? void 0 : fontStore.getHyphenationCallback()) || null;\n    var layoutOptions = {\n      hyphenationCallback: hyphenationCallback,\n      shrinkWhitespaceFactor: shrinkWhitespaceFactor\n    };\n    var lines = engine$1(attributedString, container, layoutOptions).flat();\n    return Object.assign({}, node, {\n      lines: lines\n    });\n  };\n};\nvar layoutText$1 = function layoutText(fontStore, node) {\n  if (!node.children) return node;\n  var children = node.children.map(layoutTspan(fontStore));\n  return Object.assign({}, node, {\n    children: children\n  });\n};\nvar isDefs = function isDefs(node) {\n  return node.type === P.Defs;\n};\nvar getDefs = function getDefs(node) {\n  var children = node.children || [];\n  var defs = children.find(isDefs) || {};\n  var values = defs.children || [];\n  return values.reduce(function (acc, value) {\n    var _value$props;\n    var id = (_value$props = value.props) === null || _value$props === void 0 ? void 0 : _value$props.id;\n    if (id) acc[id] = value;\n    return acc;\n  }, {});\n};\nvar isNotDefs = function isNotDefs(node) {\n  return node.type !== P.Defs;\n};\nvar detachDefs = function detachDefs(node) {\n  if (!node.children) return node;\n  var children = node.children.filter(isNotDefs);\n  return Object.assign({}, node, {\n    children: children\n  });\n};\nvar URL_REGEX = /url\\(['\"]?#([^'\"]+)['\"]?\\)/;\nvar replaceDef = function replaceDef(defs, value) {\n  if (!value) return undefined;\n  if (!URL_REGEX.test(value)) return value;\n  var match = value.match(URL_REGEX);\n  return defs[match[1]];\n};\nvar parseNodeDefs = function parseNodeDefs(defs) {\n  return function (node) {\n    var _node$props, _node$props2;\n    var fill = replaceDef(defs, (_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.fill);\n    var clipPath = replaceDef(defs, (_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.clipPath);\n    var props = Object.assign({}, node.props, {\n      fill: fill,\n      clipPath: clipPath\n    });\n    var children = node.children ? node.children.map(parseNodeDefs(defs)) : undefined;\n    return Object.assign({}, node, {\n      props: props,\n      children: children\n    });\n  };\n};\nvar parseDefs = function parseDefs(root) {\n  if (!root.children) return root;\n  var defs = getDefs(root);\n  var children = root.children.map(parseNodeDefs(defs));\n  return Object.assign({}, root, {\n    children: children\n  });\n};\nvar replaceDefs = function replaceDefs(node) {\n  return detachDefs(parseDefs(node));\n};\nvar parseViewbox = function parseViewbox(value) {\n  if (!value) return null;\n  var values = value.split(/[,\\s]+/).map(parseFloat);\n  if (values.length !== 4) return null;\n  return {\n    minX: values[0],\n    minY: values[1],\n    maxX: values[2],\n    maxY: values[3]\n  };\n};\nvar getContainer$1 = function getContainer(node) {\n  var viewbox = parseViewbox(node.props.viewBox);\n  if (viewbox) {\n    return {\n      width: viewbox.maxX,\n      height: viewbox.maxY\n    };\n  }\n  if (node.props.width && node.props.height) {\n    return {\n      width: parseFloat(node.props.width),\n      height: parseFloat(node.props.height)\n    };\n  }\n  return {\n    width: 0,\n    height: 0\n  };\n};\nvar SVG_INHERITED_PROPS = ['x', 'y', 'clipPath', 'clipRule', 'opacity', 'fill', 'fillOpacity', 'fillRule', 'stroke', 'strokeLinecap', 'strokeLinejoin', 'strokeOpacity', 'strokeWidth', 'textAnchor', 'dominantBaseline', 'color', 'fontFamily', 'fontSize', 'fontStyle', 'fontWeight', 'letterSpacing', 'opacity', 'textDecoration', 'lineHeight', 'textAlign', 'visibility', 'wordSpacing'];\nvar getInheritProps = function getInheritProps(node) {\n  var props = node.props || {};\n  return pick(SVG_INHERITED_PROPS, props);\n};\nvar inheritProps = function inheritProps(node) {\n  if (!node.children) return node;\n  var inheritedProps = getInheritProps(node);\n  var children = node.children.map(function (child) {\n    var props = Object.assign({}, inheritedProps, child.props || {});\n    var newChild = Object.assign({}, child, {\n      props: props\n    });\n    return inheritProps(newChild);\n  });\n  return Object.assign({}, node, {\n    children: children\n  });\n};\nvar parseAspectRatio = function parseAspectRatio(value) {\n  var match = value.replace(/[\\s\\r\\t\\n]+/gm, ' ').replace(/^defer\\s/, '').split(' ');\n  var align = match[0] || 'xMidYMid';\n  var meetOrSlice = match[1] || 'meet';\n  return {\n    align: align,\n    meetOrSlice: meetOrSlice\n  };\n};\nvar STYLE_PROPS = ['width', 'height', 'color', 'stroke', 'strokeWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'fill', 'fillRule', 'clipPath', 'offset', 'transform', 'strokeLinejoin', 'strokeLinecap', 'strokeDasharray'];\nvar VERTICAL_PROPS = ['y', 'y1', 'y2', 'height', 'cy', 'ry'];\nvar HORIZONTAL_PROPS = ['x', 'x1', 'x2', 'width', 'cx', 'rx'];\nvar isType$3 = function isType(type) {\n  return function (node) {\n    return node.type === type;\n  };\n};\nvar isSvg$3 = isType$3(P.Svg);\nvar isText$4 = isType$3(P.Text);\nvar isTextInstance$3 = isType$3(P.TextInstance);\nvar transformPercent = function transformPercent(container) {\n  return function (props) {\n    return mapValues(props, function (value, key) {\n      var match = matchPercent(value);\n      if (match && VERTICAL_PROPS.includes(key)) {\n        return match.percent * container.height;\n      }\n      if (match && HORIZONTAL_PROPS.includes(key)) {\n        return match.percent * container.width;\n      }\n      return value;\n    });\n  };\n};\nvar parsePercent = function parsePercent(value) {\n  var match = matchPercent(value);\n  return match ? match.percent : parseFloat(value);\n};\nvar parseProps = function parseProps(container) {\n  return function (node) {\n    var props = transformPercent(container)(node.props);\n    props = evolve({\n      x: parseFloat,\n      x1: parseFloat,\n      x2: parseFloat,\n      y: parseFloat,\n      y1: parseFloat,\n      y2: parseFloat,\n      r: parseFloat,\n      rx: parseFloat,\n      ry: parseFloat,\n      cx: parseFloat,\n      cy: parseFloat,\n      width: parseFloat,\n      height: parseFloat,\n      offset: parsePercent,\n      fill: transformColor,\n      opacity: parsePercent,\n      stroke: transformColor,\n      stopOpacity: parsePercent,\n      stopColor: transformColor,\n      transform: processTransform\n    }, props);\n    return Object.assign({}, node, {\n      props: props\n    });\n  };\n};\nvar mergeStyles$1 = function mergeStyles(node) {\n  var style = node.style || {};\n  var props = Object.assign({}, style, node.props);\n  return Object.assign({}, node, {\n    props: props\n  });\n};\nvar removeNoneValues = function removeNoneValues(node) {\n  var removeNone = function removeNone(value) {\n    return value === 'none' ? null : value;\n  };\n  var props = mapValues(node.props, removeNone);\n  return Object.assign({}, node, {\n    props: props\n  });\n};\nvar pickStyleProps = function pickStyleProps(node) {\n  var props = node.props || {};\n  var styleProps = pick(STYLE_PROPS, props);\n  var style = Object.assign({}, styleProps, node.style || {});\n  return Object.assign({}, node, {\n    style: style\n  });\n};\nvar parseSvgProps = function parseSvgProps(node) {\n  var props = evolve({\n    width: parseFloat,\n    height: parseFloat,\n    viewBox: parseViewbox,\n    preserveAspectRatio: parseAspectRatio\n  }, node.props);\n  return Object.assign({}, node, {\n    props: props\n  });\n};\nvar wrapBetweenTspan = function wrapBetweenTspan(node) {\n  return {\n    type: P.Tspan,\n    props: {},\n    children: [node]\n  };\n};\nvar addMissingTspan = function addMissingTspan(node) {\n  if (!isText$4(node)) return node;\n  if (!node.children) return node;\n  var resolveChild = function resolveChild(child) {\n    return isTextInstance$3(child) ? wrapBetweenTspan(child) : child;\n  };\n  var children = node.children.map(resolveChild);\n  return Object.assign({}, node, {\n    children: children\n  });\n};\nvar parseText = function parseText(fontStore) {\n  return function (node) {\n    if (isText$4(node)) return layoutText$1(fontStore, node);\n    if (!node.children) return node;\n    var children = node.children.map(parseText(fontStore));\n    return Object.assign({}, node, {\n      children: children\n    });\n  };\n};\nvar resolveSvgNode = function resolveSvgNode(container) {\n  return compose(parseProps(container), addMissingTspan, removeNoneValues, mergeStyles$1);\n};\nvar resolveChildren = function resolveChildren(container) {\n  return function (node) {\n    if (!node.children) return node;\n    var resolveChild = compose(resolveChildren(container), resolveSvgNode(container));\n    var children = node.children.map(resolveChild);\n    return Object.assign({}, node, {\n      children: children\n    });\n  };\n};\nvar resolveSvgRoot = function resolveSvgRoot(node, fontStore) {\n  var container = getContainer$1(node);\n  return compose(replaceDefs, parseText(fontStore), parseSvgProps, pickStyleProps, inheritProps, resolveChildren(container))(node);\n};\n\n/**\n * Pre-process SVG nodes so they can be rendered in the next steps\n *\n * @param {Object} root node\n * @param {Object} fontStore font store\n * @returns {Object} root node\n */\nvar resolveSvg = function resolveSvg(node, fontStore) {\n  if (!node.children) return node;\n  var resolveChild = function resolveChild(child) {\n    return resolveSvg(child, fontStore);\n  };\n  var root = isSvg$3(node) ? resolveSvgRoot(node, fontStore) : node;\n  var children = root.children.map(resolveChild);\n  return Object.assign({}, root, {\n    children: children\n  });\n};\nvar getZIndex = function getZIndex(node) {\n  return node.style.zIndex;\n};\nvar shouldSort = function shouldSort(node) {\n  return node.type !== P.Document && node.type !== P.Svg;\n};\nvar sortZIndex = function sortZIndex(a, b) {\n  var za = getZIndex(a);\n  var zb = getZIndex(b);\n  if (!za && !zb) return 0;\n  if (!za) return 1;\n  if (!zb) return -1;\n  return zb - za;\n};\n\n/**\n * Sort children by zIndex value\n *\n * @param {Object} node\n * @returns {Object} node\n */\nvar resolveZIndex = function resolveZIndex(node) {\n  if (!node.children) return node;\n  var sortedChildren = shouldSort(node) ? node.children.sort(sortZIndex) : node.children;\n  var children = sortedChildren.map(resolveZIndex);\n  return Object.assign({}, node, {\n    children: children\n  });\n};\n\n// Caches emoji images data\nvar emojis = {};\nvar regex = emojiRegex();\nvar reflect = function reflect(promise) {\n  return function () {\n    return promise.apply(void 0, arguments).then(function (v) {\n      return v;\n    }, function (e) {\n      return e;\n    });\n  };\n};\n\n// Returns a function to be able to mock resolveImage.\nvar makeFetchEmojiImage = function makeFetchEmojiImage() {\n  return reflect(resolveImage);\n};\n\n/**\n * When an emoji as no color, it might still have 2 parts,\n * the canonical emoji and an empty string.\n * ex.\n *   (no color) Array.from('‚ù§Ô∏è') => [\"‚ù§\", \"Ô∏è\"]\n *   (w/ color) Array.from('üëçüèø') => [\"üëç\", \"üèø\"]\n *\n * The empty string needs to be removed otherwise the generated\n * url will be incorect.\n */\nvar _removeNoColor = function _removeNoColor(x) {\n  return x !== 'Ô∏è';\n};\nvar getCodePoints = function getCodePoints(string) {\n  return Array.from(string).filter(_removeNoColor).map(function (char) {\n    return char.codePointAt(0).toString(16);\n  }).join('-');\n};\nvar buildEmojiUrl = function buildEmojiUrl(emoji, source) {\n  var url = source.url,\n    format = source.format,\n    builder = source.builder;\n  if (typeof builder === 'function') {\n    return builder(getCodePoints(emoji));\n  }\n  return \"\" + url + getCodePoints(emoji) + \".\" + format;\n};\nvar fetchEmojis = function fetchEmojis(string, source) {\n  if (!source || !source.url && !source.builder) return [];\n  var promises = [];\n  var match;\n  var _loop = function _loop() {\n    var emoji = match[0];\n    if (!emojis[emoji] || emojis[emoji].loading) {\n      var emojiUrl = buildEmojiUrl(emoji, source);\n      emojis[emoji] = {\n        loading: true\n      };\n      var fetchEmojiImage = makeFetchEmojiImage();\n      promises.push(fetchEmojiImage({\n        uri: emojiUrl\n      }).then(function (image) {\n        emojis[emoji].loading = false;\n        emojis[emoji].data = image.data;\n      }));\n    }\n  };\n  while (match = regex.exec(string)) {\n    _loop();\n  }\n  return promises;\n};\nvar embedEmojis = function embedEmojis(fragments) {\n  var result = [];\n  for (var i = 0; i < fragments.length; i += 1) {\n    var fragment = fragments[i];\n    var match = void 0;\n    var lastIndex = 0;\n    while (match = regex.exec(fragment.string)) {\n      var _match = match,\n        index = _match.index;\n      var emoji = match[0];\n      var emojiSize = fragment.attributes.fontSize;\n      var chunk = fragment.string.slice(lastIndex, index + match[0].length);\n\n      // If emoji image was found, we create a new fragment with the\n      // correct attachment and object substitution character;\n      if (emojis[emoji] && emojis[emoji].data) {\n        result.push({\n          string: chunk.replace(match, String.fromCharCode(0xfffc)),\n          attributes: _extends({}, fragment.attributes, {\n            attachment: {\n              width: emojiSize,\n              height: emojiSize,\n              yOffset: Math.floor(emojiSize * 0.1),\n              image: emojis[emoji].data\n            }\n          })\n        });\n      } else {\n        // If no emoji data, we just replace the emoji with a nodef char\n        result.push({\n          string: chunk.replace(match, String.fromCharCode(0)),\n          attributes: fragment.attributes\n        });\n      }\n      lastIndex = index + emoji.length;\n    }\n    if (lastIndex < fragment.string.length) {\n      result.push({\n        string: fragment.string.slice(lastIndex),\n        attributes: fragment.attributes\n      });\n    }\n  }\n  return result;\n};\n\n/**\n * Get image source\n *\n * @param {Object} image node\n * @returns {String | Object} image src\n */\nvar getSource = function getSource(node) {\n  var _node$props, _node$props2, _node$props3;\n  return ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.src) || ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.source) || ((_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.href);\n};\n\n/**\n * Resolves `src` to `@react-pdf/image` interface.\n *\n * Also it handles factories and async sources.\n *\n * @param {string | Object | Function} src\n * @returns {object} resolved src\n */\nvar resolveSource = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(src) {\n    var source;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          if (!(typeof src === 'function')) {\n            _context.next = 6;\n            break;\n          }\n          _context.next = 3;\n          return src();\n        case 3:\n          _context.t0 = _context.sent;\n          _context.next = 9;\n          break;\n        case 6:\n          _context.next = 8;\n          return src;\n        case 8:\n          _context.t0 = _context.sent;\n        case 9:\n          source = _context.t0;\n          return _context.abrupt(\"return\", typeof source === 'string' ? {\n            uri: source\n          } : source);\n        case 11:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function resolveSource(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\n/**\n * Fetches image and append data to node\n * Ideally this fn should be immutable.\n *\n * @param {Object} node\n */\nvar fetchImage = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(node) {\n    var src, cache, source;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          src = getSource(node);\n          cache = node.props.cache;\n          if (src) {\n            _context.next = 5;\n            break;\n          }\n          console.warn(false, 'Image should receive either a \"src\" or \"source\" prop');\n          return _context.abrupt(\"return\");\n        case 5:\n          _context.prev = 5;\n          _context.next = 8;\n          return resolveSource(src);\n        case 8:\n          source = _context.sent;\n          if (source) {\n            _context.next = 11;\n            break;\n          }\n          throw new Error(\"Image's \\\"src\\\" or \\\"source\\\" prop returned \" + source);\n        case 11:\n          _context.next = 13;\n          return resolveImage(source, {\n            cache: cache\n          });\n        case 13:\n          node.image = _context.sent;\n          node.image.key = source.data ? source.data.toString() : source.uri;\n          _context.next = 21;\n          break;\n        case 17:\n          _context.prev = 17;\n          _context.t0 = _context[\"catch\"](5);\n          node.image = {\n            width: 0,\n            height: 0,\n            key: null\n          };\n          console.warn(_context.t0.message);\n        case 21:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[5, 17]]);\n  }));\n  return function fetchImage(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\nvar isImage$2 = function isImage(node) {\n  return node.type === P.Image;\n};\n\n/**\n * Get all asset promises that need to be resolved\n *\n * @param {Object} root node\n * @returns {Array} asset promises\n */\nvar fetchAssets = function fetchAssets(fontStore, node) {\n  var _node$children;\n  var promises = [];\n  var listToExplore = ((_node$children = node.children) === null || _node$children === void 0 ? void 0 : _node$children.slice(0)) || [];\n  var emojiSource = fontStore ? fontStore.getEmojiSource() : null;\n  while (listToExplore.length > 0) {\n    var _n$style;\n    var n = listToExplore.shift();\n    if (isImage$2(n)) {\n      promises.push(fetchImage(n));\n    }\n    if (fontStore && (_n$style = n.style) !== null && _n$style !== void 0 && _n$style.fontFamily) {\n      promises.push(fontStore.load(n.style));\n    }\n    if (typeof n === 'string') {\n      promises.push.apply(promises, fetchEmojis(n, emojiSource));\n    }\n    if (typeof n.value === 'string') {\n      promises.push.apply(promises, fetchEmojis(n.value, emojiSource));\n    }\n    if (n.children) {\n      n.children.forEach(function (childNode) {\n        listToExplore.push(childNode);\n      });\n    }\n  }\n  return promises;\n};\n\n/**\n * Fetch image, font and emoji assets in parallel.\n * Layout process will not be resumed until promise resolves.\n *\n * @param {Object} root node\n * @param {Object} fontStore font store\n * @returns {Object} root node\n */\nvar resolveAssets = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(node, fontStore) {\n    var promises;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          promises = fetchAssets(fontStore, node);\n          _context.next = 3;\n          return Promise.all(promises);\n        case 3:\n          return _context.abrupt(\"return\", node);\n        case 4:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function resolveAssets(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\nvar isLink$1 = function isLink(node) {\n  return node.type === P.Link;\n};\nvar DEFAULT_LINK_STYLES = {\n  color: 'blue',\n  textDecoration: 'underline'\n};\n\n/**\n * Computes styles using stylesheet\n *\n * @param {Object} container\n * @param {Object} document node\n * @returns {Object} computed styles\n */\nvar computeStyle = function computeStyle(container, node) {\n  var baseStyle = node.style;\n  if (isLink$1(node)) {\n    baseStyle = Array.isArray(node.style) ? [DEFAULT_LINK_STYLES].concat(node.style) : [DEFAULT_LINK_STYLES, node.style];\n  }\n  return stylesheet(container, baseStyle);\n};\n\n/**\n * Resolves node styles\n *\n * @param {Object} container\n * @param {Object} document node\n * @returns {Object} node (and subnodes) with resolved styles\n */\nvar resolveNodeStyles = function resolveNodeStyles(container) {\n  return function (node) {\n    var style = computeStyle(container, node);\n    if (!node.children) return Object.assign({}, node, {\n      style: style\n    });\n    var children = node.children.map(resolveNodeStyles(container));\n    return Object.assign({}, node, {\n      style: style,\n      children: children\n    });\n  };\n};\n\n/**\n * Resolves page styles\n *\n * @param {Object} document page\n * @returns {Object} document page with resolved styles\n */\nvar resolvePageStyles = function resolvePageStyles(page) {\n  var _page$props, _page$box, _page$box2, _page$props2;\n  var dpi = ((_page$props = page.props) === null || _page$props === void 0 ? void 0 : _page$props.dpi) || 72;\n  var width = ((_page$box = page.box) === null || _page$box === void 0 ? void 0 : _page$box.width) || page.style.width;\n  var height = ((_page$box2 = page.box) === null || _page$box2 === void 0 ? void 0 : _page$box2.height) || page.style.height;\n  var orientation = ((_page$props2 = page.props) === null || _page$props2 === void 0 ? void 0 : _page$props2.orientation) || 'portrait';\n  var container = {\n    width: width,\n    height: height,\n    orientation: orientation,\n    dpi: dpi\n  };\n  return resolveNodeStyles(container)(page);\n};\n\n/**\n * Resolves document styles\n *\n * @param {Object} document root\n * @returns {Object} document root with resolved styles\n */\nvar resolveStyles = function resolveStyles(root) {\n  if (!root.children) return root;\n  var children = root.children.map(resolvePageStyles);\n  return Object.assign({}, root, {\n    children: children\n  });\n};\nvar getTransformStyle = function getTransformStyle(s) {\n  return function (node) {\n    var _node$style, _node$style2;\n    return isNil((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style[s]) ? '50%' : (_node$style2 = node.style) === null || _node$style2 === void 0 ? void 0 : _node$style2[s];\n  };\n};\n\n/**\n * Get node origin\n *\n * @param {Object} node\n * @returns {Object} node origin\n */\nvar getOrigin = function getOrigin(node) {\n  if (!node.box) return {};\n  var _node$box = node.box,\n    left = _node$box.left,\n    top = _node$box.top,\n    width = _node$box.width,\n    height = _node$box.height;\n  var transformOriginX = getTransformStyle('transformOriginX')(node);\n  var transformOriginY = getTransformStyle('transformOriginY')(node);\n  var percentX = matchPercent(transformOriginX);\n  var percentY = matchPercent(transformOriginY);\n  var offsetX = percentX ? width * percentX.percent : transformOriginX;\n  var offsetY = percentY ? height * percentY.percent : transformOriginY;\n  return {\n    left: left + offsetX,\n    top: top + offsetY\n  };\n};\n\n/**\n * Resolve node origin\n *\n * @param {Object} node\n * @returns {Object} node with origin attribute\n */\nvar resolveNodeOrigin = function resolveNodeOrigin(node) {\n  var origin = getOrigin(node);\n  var newNode = Object.assign({}, node, {\n    origin: origin\n  });\n  if (!node.children) return newNode;\n  var children = node.children.map(resolveNodeOrigin);\n  return Object.assign({}, newNode, {\n    children: children\n  });\n};\n\n/**\n * Resolve document origins\n *\n * @param {Object} document root\n * @returns {Object} documrnt root\n */\n\nvar resolveOrigin = function resolveOrigin(root) {\n  if (!root.children) return root;\n  var children = root.children.map(resolveNodeOrigin);\n  return Object.assign({}, root, {\n    children: children\n  });\n};\n\n/* eslint-disable no-plusplus */\n/* eslint-disable prefer-const */\n/* eslint-disable prefer-destructuring */\n\nvar getBookmarkValue = function getBookmarkValue(title) {\n  return typeof title === 'string' ? {\n    title: title,\n    fit: false,\n    expanded: false\n  } : title;\n};\nvar resolveBookmarks = function resolveBookmarks(node) {\n  var refs = 0;\n  var children = (node.children || []).slice(0);\n  var listToExplore = children.map(function (value) {\n    return {\n      value: value,\n      parent: null\n    };\n  });\n  var _loop = function _loop() {\n    var _child$props;\n    var element = listToExplore.shift();\n    var child = element.value;\n    var parent = element.parent;\n    if ((_child$props = child.props) !== null && _child$props !== void 0 && _child$props.bookmark) {\n      var _parent;\n      var bookmark = getBookmarkValue(child.props.bookmark);\n      var ref = refs++;\n      var newHierarchy = _extends({\n        ref: ref,\n        parent: (_parent = parent) === null || _parent === void 0 ? void 0 : _parent.ref\n      }, bookmark);\n      child.props.bookmark = newHierarchy;\n      parent = newHierarchy;\n    }\n    if (child.children) {\n      child.children.forEach(function (childNode) {\n        listToExplore.push({\n          value: childNode,\n          parent: parent\n        });\n      });\n    }\n  };\n  while (listToExplore.length > 0) {\n    _loop();\n  }\n  return node;\n};\nvar VALID_ORIENTATIONS = ['portrait', 'landscape'];\n\n/**\n * Get page orientation. Defaults to portrait\n *\n * @param { Object } page object\n * @returns { String } page orientation\n */\nvar getOrientation = function getOrientation(page) {\n  var _page$props;\n  var value = ((_page$props = page.props) === null || _page$props === void 0 ? void 0 : _page$props.orientation) || 'portrait';\n  return VALID_ORIENTATIONS.includes(value) ? value : 'portrait';\n};\n\n/**\n * Return true if page is landscape\n *\n * @param {Object} page instance\n * @returns {Boolean} is page landscape\n */\nvar isLandscape = function isLandscape(page) {\n  return getOrientation(page) === 'landscape';\n};\nvar PAGE_SIZES = {\n  '4A0': [4767.87, 6740.79],\n  '2A0': [3370.39, 4767.87],\n  A0: [2383.94, 3370.39],\n  A1: [1683.78, 2383.94],\n  A2: [1190.55, 1683.78],\n  A3: [841.89, 1190.55],\n  A4: [595.28, 841.89],\n  A5: [419.53, 595.28],\n  A6: [297.64, 419.53],\n  A7: [209.76, 297.64],\n  A8: [147.4, 209.76],\n  A9: [104.88, 147.4],\n  A10: [73.7, 104.88],\n  B0: [2834.65, 4008.19],\n  B1: [2004.09, 2834.65],\n  B2: [1417.32, 2004.09],\n  B3: [1000.63, 1417.32],\n  B4: [708.66, 1000.63],\n  B5: [498.9, 708.66],\n  B6: [354.33, 498.9],\n  B7: [249.45, 354.33],\n  B8: [175.75, 249.45],\n  B9: [124.72, 175.75],\n  B10: [87.87, 124.72],\n  C0: [2599.37, 3676.54],\n  C1: [1836.85, 2599.37],\n  C2: [1298.27, 1836.85],\n  C3: [918.43, 1298.27],\n  C4: [649.13, 918.43],\n  C5: [459.21, 649.13],\n  C6: [323.15, 459.21],\n  C7: [229.61, 323.15],\n  C8: [161.57, 229.61],\n  C9: [113.39, 161.57],\n  C10: [79.37, 113.39],\n  RA0: [2437.8, 3458.27],\n  RA1: [1729.13, 2437.8],\n  RA2: [1218.9, 1729.13],\n  RA3: [864.57, 1218.9],\n  RA4: [609.45, 864.57],\n  SRA0: [2551.18, 3628.35],\n  SRA1: [1814.17, 2551.18],\n  SRA2: [1275.59, 1814.17],\n  SRA3: [907.09, 1275.59],\n  SRA4: [637.8, 907.09],\n  EXECUTIVE: [521.86, 756.0],\n  FOLIO: [612.0, 936.0],\n  LEGAL: [612.0, 1008.0],\n  LETTER: [612.0, 792.0],\n  TABLOID: [792.0, 1224.0],\n  ID1: [153, 243]\n};\n\n/**\n * Transforms array into size object\n *\n * @param {Array} array\n * @returns {Object} size object with width and height\n */\nvar toSizeObject = function toSizeObject(v) {\n  return {\n    width: v[0],\n    height: v[1]\n  };\n};\n\n/**\n * Flip size object\n *\n * @param {Object} size object\n * @returns {Object} flipped size object\n */\nvar flipSizeObject = function flipSizeObject(v) {\n  return {\n    width: v.height,\n    height: v.width\n  };\n};\n\n/**\n * Adjust page size to passed DPI\n *\n * @param {Object} size object\n * @param {number} dpi\n * @returns {Object} adjusted size object\n */\nvar adjustDpi = function adjustDpi(v, dpi) {\n  return {\n    width: v.width ? v.width * dpi : v.width,\n    height: v.height ? v.height * dpi : v.height\n  };\n};\n\n/**\n * Returns size object from a given string\n *\n * @param {String} page size string\n * @returns {Object} size object with width and height\n */\nvar getStringSize = function getStringSize(v) {\n  return toSizeObject(PAGE_SIZES[v.toUpperCase()]);\n};\n\n/**\n * Returns size object from a single number\n *\n * @param {Number} page size number\n * @returns {Object} size object with width and height\n */\nvar getNumberSize = function getNumberSize(n) {\n  return toSizeObject([n]);\n};\n\n/**\n * Return page size in an object { width, height }\n *\n * @param {Object} page instance\n * @returns {Object} size object with width and height\n */\nvar getSize = function getSize(page) {\n  var _page$props, _page$props2;\n  var value = ((_page$props = page.props) === null || _page$props === void 0 ? void 0 : _page$props.size) || 'A4';\n  var dpi = parseFloat(((_page$props2 = page.props) === null || _page$props2 === void 0 ? void 0 : _page$props2.dpi) || 72);\n  var type = typeof value;\n  var size = value;\n  if (type === 'string') {\n    size = getStringSize(value);\n  } else if (Array.isArray(value)) {\n    size = toSizeObject(value);\n  } else if (type === 'number') {\n    size = getNumberSize(value);\n  }\n  size = adjustDpi(size, dpi / 72);\n  return isLandscape(page) ? flipSizeObject(size) : size;\n};\n\n/**\n * Resolves page size\n *\n * @param {Object} page\n * @returns {Object} page with resolved size in style attribute\n */\nvar resolvePageSize = function resolvePageSize(page) {\n  var size = getSize(page);\n  var style = flatten(page.style || {});\n  return _extends({}, page, {\n    style: _extends({}, style, size)\n  });\n};\n\n/**\n * Resolves page sizes\n *\n * @param {Object} document root\n * @returns {Object} document root with resolved page sizes\n */\nvar resolvePageSizes = function resolvePageSizes(root) {\n  if (!root.children) return root;\n  var children = root.children.map(resolvePageSize);\n  return Object.assign({}, root, {\n    children: children\n  });\n};\nvar isFixed = function isFixed(node) {\n  var _node$props;\n  return ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.fixed) === true;\n};\n\n/**\n * Get line index at given height\n *\n * @param {Object} node\n * @param {Number} height\n */\nvar lineIndexAtHeight = function lineIndexAtHeight(node, height) {\n  var y = 0;\n  if (!node.lines) return 0;\n  for (var i = 0; i < node.lines.length; i += 1) {\n    var line = node.lines[i];\n    if (y + line.box.height > height) return i;\n    y += line.box.height;\n  }\n  return node.lines.length;\n};\n\n/**\n * Get height for given text line index\n *\n * @param {Object} node\n * @param {Number} index\n */\nvar heightAtLineIndex = function heightAtLineIndex(node, index) {\n  var counter = 0;\n  if (!node.lines) return counter;\n  for (var i = 0; i < index; i += 1) {\n    var line = node.lines[i];\n    if (!line) break;\n    counter += line.box.height;\n  }\n  return counter;\n};\nvar getLineBreak = function getLineBreak(node, height) {\n  var top = get(node, ['box', 'top'], 0);\n  var widows = get(node, ['props', 'widows'], 2);\n  var orphans = get(node, ['props', 'orphans'], 2);\n  var linesQuantity = node.lines.length;\n  var slicedLine = lineIndexAtHeight(node, height - top);\n  if (slicedLine === 0) {\n    return 0;\n  }\n  if (linesQuantity < orphans) {\n    return linesQuantity;\n  }\n  if (slicedLine < orphans || linesQuantity < orphans + widows) {\n    return 0;\n  }\n  if (linesQuantity === orphans + widows) {\n    return orphans;\n  }\n  if (linesQuantity - slicedLine < widows) {\n    return linesQuantity - widows;\n  }\n  return slicedLine;\n};\n\n// Also receives contentArea in case it's needed\nvar splitText = function splitText(node, height) {\n  var slicedLineIndex = getLineBreak(node, height);\n  var currentHeight = heightAtLineIndex(node, slicedLineIndex);\n  var nextHeight = node.box.height - currentHeight;\n  var current = Object.assign({}, node, {\n    box: _extends({}, node.box, {\n      height: currentHeight,\n      borderBottomWidth: 0\n    }),\n    style: _extends({}, node.style, {\n      marginBottom: 0,\n      paddingBottom: 0,\n      borderBottomWidth: 0,\n      borderBottomLeftRadius: 0,\n      borderBottomRightRadius: 0\n    }),\n    lines: node.lines.slice(0, slicedLineIndex)\n  });\n  var next = Object.assign({}, node, {\n    box: _extends({}, node.box, {\n      top: 0,\n      height: nextHeight,\n      borderTopWidth: 0\n    }),\n    style: _extends({}, node.style, {\n      marginTop: 0,\n      paddingTop: 0,\n      borderTopWidth: 0,\n      borderTopLeftRadius: 0,\n      borderTopRightRadius: 0\n    }),\n    lines: node.lines.slice(slicedLineIndex)\n  });\n  return [current, next];\n};\nvar getTop$1 = function getTop(node) {\n  var _node$box;\n  return ((_node$box = node.box) === null || _node$box === void 0 ? void 0 : _node$box.top) || 0;\n};\nvar hasFixedHeight = function hasFixedHeight(node) {\n  var _node$style;\n  return !isNil((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.height);\n};\nvar splitNode = function splitNode(node, height) {\n  if (!node) return [null, null];\n  var nodeTop = getTop$1(node);\n  var current = Object.assign({}, node, {\n    box: _extends({}, node.box, {\n      borderBottomWidth: 0\n    }),\n    style: _extends({}, node.style, {\n      marginBottom: 0,\n      paddingBottom: 0,\n      borderBottomWidth: 0,\n      borderBottomLeftRadius: 0,\n      borderBottomRightRadius: 0\n    })\n  });\n  current.style.height = height - nodeTop;\n  var nextHeight = hasFixedHeight(node) ? node.box.height - (height - nodeTop) : null;\n  var next = Object.assign({}, node, {\n    box: _extends({}, node.box, {\n      top: 0,\n      borderTopWidth: 0\n    }),\n    style: _extends({}, node.style, {\n      marginTop: 0,\n      paddingTop: 0,\n      borderTopWidth: 0,\n      borderTopLeftRadius: 0,\n      borderTopRightRadius: 0\n    })\n  });\n  if (nextHeight) {\n    next.style.height = nextHeight;\n  }\n  return [current, next];\n};\nvar NON_WRAP_TYPES = [P.Svg, P.Note, P.Image, P.Canvas];\nvar getWrap = function getWrap(node) {\n  var _node$props;\n  if (NON_WRAP_TYPES.includes(node.type)) return false;\n  return isNil((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.wrap) ? true : node.props.wrap;\n};\nvar getComputedPadding = function getComputedPadding(node, edge) {\n  var yogaNode = node.yogaNode;\n  return yogaNode ? yogaNode.getComputedPadding(edge) : null;\n};\n\n/**\n * Get Yoga computed paddings. Zero otherwise\n *\n * @param {Object} node\n * @return {Object} paddings\n */\nvar getPadding = function getPadding(node) {\n  var style = node.style,\n    box = node.box;\n  var paddingTop = getComputedPadding(node, Yoga.EDGE_TOP) || (box === null || box === void 0 ? void 0 : box.paddingTop) || (style === null || style === void 0 ? void 0 : style.paddingTop) || (style === null || style === void 0 ? void 0 : style.paddingVertical) || (style === null || style === void 0 ? void 0 : style.padding) || 0;\n  var paddingRight = getComputedPadding(node, Yoga.EDGE_RIGHT) || (box === null || box === void 0 ? void 0 : box.paddingRight) || (style === null || style === void 0 ? void 0 : style.paddingRight) || (style === null || style === void 0 ? void 0 : style.paddingHorizontal) || (style === null || style === void 0 ? void 0 : style.padding) || 0;\n  var paddingBottom = getComputedPadding(node, Yoga.EDGE_BOTTOM) || (box === null || box === void 0 ? void 0 : box.paddingBottom) || (style === null || style === void 0 ? void 0 : style.paddingBottom) || (style === null || style === void 0 ? void 0 : style.paddingVertical) || (style === null || style === void 0 ? void 0 : style.padding) || 0;\n  var paddingLeft = getComputedPadding(node, Yoga.EDGE_LEFT) || (box === null || box === void 0 ? void 0 : box.paddingLeft) || (style === null || style === void 0 ? void 0 : style.paddingLeft) || (style === null || style === void 0 ? void 0 : style.paddingHorizontal) || (style === null || style === void 0 ? void 0 : style.padding) || 0;\n  return {\n    paddingTop: paddingTop,\n    paddingRight: paddingRight,\n    paddingBottom: paddingBottom,\n    paddingLeft: paddingLeft\n  };\n};\nvar getWrapArea = function getWrapArea(page) {\n  var _page$style;\n  var _getPadding = getPadding(page),\n    paddingBottom = _getPadding.paddingBottom;\n  var height = (_page$style = page.style) === null || _page$style === void 0 ? void 0 : _page$style.height;\n  return height - paddingBottom;\n};\nvar getContentArea = function getContentArea(page) {\n  var _page$style;\n  var height = (_page$style = page.style) === null || _page$style === void 0 ? void 0 : _page$style.height;\n  var _getPadding = getPadding(page),\n    paddingTop = _getPadding.paddingTop,\n    paddingBottom = _getPadding.paddingBottom;\n  return height - paddingBottom - paddingTop;\n};\nvar _excluded = [\"style\", \"children\"];\nvar isString = function isString(value) {\n  return typeof value === 'string';\n};\nvar isNumber = function isNumber(value) {\n  return typeof value === 'number';\n};\nvar isFragment = function isFragment(value) {\n  return value && value.type === Symbol.for('react.fragment');\n};\n\n/**\n * Transforms a react element instance to internal element format.\n *\n * Can return multiple instances in the case of arrays or fragments.\n *\n * @param {Object} React element\n * @returns {Array} parsed react elements\n */\nvar createInstances = function createInstances(element) {\n  if (!element) return [];\n  if (isString(element) || isNumber(element)) {\n    return [{\n      type: TextInstance,\n      value: \"\" + element\n    }];\n  }\n  if (isFragment(element)) {\n    return createInstances(element.props.children);\n  }\n  if (Array.isArray(element)) {\n    return element.reduce(function (acc, el) {\n      return acc.concat(createInstances(el));\n    }, []);\n  }\n  if (!isString(element.type)) {\n    return createInstances(element.type(element.props));\n  }\n  var type = element.type,\n    _element$props = element.props,\n    _element$props$style = _element$props.style,\n    style = _element$props$style === void 0 ? {} : _element$props$style,\n    _element$props$childr = _element$props.children,\n    children = _element$props$childr === void 0 ? [] : _element$props$childr,\n    props = _objectWithoutPropertiesLoose(_element$props, _excluded);\n  var nextChildren = castArray(children).reduce(function (acc, child) {\n    return acc.concat(createInstances(child));\n  }, []);\n  return [{\n    type: type,\n    style: style,\n    props: props,\n    box: {},\n    children: nextChildren\n  }];\n};\n\n/**\n * Get many nodes height\n *\n * @param {Array} nodes\n * @return {number} nodes height\n */\nvar getNodesHeight = function getNodesHeight(nodes) {\n  var max = 0;\n  var min = Infinity;\n  if (!nodes || nodes.length === 0) return 0;\n  for (var i = 0; i < nodes.length; i += 1) {\n    var node = nodes[i];\n    min = Math.min(min, node.box.top);\n    max = Math.max(max, node.box.top + node.box.height);\n  }\n  return max - min;\n};\n\n/* eslint-disable no-continue */\nvar getBreak = function getBreak(node) {\n  var _node$props;\n  return ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.break) || false;\n};\nvar getMinPresenceAhead = function getMinPresenceAhead(node) {\n  var _node$props2;\n  return (_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.minPresenceAhead;\n};\nvar defaultPresenceAhead = function defaultPresenceAhead(element) {\n  return function (height) {\n    return Math.min(element.box.height, height);\n  };\n};\nvar getPresenceAhead = function getPresenceAhead(elements, height) {\n  var result = 0;\n  for (var i = 0; i < elements.length; i += 1) {\n    var element = elements[i];\n    if (!element.box) continue;\n    var isElementInside = height > element.box.top;\n    var presenceAhead = element.props.presenceAhead || defaultPresenceAhead(element);\n    if (element && isElementInside) {\n      result += presenceAhead(height - element.box.top);\n    }\n  }\n  return result;\n};\nvar shouldBreak = function shouldBreak(child, futureElements, height) {\n  var minPresenceAhead = getMinPresenceAhead(child);\n  var presenceAhead = getPresenceAhead(futureElements, height);\n  var futureHeight = getNodesHeight(futureElements);\n  var shouldSplit = height < child.box.top + child.box.height;\n  var shouldWrap = getWrap(child);\n  return getBreak(child) || !shouldWrap && shouldSplit || minPresenceAhead < futureHeight && presenceAhead < minPresenceAhead;\n};\nvar IGNORABLE_CODEPOINTS = [8232,\n// LINE_SEPARATOR\n8233 // PARAGRAPH_SEPARATOR\n];\n\nvar buildSubsetForFont = function buildSubsetForFont(font) {\n  return IGNORABLE_CODEPOINTS.reduce(function (acc, codePoint) {\n    if (font && font.hasGlyphForCodePoint && font.hasGlyphForCodePoint(codePoint)) {\n      return acc;\n    }\n    return [].concat(acc, [String.fromCharCode(codePoint)]);\n  }, []);\n};\nvar ignoreChars = function ignoreChars(fragments) {\n  return fragments.map(function (fragment) {\n    var charSubset = buildSubsetForFont(fragment.attributes.font);\n    var subsetRegex = new RegExp(charSubset.join('|'));\n    return {\n      string: fragment.string.replace(subsetRegex, ''),\n      attributes: fragment.attributes\n    };\n  });\n};\nvar PREPROCESSORS = [ignoreChars, embedEmojis];\nvar isImage$1 = function isImage(node) {\n  return node.type === P.Image;\n};\nvar isTextInstance$2 = function isTextInstance(node) {\n  return node.type === P.TextInstance;\n};\n\n/**\n * Get textkit fragments of given node object\n *\n * @param {Object} font store\n * @param {Object} instance node\n * @returns {Array} text fragments\n */\nvar getFragments = function getFragments(fontStore, instance, parentLink, level) {\n  var _instance$props, _instance$props2;\n  if (level === void 0) {\n    level = 0;\n  }\n  if (!instance) return [{\n    string: ''\n  }];\n  var fragments = [];\n  var _instance$style = instance.style,\n    _instance$style$color = _instance$style.color,\n    color = _instance$style$color === void 0 ? 'black' : _instance$style$color,\n    _instance$style$fontF = _instance$style.fontFamily,\n    fontFamily = _instance$style$fontF === void 0 ? 'Helvetica' : _instance$style$fontF,\n    fontWeight = _instance$style.fontWeight,\n    fontStyle = _instance$style.fontStyle,\n    _instance$style$fontS = _instance$style.fontSize,\n    fontSize = _instance$style$fontS === void 0 ? 18 : _instance$style$fontS,\n    _instance$style$textA = _instance$style.textAlign,\n    textAlign = _instance$style$textA === void 0 ? 'left' : _instance$style$textA,\n    lineHeight = _instance$style.lineHeight,\n    textDecoration = _instance$style.textDecoration,\n    textDecorationColor = _instance$style.textDecorationColor,\n    textDecorationStyle = _instance$style.textDecorationStyle,\n    textTransform = _instance$style.textTransform,\n    letterSpacing = _instance$style.letterSpacing,\n    textIndent = _instance$style.textIndent,\n    opacity = _instance$style.opacity,\n    verticalAlign = _instance$style.verticalAlign;\n  var opts = {\n    fontFamily: fontFamily,\n    fontWeight: fontWeight,\n    fontStyle: fontStyle\n  };\n  var obj = fontStore ? fontStore.getFont(opts) : null;\n  var font = obj ? obj.data : fontFamily;\n\n  // Don't pass main background color to textkit. Will be rendered by the render package instead\n  var backgroundColor = level === 0 ? null : instance.style.backgroundColor;\n  var attributes = {\n    font: font,\n    color: color,\n    opacity: opacity,\n    fontSize: fontSize,\n    backgroundColor: backgroundColor,\n    align: textAlign,\n    indent: textIndent,\n    characterSpacing: letterSpacing,\n    strikeStyle: textDecorationStyle,\n    underlineStyle: textDecorationStyle,\n    underline: textDecoration === 'underline' || textDecoration === 'underline line-through' || textDecoration === 'line-through underline',\n    strike: textDecoration === 'line-through' || textDecoration === 'underline line-through' || textDecoration === 'line-through underline',\n    strikeColor: textDecorationColor || color,\n    underlineColor: textDecorationColor || color,\n    link: parentLink || ((_instance$props = instance.props) === null || _instance$props === void 0 ? void 0 : _instance$props.src) || ((_instance$props2 = instance.props) === null || _instance$props2 === void 0 ? void 0 : _instance$props2.href),\n    lineHeight: lineHeight ? lineHeight * fontSize : null,\n    verticalAlign: verticalAlign\n  };\n  for (var i = 0; i < instance.children.length; i += 1) {\n    var child = instance.children[i];\n    if (isImage$1(child)) {\n      fragments.push({\n        string: String.fromCharCode(0xfffc),\n        attributes: _extends({}, attributes, {\n          attachment: {\n            width: child.style.width || fontSize,\n            height: child.style.height || fontSize,\n            image: child.image.data\n          }\n        })\n      });\n    } else if (isTextInstance$2(child)) {\n      fragments.push({\n        string: transformText(child.value, textTransform),\n        attributes: attributes\n      });\n    } else if (child) {\n      var _fragments;\n      (_fragments = fragments).push.apply(_fragments, getFragments(fontStore, child, attributes.link, level + 1));\n    }\n  }\n  for (var _i = 0; _i < PREPROCESSORS.length; _i += 1) {\n    var preprocessor = PREPROCESSORS[_i];\n    fragments = preprocessor(fragments);\n  }\n  return fragments;\n};\n\n/**\n * Get textkit attributed string from text node\n *\n * @param {Object} font store\n * @param {Object} instance node\n * @returns {Object} attributed string\n */\nvar getAttributedString = function getAttributedString(fontStore, instance) {\n  var fragments = getFragments(fontStore, instance);\n  return fromFragments(fragments);\n};\nvar engines = {\n  linebreaker: linebreaker,\n  justification: justification,\n  textDecoration: textDecoration,\n  scriptItemizer: scriptItemizer,\n  wordHyphenation: wordHyphenation,\n  fontSubstitution: fontSubstitution\n};\nvar engine = layoutEngine(engines);\nvar getMaxLines = function getMaxLines(node) {\n  var _node$style;\n  return (_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.maxLines;\n};\nvar getTextOverflow = function getTextOverflow(node) {\n  var _node$style2;\n  return (_node$style2 = node.style) === null || _node$style2 === void 0 ? void 0 : _node$style2.textOverflow;\n};\n\n/**\n * Get layout container for specific text node\n *\n * @param {Number} width\n * @param {Number} height\n * @param {Object} node\n * @returns {Object} layout container\n */\nvar getContainer = function getContainer(width, height, node) {\n  var maxLines = getMaxLines(node);\n  var textOverflow = getTextOverflow(node);\n  return {\n    x: 0,\n    y: 0,\n    width: width,\n    maxLines: maxLines,\n    height: height || Infinity,\n    truncateMode: textOverflow\n  };\n};\n\n/**\n * Get text layout options for specific text node\n *\n * @param {Object} node instance\n * @returns {Object} layout options\n */\nvar getLayoutOptions = function getLayoutOptions(fontStore, node) {\n  return {\n    hyphenationPenalty: node.props.hyphenationPenalty,\n    shrinkWhitespaceFactor: {\n      before: -0.5,\n      after: -0.5\n    },\n    hyphenationCallback: node.props.hyphenationCallback || (fontStore === null || fontStore === void 0 ? void 0 : fontStore.getHyphenationCallback()) || null\n  };\n};\n\n/**\n * Get text lines for given node\n *\n * @param {Object} node\n * @param {Number} container width\n * @param {Number} container height\n * @param {Number} fontStore font store\n * @returns {Array} layout lines\n */\nvar layoutText = function layoutText(node, width, height, fontStore) {\n  var attributedString = getAttributedString(fontStore, node);\n  var container = getContainer(width, height, node);\n  var options = getLayoutOptions(fontStore, node);\n  var lines = engine(attributedString, container, options);\n  return lines.reduce(function (acc, line) {\n    return [].concat(acc, line);\n  }, []);\n};\nvar isType$2 = function isType(type) {\n  return function (node) {\n    return node.type === type;\n  };\n};\nvar isSvg$2 = isType$2(P.Svg);\nvar isText$3 = isType$2(P.Text);\nvar shouldIterate = function shouldIterate(node) {\n  return !isSvg$2(node) && !isText$3(node);\n};\nvar shouldLayoutText = function shouldLayoutText(node) {\n  return isText$3(node) && !node.lines;\n};\n\n/**\n * Performs text layout on text node if wasn't calculated before.\n * Text layout is usually performed on Yoga's layout process (via setMeasureFunc),\n * but we need to layout those nodes with fixed width and height.\n *\n * @param {Object} node\n * @returns {Object} layout node\n */\nvar resolveTextLayout = function resolveTextLayout(node, fontStore) {\n  if (shouldLayoutText(node)) {\n    var width = node.box.width - (node.box.paddingRight + node.box.paddingLeft);\n    var height = node.box.height - (node.box.paddingTop + node.box.paddingBottom);\n\n    // eslint-disable-next-line no-param-reassign\n    node.lines = layoutText(node, width, height, fontStore);\n  }\n  if (shouldIterate(node)) {\n    if (!node.children) return node;\n    var mapChild = function mapChild(child) {\n      return resolveTextLayout(child, fontStore);\n    };\n    var children = node.children.map(mapChild);\n    return Object.assign({}, node, {\n      children: children\n    });\n  }\n  return node;\n};\nvar INHERITED_PROPERTIES = ['color', 'fontFamily', 'fontSize', 'fontStyle', 'fontWeight', 'letterSpacing', 'opacity', 'textDecoration', 'textTransform', 'lineHeight', 'textAlign', 'visibility', 'wordSpacing'];\nvar isSvg$1 = function isSvg(node) {\n  return node.type === P.Svg;\n};\n\n// Merge style values\nvar mergeValues = function mergeValues(styleName, value, inheritedValue) {\n  switch (styleName) {\n    case 'textDecoration':\n      {\n        // merge not none and not false textDecoration values to one rule\n        return [inheritedValue, value].filter(function (v) {\n          return v && v !== 'none';\n        }).join(' ');\n      }\n    default:\n      return value;\n  }\n};\n\n// Merge inherited and node styles\nvar merge = function merge(inheritedStyles, style) {\n  var mergedStyles = _extends({}, inheritedStyles);\n  Object.entries(style).forEach(function (_ref) {\n    var styleName = _ref[0],\n      value = _ref[1];\n    mergedStyles[styleName] = mergeValues(styleName, value, inheritedStyles[styleName]);\n  });\n  return mergedStyles;\n};\n\n/**\n * Merges styles with node\n *\n * @param {Object} style object\n * @param {Object} node\n * @returns {Object} node with styles merged\n */\nvar mergeStyles = function mergeStyles(inheritedStyles) {\n  return function (node) {\n    var style = merge(inheritedStyles, node.style || {});\n    return Object.assign({}, node, {\n      style: style\n    });\n  };\n};\n\n/**\n * Inherit style values from the root to the leafs\n *\n * @param {Object} document root\n * @returns {Object} document root with inheritance\n *\n */\nvar resolveInheritance = function resolveInheritance(node) {\n  if (isSvg$1(node)) return node;\n  if (!node.children) return node;\n  var inheritStyles = pick(INHERITED_PROPERTIES, node.style || {});\n  var resolveChild = compose(resolveInheritance, mergeStyles(inheritStyles));\n  var children = node.children.map(resolveChild);\n  return Object.assign({}, node, {\n    children: children\n  });\n};\nvar getComputedMargin = function getComputedMargin(node, edge) {\n  var yogaNode = node.yogaNode;\n  return yogaNode ? yogaNode.getComputedMargin(edge) : null;\n};\n\n/**\n * Get Yoga computed magins. Zero otherwise\n *\n * @param {Object} node\n * @return {Object} margins\n */\nvar getMargin = function getMargin(node) {\n  var style = node.style,\n    box = node.box;\n  var marginTop = getComputedMargin(node, Yoga.EDGE_TOP) || (box === null || box === void 0 ? void 0 : box.marginTop) || (style === null || style === void 0 ? void 0 : style.marginTop) || (style === null || style === void 0 ? void 0 : style.marginVertical) || (style === null || style === void 0 ? void 0 : style.margin) || 0;\n  var marginRight = getComputedMargin(node, Yoga.EDGE_RIGHT) || (box === null || box === void 0 ? void 0 : box.marginRight) || (style === null || style === void 0 ? void 0 : style.marginRight) || (style === null || style === void 0 ? void 0 : style.marginHorizontal) || (style === null || style === void 0 ? void 0 : style.margin) || 0;\n  var marginBottom = getComputedMargin(node, Yoga.EDGE_BOTTOM) || (box === null || box === void 0 ? void 0 : box.marginBottom) || (style === null || style === void 0 ? void 0 : style.marginBottom) || (style === null || style === void 0 ? void 0 : style.marginVertical) || (style === null || style === void 0 ? void 0 : style.margin) || 0;\n  var marginLeft = getComputedMargin(node, Yoga.EDGE_LEFT) || (box === null || box === void 0 ? void 0 : box.marginLeft) || (style === null || style === void 0 ? void 0 : style.marginLeft) || (style === null || style === void 0 ? void 0 : style.marginHorizontal) || (style === null || style === void 0 ? void 0 : style.margin) || 0;\n  return {\n    marginTop: marginTop,\n    marginRight: marginRight,\n    marginBottom: marginBottom,\n    marginLeft: marginLeft\n  };\n};\n\n/**\n * Get Yoga computed position. Zero otherwise\n *\n * @param {Object} node\n * @return {Object} position\n */\nvar getPosition = function getPosition(node) {\n  var yogaNode = node.yogaNode;\n  return {\n    top: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedTop()) || 0,\n    right: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedRight()) || 0,\n    bottom: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedBottom()) || 0,\n    left: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedLeft()) || 0\n  };\n};\nvar DEFAULT_DIMENSION = {\n  width: 0,\n  height: 0\n};\n\n/**\n * Get Yoga computed dimensions. Zero otherwise\n *\n * @param {Object} node\n * @return {Object} dimensions\n */\nvar getDimension = function getDimension(node) {\n  var yogaNode = node.yogaNode;\n  if (!yogaNode) return DEFAULT_DIMENSION;\n  return {\n    width: yogaNode.getComputedWidth(),\n    height: yogaNode.getComputedHeight()\n  };\n};\nvar getComputedBorder = function getComputedBorder(yogaNode, edge) {\n  return yogaNode ? yogaNode.getComputedBorder(edge) : 0;\n};\n\n/**\n * Get Yoga computed border width. Zero otherwise\n *\n * @param {Object} node\n * @return {Object} border widths\n */\nvar getBorderWidth = function getBorderWidth(node) {\n  var yogaNode = node.yogaNode;\n  return {\n    borderTopWidth: getComputedBorder(yogaNode, Yoga.EDGE_TOP),\n    borderRightWidth: getComputedBorder(yogaNode, Yoga.EDGE_RIGHT),\n    borderBottomWidth: getComputedBorder(yogaNode, Yoga.EDGE_BOTTOM),\n    borderLeftWidth: getComputedBorder(yogaNode, Yoga.EDGE_LEFT)\n  };\n};\n\n/**\n * Set display attribute to node's Yoga instance\n *\n * @param {String} display\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setDisplay = function setDisplay(value) {\n  return function (node) {\n    var yogaNode = node.yogaNode;\n    if (yogaNode) {\n      yogaNode.setDisplay(value === 'none' ? Yoga.DISPLAY_NONE : Yoga.DISPLAY_FLEX);\n    }\n    return node;\n  };\n};\nvar OVERFLOW = {\n  hidden: Yoga.OVERFLOW_HIDDEN,\n  scroll: Yoga.OVERFLOW_SCROLL\n};\n\n/**\n * Set overflow attribute to node's Yoga instance\n *\n * @param {String} overflow value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setOverflow = function setOverflow(value) {\n  return function (node) {\n    var yogaNode = node.yogaNode;\n    if (!isNil(value) && yogaNode) {\n      var overflow = OVERFLOW[value] || Yoga.OVERFLOW_VISIBLE;\n      yogaNode.setOverflow(overflow);\n    }\n    return node;\n  };\n};\nvar FLEX_WRAP = {\n  wrap: Yoga.WRAP_WRAP,\n  'wrap-reverse': Yoga.WRAP_WRAP_REVERSE\n};\n\n/**\n * Set flex wrap attribute to node's Yoga instance\n *\n * @param {String} flex wrap value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setFlexWrap = function setFlexWrap(value) {\n  return function (node) {\n    var yogaNode = node.yogaNode;\n    if (yogaNode) {\n      var flexWrap = FLEX_WRAP[value] || Yoga.WRAP_NO_WRAP;\n      yogaNode.setFlexWrap(flexWrap);\n    }\n    return node;\n  };\n};\n\n/* eslint-disable no-unused-expressions */\n\n/**\n * Set generic yoga attribute to node's Yoga instance, handing `auto`, edges and percentage cases\n *\n * @param {String} property\n * @param {Number} edge\n * @param {any} value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setYogaValue = function setYogaValue(attr, edge) {\n  return function (value) {\n    return function (node) {\n      var yogaNode = node.yogaNode;\n      if (!isNil(value) && yogaNode) {\n        var hasEdge = !isNil(edge);\n        var fixedMethod = \"set\" + upperFirst(attr);\n        var autoMethod = fixedMethod + \"Auto\";\n        var percentMethod = fixedMethod + \"Percent\";\n        var percent = matchPercent(value);\n        if (percent && !yogaNode[percentMethod]) {\n          throw new Error(\"You can't pass percentage values to \" + attr + \" property\");\n        }\n        if (percent) {\n          if (hasEdge) {\n            var _yogaNode$percentMeth;\n            (_yogaNode$percentMeth = yogaNode[percentMethod]) === null || _yogaNode$percentMeth === void 0 ? void 0 : _yogaNode$percentMeth.call(yogaNode, edge, percent.value);\n          } else {\n            var _yogaNode$percentMeth2;\n            (_yogaNode$percentMeth2 = yogaNode[percentMethod]) === null || _yogaNode$percentMeth2 === void 0 ? void 0 : _yogaNode$percentMeth2.call(yogaNode, percent.value);\n          }\n        } else if (value === 'auto') {\n          if (hasEdge) {\n            var _yogaNode$autoMethod;\n            (_yogaNode$autoMethod = yogaNode[autoMethod]) === null || _yogaNode$autoMethod === void 0 ? void 0 : _yogaNode$autoMethod.call(yogaNode, edge);\n          } else {\n            var _yogaNode$autoMethod2;\n            (_yogaNode$autoMethod2 = yogaNode[autoMethod]) === null || _yogaNode$autoMethod2 === void 0 ? void 0 : _yogaNode$autoMethod2.call(yogaNode);\n          }\n        } else if (hasEdge) {\n          var _yogaNode$fixedMethod;\n          (_yogaNode$fixedMethod = yogaNode[fixedMethod]) === null || _yogaNode$fixedMethod === void 0 ? void 0 : _yogaNode$fixedMethod.call(yogaNode, edge, value);\n        } else {\n          var _yogaNode$fixedMethod2;\n          (_yogaNode$fixedMethod2 = yogaNode[fixedMethod]) === null || _yogaNode$fixedMethod2 === void 0 ? void 0 : _yogaNode$fixedMethod2.call(yogaNode, value);\n        }\n      }\n      return node;\n    };\n  };\n};\n\n/**\n * Set flex grow attribute to node's Yoga instance\n *\n * @param {Number} flex grow value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setFlexGrow = function setFlexGrow(value) {\n  return function (node) {\n    return setYogaValue('flexGrow')(value || 0)(node);\n  };\n};\n\n/**\n * Set flex basis attribute to node's Yoga instance\n *\n * @param {Number} flex basis value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setFlexBasis = setYogaValue('flexBasis');\nvar ALIGN = {\n  'flex-start': Yoga.ALIGN_FLEX_START,\n  center: Yoga.ALIGN_CENTER,\n  'flex-end': Yoga.ALIGN_FLEX_END,\n  stretch: Yoga.ALIGN_STRETCH,\n  baseline: Yoga.ALIGN_BASELINE,\n  'space-between': Yoga.ALIGN_SPACE_BETWEEN,\n  'space-around': Yoga.ALIGN_SPACE_AROUND\n};\n\n/**\n * Set generic align attribute to node's Yoga instance\n *\n * @param {String} specific align property\n * @param {String} align value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setAlign = function setAlign(attr) {\n  return function (value) {\n    return function (node) {\n      var yogaNode = node.yogaNode;\n      var defaultValue = attr === 'items' ? Yoga.ALIGN_STRETCH : Yoga.ALIGN_AUTO;\n      if (yogaNode) {\n        var align = ALIGN[value] || defaultValue;\n        yogaNode[\"setAlign\" + upperFirst(attr)](align);\n      }\n      return node;\n    };\n  };\n};\n\n/**\n * Set align self attribute to node's Yoga instance\n *\n * @param {String} align value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setAlignSelf = setAlign('self');\n\n/**\n * Set align items attribute to node's Yoga instance\n *\n * @param {String} align value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setAlignItems = setAlign('items');\n\n/**\n * Set flex shrink attribute to node's Yoga instance\n *\n * @param {Number} flex shrink value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setFlexShrink = function setFlexShrink(value) {\n  return function (node) {\n    return setYogaValue('flexShrink')(value || 1)(node);\n  };\n};\n\n/**\n * Set aspect ratio attribute to node's Yoga instance\n *\n * @param {Number} ratio\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setAspectRatio = function setAspectRatio(value) {\n  return function (node) {\n    var yogaNode = node.yogaNode;\n    if (!isNil(value) && yogaNode) {\n      yogaNode.setAspectRatio(value);\n    }\n    return node;\n  };\n};\n\n/**\n * Set align content attribute to node's Yoga instance\n *\n * @param {String} align value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setAlignContent = setAlign('content');\n\n/**\n * Set position type attribute to node's Yoga instance\n *\n * @param {String} position type\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setPositionType = function setPositionType(value) {\n  return function (node) {\n    var yogaNode = node.yogaNode;\n    if (!isNil(value) && yogaNode) {\n      yogaNode.setPositionType(value === 'absolute' ? Yoga.POSITION_TYPE_ABSOLUTE : Yoga.POSITION_TYPE_RELATIVE);\n    }\n    return node;\n  };\n};\nvar FLEX_DIRECTIONS = {\n  row: Yoga.FLEX_DIRECTION_ROW,\n  'row-reverse': Yoga.FLEX_DIRECTION_ROW_REVERSE,\n  'column-reverse': Yoga.FLEX_DIRECTION_COLUMN_REVERSE\n};\n\n/**\n * Set flex direction attribute to node's Yoga instance\n *\n * @param {String} flex direction value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setFlexDirection = function setFlexDirection(value) {\n  return function (node) {\n    var yogaNode = node.yogaNode;\n    if (yogaNode) {\n      var flexDirection = FLEX_DIRECTIONS[value] || Yoga.FLEX_DIRECTION_COLUMN;\n      yogaNode.setFlexDirection(flexDirection);\n    }\n    return node;\n  };\n};\nvar JUSTIFY_CONTENT = {\n  center: Yoga.JUSTIFY_CENTER,\n  'flex-end': Yoga.JUSTIFY_FLEX_END,\n  'space-between': Yoga.JUSTIFY_SPACE_BETWEEN,\n  'space-around': Yoga.JUSTIFY_SPACE_AROUND,\n  'space-evenly': Yoga.JUSTIFY_SPACE_EVENLY\n};\n\n/**\n * Set justify content attribute to node's Yoga instance\n *\n * @param {String} justify content value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setJustifyContent = function setJustifyContent(value) {\n  return function (node) {\n    var yogaNode = node.yogaNode;\n    if (!isNil(value) && yogaNode) {\n      var justifyContent = JUSTIFY_CONTENT[value] || Yoga.JUSTIFY_FLEX_START;\n      yogaNode.setJustifyContent(justifyContent);\n    }\n    return node;\n  };\n};\n\n/**\n * Set margin top attribute to node's Yoga instance\n *\n * @param {Number} margin top\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setMarginTop = setYogaValue('margin', Yoga.EDGE_TOP);\n\n/**\n * Set margin right attribute to node's Yoga instance\n *\n * @param {Number} margin right\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setMarginRight = setYogaValue('margin', Yoga.EDGE_RIGHT);\n\n/**\n * Set margin bottom attribute to node's Yoga instance\n *\n * @param {Number} margin bottom\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setMarginBottom = setYogaValue('margin', Yoga.EDGE_BOTTOM);\n\n/**\n * Set margin left attribute to node's Yoga instance\n *\n * @param {Number} margin left\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setMarginLeft = setYogaValue('margin', Yoga.EDGE_LEFT);\n\n/**\n * Set padding top attribute to node's Yoga instance\n *\n * @param {Number} padding top\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setPaddingTop = setYogaValue('padding', Yoga.EDGE_TOP);\n\n/**\n * Set padding right attribute to node's Yoga instance\n *\n * @param {Number} padding right\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setPaddingRight = setYogaValue('padding', Yoga.EDGE_RIGHT);\n\n/**\n * Set padding bottom attribute to node's Yoga instance\n *\n * @param {Number} padding bottom\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setPaddingBottom = setYogaValue('padding', Yoga.EDGE_BOTTOM);\n\n/**\n * Set padding left attribute to node's Yoga instance\n *\n * @param {Number} padding left\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setPaddingLeft = setYogaValue('padding', Yoga.EDGE_LEFT);\n\n/**\n * Set border top attribute to node's Yoga instance\n *\n * @param {Number} border top width\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setBorderTop = setYogaValue('border', Yoga.EDGE_TOP);\n\n/**\n * Set border right attribute to node's Yoga instance\n *\n * @param {Number} border right width\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setBorderRight = setYogaValue('border', Yoga.EDGE_RIGHT);\n\n/**\n * Set border bottom attribute to node's Yoga instance\n *\n * @param {Number} border bottom width\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setBorderBottom = setYogaValue('border', Yoga.EDGE_BOTTOM);\n\n/**\n * Set border left attribute to node's Yoga instance\n *\n * @param {Number} border left width\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setBorderLeft = setYogaValue('border', Yoga.EDGE_LEFT);\n\n/**\n * Set position top attribute to node's Yoga instance\n *\n * @param {Number} position top\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setPositionTop = setYogaValue('position', Yoga.EDGE_TOP);\n\n/**\n * Set position right attribute to node's Yoga instance\n *\n * @param {Number} position right\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setPositionRight = setYogaValue('position', Yoga.EDGE_RIGHT);\n\n/**\n * Set position bottom attribute to node's Yoga instance\n *\n * @param {Number} position bottom\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setPositionBottom = setYogaValue('position', Yoga.EDGE_BOTTOM);\n\n/**\n * Set position left attribute to node's Yoga instance\n *\n * @param {Number} position left\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setPositionLeft = setYogaValue('position', Yoga.EDGE_LEFT);\n\n/**\n * Set width to node's Yoga instance\n *\n * @param {Number} width\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setWidth = setYogaValue('width');\n\n/**\n * Set min width to node's Yoga instance\n *\n * @param {Number} min width\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setMinWidth = setYogaValue('minWidth');\n\n/**\n * Set max width to node's Yoga instance\n *\n * @param {Number} max width\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setMaxWidth = setYogaValue('maxWidth');\n\n/**\n * Set height to node's Yoga instance\n *\n * @param {Number} height\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setHeight = setYogaValue('height');\n\n/**\n * Set min height to node's Yoga instance\n *\n * @param {Number} min height\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setMinHeight = setYogaValue('minHeight');\n\n/**\n * Set max height to node's Yoga instance\n *\n * @param {Number} max height\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setMaxHeight = setYogaValue('maxHeight');\nvar checkPercents = function checkPercents(attr, value) {\n  var percent = matchPercent(value);\n  if (percent) {\n    throw new Error(\"You can't pass percentage values to \" + attr + \" property\");\n  }\n};\n\n/**\n * Set rowGap value to node's Yoga instance\n *\n * @param {Number} gap value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setRowGap = function setRowGap(value) {\n  return function (node) {\n    var yogaNode = node.yogaNode;\n    if (!isNil(value) && yogaNode) {\n      checkPercents('rowGap', value);\n      yogaNode.setGap(Yoga.GUTTER_ROW, value);\n    }\n    return node;\n  };\n};\n\n/**\n * Set columnGap value to node's Yoga instance\n *\n * @param {Number} gap value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nvar setColumnGap = function setColumnGap(value) {\n  return function (node) {\n    var yogaNode = node.yogaNode;\n    if (!isNil(value) && yogaNode) {\n      checkPercents('columnGap', value);\n      yogaNode.setGap(Yoga.GUTTER_COLUMN, value);\n    }\n    return node;\n  };\n};\nvar getAspectRatio = function getAspectRatio(viewbox) {\n  if (!viewbox) return null;\n  return (viewbox.maxX - viewbox.minX) / (viewbox.maxY - viewbox.minY);\n};\n\n/**\n * Yoga svg measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @param {Number} width\n * @param {Number} widthMode\n * @param {Number} height\n * @param {Number} heightMode\n * @returns {Object} canvas width and height\n */\nvar measureCanvas$1 = function measureCanvas(page, node) {\n  return function (width, widthMode, height, heightMode) {\n    var aspectRatio = getAspectRatio(node.props.viewBox) || 1;\n    if (widthMode === Yoga.MEASURE_MODE_EXACTLY || widthMode === Yoga.MEASURE_MODE_AT_MOST) {\n      return {\n        width: width,\n        height: width / aspectRatio\n      };\n    }\n    if (heightMode === Yoga.MEASURE_MODE_EXACTLY) {\n      return {\n        width: height * aspectRatio\n      };\n    }\n    return {};\n  };\n};\n\n/**\n * Get lines width (if any)\n *\n * @param {Object} node\n * @returns {Number} lines width\n */\nvar linesWidth = function linesWidth(node) {\n  if (!node.lines) return 0;\n  return Math.max.apply(Math, [0].concat(node.lines.map(function (line) {\n    return line.xAdvance;\n  })));\n};\n\n/**\n * Get lines height (if any)\n *\n * @param {Object} node\n * @returns {Number} lines height\n */\nvar linesHeight = function linesHeight(node) {\n  if (!node.lines) return -1;\n  return node.lines.reduce(function (acc, line) {\n    return acc + line.box.height;\n  }, 0);\n};\n\n/* eslint-disable no-param-reassign */\nvar ALIGNMENT_FACTORS = {\n  center: 0.5,\n  right: 1\n};\n\n/**\n * Yoga text measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @param {Number} width\n * @param {Number} widthMode\n * @param {Number} height\n * @param {Number} heightMode\n * @returns {Object} text width and height\n */\nvar measureText = function measureText(page, node, fontStore) {\n  return function (width, widthMode, height) {\n    if (widthMode === Yoga.MEASURE_MODE_EXACTLY) {\n      if (!node.lines) node.lines = layoutText(node, width, height, fontStore);\n      return {\n        height: linesHeight(node)\n      };\n    }\n    if (widthMode === Yoga.MEASURE_MODE_AT_MOST) {\n      var _node$style;\n      var alignFactor = ALIGNMENT_FACTORS[(_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.textAlign] || 0;\n      if (!node.lines) {\n        node.lines = layoutText(node, width, height, fontStore);\n        node.alignOffset = (width - linesWidth(node)) * alignFactor; // Compensate align in variable width containers\n      }\n\n      return {\n        height: linesHeight(node),\n        width: Math.min(width, linesWidth(node))\n      };\n    }\n    return {};\n  };\n};\n\n/**\n * Get image ratio\n *\n * @param {Object} image node\n * @returns {Number} image ratio\n */\nvar getRatio = function getRatio(node) {\n  var _node$image;\n  return (_node$image = node.image) !== null && _node$image !== void 0 && _node$image.data ? node.image.width / node.image.height : 1;\n};\n\n/**\n * Checks if page has auto height\n *\n * @param {Object} page\n * @returns {Boolean} is page height auto\n */\nvar isHeightAuto = function isHeightAuto(page) {\n  var _page$box;\n  return isNil((_page$box = page.box) === null || _page$box === void 0 ? void 0 : _page$box.height);\n};\nvar SAFETY_HEIGHT$1 = 10;\n\n/**\n * Yoga image measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @param {Number} width\n * @param {Number} widthMode\n * @param {Number} height\n * @param {Number} heightMode\n * @returns {Object} image width and height\n */\nvar measureImage = function measureImage(page, node) {\n  return function (width, widthMode, height, heightMode) {\n    var imageRatio = getRatio(node);\n    var imageMargin = getMargin(node);\n    var pagePadding = getPadding(page);\n    var pageArea = isHeightAuto(page) ? Infinity : page.box.height - pagePadding.paddingTop - pagePadding.paddingBottom - imageMargin.marginTop - imageMargin.marginBottom - SAFETY_HEIGHT$1;\n\n    // Skip measure if image data not present yet\n    if (!node.image) return {\n      width: 0,\n      height: 0\n    };\n    if (widthMode === Yoga.MEASURE_MODE_EXACTLY && heightMode === Yoga.MEASURE_MODE_UNDEFINED) {\n      var scaledHeight = width / imageRatio;\n      return {\n        height: Math.min(pageArea, scaledHeight)\n      };\n    }\n    if (heightMode === Yoga.MEASURE_MODE_EXACTLY && (widthMode === Yoga.MEASURE_MODE_AT_MOST || widthMode === Yoga.MEASURE_MODE_UNDEFINED)) {\n      return {\n        width: Math.min(height * imageRatio, width)\n      };\n    }\n    if (widthMode === Yoga.MEASURE_MODE_EXACTLY && heightMode === Yoga.MEASURE_MODE_AT_MOST) {\n      var _scaledHeight = width / imageRatio;\n      return {\n        height: Math.min(height, pageArea, _scaledHeight)\n      };\n    }\n    if (widthMode === Yoga.MEASURE_MODE_AT_MOST && heightMode === Yoga.MEASURE_MODE_AT_MOST) {\n      if (imageRatio > 1) {\n        return {\n          width: width,\n          height: Math.min(width / imageRatio, height)\n        };\n      }\n      return {\n        height: height,\n        width: Math.min(height * imageRatio, width)\n      };\n    }\n    return {\n      height: height,\n      width: width\n    };\n  };\n};\n\n/* eslint-disable no-param-reassign */\nvar SAFETY_HEIGHT = 10;\nvar getMax = function getMax(values) {\n  return Math.max.apply(Math, [-Infinity].concat(values));\n};\n\n/**\n * Helper object to predict canvas size\n * TODO: Implement remaining functions (as close as possible);\n */\nvar measureCtx = function measureCtx() {\n  var ctx = {};\n  var points = [];\n  var nil = function nil() {\n    return ctx;\n  };\n  var addPoint = function addPoint(x, y) {\n    return points.push([x, y]);\n  };\n  var moveTo = function moveTo() {\n    addPoint.apply(void 0, arguments);\n    return ctx;\n  };\n  var rect = function rect(x, y, w, h) {\n    addPoint(x, y);\n    addPoint(x + w, y);\n    addPoint(x, y + h);\n    addPoint(x + w, y + h);\n    return ctx;\n  };\n  var ellipse = function ellipse(x, y, rx, ry) {\n    ry = ry || rx;\n    addPoint(x - rx, y - ry);\n    addPoint(x + rx, y - ry);\n    addPoint(x + rx, y + ry);\n    addPoint(x - rx, y + ry);\n    return ctx;\n  };\n  var polygon = function polygon() {\n    points.push.apply(points, arguments);\n    return ctx;\n  };\n\n  // Change dimensions\n  ctx.rect = rect;\n  ctx.moveTo = moveTo;\n  ctx.lineTo = moveTo;\n  ctx.circle = ellipse;\n  ctx.polygon = polygon;\n  ctx.ellipse = ellipse;\n  ctx.roundedRect = rect;\n\n  // To be implemented\n  ctx.text = nil;\n  ctx.path = nil;\n  ctx.lineWidth = nil;\n  ctx.bezierCurveTo = nil;\n  ctx.quadraticCurveTo = nil;\n  ctx.scale = nil;\n  ctx.rotate = nil;\n  ctx.translate = nil;\n\n  // These don't change dimensions\n  ctx.dash = nil;\n  ctx.clip = nil;\n  ctx.save = nil;\n  ctx.fill = nil;\n  ctx.font = nil;\n  ctx.stroke = nil;\n  ctx.lineCap = nil;\n  ctx.opacity = nil;\n  ctx.restore = nil;\n  ctx.lineJoin = nil;\n  ctx.fontSize = nil;\n  ctx.fillColor = nil;\n  ctx.miterLimit = nil;\n  ctx.strokeColor = nil;\n  ctx.fillOpacity = nil;\n  ctx.strokeOpacity = nil;\n  ctx.linearGradient = nil;\n  ctx.radialGradient = nil;\n  ctx.getWidth = function () {\n    return getMax(points.map(function (p) {\n      return p[0];\n    }));\n  };\n  ctx.getHeight = function () {\n    return getMax(points.map(function (p) {\n      return p[1];\n    }));\n  };\n  return ctx;\n};\n\n/**\n * Yoga canvas measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @param {Number} width\n * @param {Number} widthMode\n * @param {Number} height\n * @param {Number} heightMode\n * @returns {Object} canvas width and height\n */\nvar measureCanvas = function measureCanvas(page, node) {\n  return function () {\n    var imageMargin = getMargin(node);\n    var pagePadding = getPadding(page);\n    var pageArea = isHeightAuto(page) ? Infinity : page.box.height - pagePadding.paddingTop - pagePadding.paddingBottom - imageMargin.marginTop - imageMargin.marginBottom - SAFETY_HEIGHT;\n    var ctx = measureCtx();\n    node.props.paint(ctx);\n    var width = ctx.getWidth();\n    var height = Math.min(pageArea, ctx.getHeight());\n    return {\n      height: height,\n      width: width\n    };\n  };\n};\nvar YOGA_CONFIG = Yoga.Config.create();\nYOGA_CONFIG.setPointScaleFactor(0);\nvar isType$1 = function isType(type) {\n  return function (node) {\n    return node.type === type;\n  };\n};\nvar isSvg = isType$1(P.Svg);\nvar isText$2 = isType$1(P.Text);\nvar isNote = isType$1(P.Note);\nvar isPage = isType$1(P.Page);\nvar isImage = isType$1(P.Image);\nvar isCanvas = isType$1(P.Canvas);\nvar isTextInstance$1 = isType$1(P.TextInstance);\nvar setNodeHeight = function setNodeHeight(node) {\n  var value = isPage(node) ? node.box.height : node.style.height;\n  return setHeight(value);\n};\n\n/**\n * Set styles valeus into yoga node before layout calculation\n *\n * @param {Object} node\n * @returns {Object} node\n */\nvar setYogaValues = function setYogaValues(node) {\n  compose(setNodeHeight(node), setWidth(node.style.width), setMinWidth(node.style.minWidth), setMaxWidth(node.style.maxWidth), setMinHeight(node.style.minHeight), setMaxHeight(node.style.maxHeight), setMarginTop(node.style.marginTop), setMarginRight(node.style.marginRight), setMarginBottom(node.style.marginBottom), setMarginLeft(node.style.marginLeft), setPaddingTop(node.style.paddingTop), setPaddingRight(node.style.paddingRight), setPaddingBottom(node.style.paddingBottom), setPaddingLeft(node.style.paddingLeft), setPositionType(node.style.position), setPositionTop(node.style.top), setPositionRight(node.style.right), setPositionBottom(node.style.bottom), setPositionLeft(node.style.left), setBorderTop(node.style.borderTopWidth), setBorderRight(node.style.borderRightWidth), setBorderBottom(node.style.borderBottomWidth), setBorderLeft(node.style.borderLeftWidth), setDisplay(node.style.display), setFlexDirection(node.style.flexDirection), setAlignSelf(node.style.alignSelf), setAlignContent(node.style.alignContent), setAlignItems(node.style.alignItems), setJustifyContent(node.style.justifyContent), setFlexWrap(node.style.flexWrap), setOverflow(node.style.overflow), setAspectRatio(node.style.aspectRatio), setFlexBasis(node.style.flexBasis), setFlexGrow(node.style.flexGrow), setFlexShrink(node.style.flexShrink), setRowGap(node.style.rowGap), setColumnGap(node.style.columnGap))(node);\n};\n\n/**\n * Inserts child into parent' yoga node\n *\n * @param {Object} parent\n * @param {Object} node\n * @param {Object} node\n */\nvar insertYogaNodes = function insertYogaNodes(parent) {\n  return function (child) {\n    parent.insertChild(child.yogaNode, parent.getChildCount());\n    return child;\n  };\n};\nvar setMeasureFunc = function setMeasureFunc(node, page, fontStore) {\n  var yogaNode = node.yogaNode;\n  if (isText$2(node)) {\n    yogaNode.setMeasureFunc(measureText(page, node, fontStore));\n  }\n  if (isImage(node)) {\n    yogaNode.setMeasureFunc(measureImage(page, node));\n  }\n  if (isCanvas(node)) {\n    yogaNode.setMeasureFunc(measureCanvas(page, node));\n  }\n  if (isSvg(node)) {\n    yogaNode.setMeasureFunc(measureCanvas$1(page, node));\n  }\n  return node;\n};\nvar isLayoutElement = function isLayoutElement(node) {\n  return !isText$2(node) && !isNote(node) && !isSvg(node);\n};\n\n/**\n * Creates and add yoga node to document tree\n * Handles measure function for text and image nodes\n *\n * @param {Object} node\n * @returns {Object} node with appended yoga node\n */\nvar createYogaNodes = function createYogaNodes(page, fontStore) {\n  return function (node) {\n    var yogaNode = Yoga.Node.createWithConfig(YOGA_CONFIG);\n    var result = Object.assign({}, node, {\n      yogaNode: yogaNode\n    });\n    setYogaValues(result);\n    if (isLayoutElement(node) && node.children) {\n      var resolveChild = compose(insertYogaNodes(yogaNode), createYogaNodes(page, fontStore));\n      result.children = node.children.map(resolveChild);\n    }\n    setMeasureFunc(result, page, fontStore);\n    return result;\n  };\n};\n\n/**\n * Performs yoga calculation\n *\n * @param {Object} node\n * @returns {Object} node\n */\nvar calculateLayout = function calculateLayout(page) {\n  page.yogaNode.calculateLayout();\n  return page;\n};\n\n/**\n * Saves Yoga layout result into 'box' attribute of node\n *\n * @param {Object} node\n * @returns {Object} node with box data\n */\nvar persistDimensions = function persistDimensions(node) {\n  if (isTextInstance$1(node)) return node;\n  var box = Object.assign(getPadding(node), getMargin(node), getBorderWidth(node), getPosition(node), getDimension(node));\n  var newNode = Object.assign({}, node, {\n    box: box\n  });\n  if (!node.children) return newNode;\n  var children = node.children.map(persistDimensions);\n  return Object.assign({}, newNode, {\n    children: children\n  });\n};\n\n/**\n * Removes yoga node from document tree\n *\n * @param {Object} node\n * @returns {Object} node without yoga node\n */\nvar destroyYogaNodes = function destroyYogaNodes(node) {\n  var newNode = Object.assign({}, node);\n  delete newNode.yogaNode;\n  if (!node.children) return newNode;\n  var children = node.children.map(destroyYogaNodes);\n  return Object.assign({}, newNode, {\n    children: children\n  });\n};\n\n/**\n * Free yoga node from document tree\n *\n * @param {Object} node\n * @returns {Object} node without yoga node\n */\nvar freeYogaNodes = function freeYogaNodes(node) {\n  if (node.yogaNode) node.yogaNode.freeRecursive();\n  return node;\n};\n\n/**\n * Calculates page object layout using Yoga.\n * Takes node values from 'box' and 'style' attributes, and persist them back into 'box'\n * Destroy yoga values at the end.\n *\n * @param {Object} page object\n * @returns {Object} page object with correct 'box' layout attributes\n */\nvar resolvePageDimensions = function resolvePageDimensions(page, fontStore) {\n  if (isNil(page)) return null;\n  return compose(destroyYogaNodes, freeYogaNodes, persistDimensions, calculateLayout, createYogaNodes(page, fontStore))(page);\n};\n\n/**\n * Calculates root object layout using Yoga.\n *\n * @param {Object} root object\n * @returns {Object} root object with correct 'box' layout attributes\n */\nvar resolveDimensions = function resolveDimensions(node, fontStore) {\n  if (!node.children) return node;\n  var resolveChild = function resolveChild(child) {\n    return resolvePageDimensions(child, fontStore);\n  };\n  var children = node.children.map(resolveChild);\n  return Object.assign({}, node, {\n    children: children\n  });\n};\nvar isText$1 = function isText(node) {\n  return node.type === P.Text;\n};\n\n// Prevent splitting elements by low decimal numbers\nvar SAFTY_THRESHOLD = 0.001;\nvar assingChildren = function assingChildren(children, node) {\n  return Object.assign({}, node, {\n    children: children\n  });\n};\nvar getTop = function getTop(node) {\n  var _node$box;\n  return ((_node$box = node.box) === null || _node$box === void 0 ? void 0 : _node$box.top) || 0;\n};\nvar allFixed = function allFixed(nodes) {\n  return nodes.every(isFixed);\n};\nvar isDynamic = function isDynamic(node) {\n  var _node$props;\n  return !isNil((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.render);\n};\nvar relayoutPage = compose(resolveTextLayout, resolveInheritance, resolvePageDimensions);\nvar warnUnavailableSpace = function warnUnavailableSpace(node) {\n  console.warn(\"Node of type \" + node.type + \" can't wrap between pages and it's bigger than available page height\");\n};\nvar splitNodes = function splitNodes(height, contentArea, nodes) {\n  var currentChildren = [];\n  var nextChildren = [];\n  for (var i = 0; i < nodes.length; i += 1) {\n    var child = nodes[i];\n    var futureNodes = nodes.slice(i + 1);\n    var futureFixedNodes = futureNodes.filter(isFixed);\n    var nodeTop = getTop(child);\n    var nodeHeight = child.box.height;\n    var isOutside = height <= nodeTop;\n    var shouldBreak$1 = shouldBreak(child, futureNodes, height);\n    var shouldSplit = height + SAFTY_THRESHOLD < nodeTop + nodeHeight;\n    var canWrap = getWrap(child);\n    var fitsInsidePage = nodeHeight <= contentArea;\n    if (isFixed(child)) {\n      nextChildren.push(child);\n      currentChildren.push(child);\n      continue;\n    }\n    if (isOutside) {\n      var box = Object.assign({}, child.box, {\n        top: child.box.top - height\n      });\n      var next = Object.assign({}, child, {\n        box: box\n      });\n      nextChildren.push(next);\n      continue;\n    }\n    if (!fitsInsidePage && !canWrap) {\n      currentChildren.push(child);\n      nextChildren.push.apply(nextChildren, futureNodes);\n      warnUnavailableSpace(child);\n      break;\n    }\n    if (shouldBreak$1) {\n      var _box = Object.assign({}, child.box, {\n        top: child.box.top - height\n      });\n      var props = Object.assign({}, child.props, {\n        wrap: true,\n        break: false\n      });\n      var _next = Object.assign({}, child, {\n        box: _box,\n        props: props\n      });\n      currentChildren.push.apply(currentChildren, futureFixedNodes);\n      nextChildren.push.apply(nextChildren, [_next].concat(futureNodes));\n      break;\n    }\n    if (shouldSplit) {\n      var _split = split(child, height, contentArea),\n        currentChild = _split[0],\n        nextChild = _split[1];\n\n      // All children are moved to the next page, it doesn't make sense to show the parent on the current page\n      if (child.children.length > 0 && currentChild.children.length === 0) {\n        var _box2 = Object.assign({}, child.box, {\n          top: child.box.top - height\n        });\n        var _next2 = Object.assign({}, child, {\n          box: _box2\n        });\n        currentChildren.push.apply(currentChildren, futureFixedNodes);\n        nextChildren.push.apply(nextChildren, [_next2].concat(futureNodes));\n        break;\n      }\n      if (currentChild) currentChildren.push(currentChild);\n      if (nextChild) nextChildren.push(nextChild);\n      continue;\n    }\n    currentChildren.push(child);\n  }\n  return [currentChildren, nextChildren];\n};\nvar splitChildren = function splitChildren(height, contentArea, node) {\n  var children = node.children || [];\n  var availableHeight = height - getTop(node);\n  return splitNodes(availableHeight, contentArea, children);\n};\nvar splitView = function splitView(node, height, contentArea) {\n  var _splitNode = splitNode(node, height),\n    currentNode = _splitNode[0],\n    nextNode = _splitNode[1];\n  var _splitChildren = splitChildren(height, contentArea, node),\n    currentChilds = _splitChildren[0],\n    nextChildren = _splitChildren[1];\n  return [assingChildren(currentChilds, currentNode), assingChildren(nextChildren, nextNode)];\n};\nvar split = function split(node, height, contentArea) {\n  return isText$1(node) ? splitText(node, height) : splitView(node, height, contentArea);\n};\nvar shouldResolveDynamicNodes = function shouldResolveDynamicNodes(node) {\n  var children = node.children || [];\n  return isDynamic(node) || children.some(shouldResolveDynamicNodes);\n};\nvar resolveDynamicNodes = function resolveDynamicNodes(props, node) {\n  var isNodeDynamic = isDynamic(node);\n\n  // Call render prop on dynamic nodes and append result to children\n  var resolveChildren = function resolveChildren(children) {\n    if (children === void 0) {\n      children = [];\n    }\n    if (isNodeDynamic) {\n      var res = node.props.render(props);\n      return createInstances(res).filter(Boolean).map(function (n) {\n        return resolveDynamicNodes(props, n);\n      });\n    }\n    return children.map(function (c) {\n      return resolveDynamicNodes(props, c);\n    });\n  };\n\n  // We reset dynamic text box so it can be computed again later on\n  var resetHeight = isNodeDynamic && isText$1(node);\n  var box = resetHeight ? _extends({}, node.box, {\n    height: 0\n  }) : node.box;\n  var children = resolveChildren(node.children);\n  var lines = isNodeDynamic ? null : node.lines;\n  return Object.assign({}, node, {\n    box: box,\n    lines: lines,\n    children: children\n  });\n};\nvar resolveDynamicPage = function resolveDynamicPage(props, page, fontStore) {\n  if (shouldResolveDynamicNodes(page)) {\n    var resolvedPage = resolveDynamicNodes(props, page);\n    return relayoutPage(resolvedPage, fontStore);\n  }\n  return page;\n};\nvar splitPage = function splitPage(page, pageNumber, fontStore) {\n  var wrapArea = getWrapArea(page);\n  var contentArea = getContentArea(page);\n  var dynamicPage = resolveDynamicPage({\n    pageNumber: pageNumber\n  }, page, fontStore);\n  var height = page.style.height;\n  var _splitNodes = splitNodes(wrapArea, contentArea, dynamicPage.children),\n    currentChilds = _splitNodes[0],\n    nextChilds = _splitNodes[1];\n  var relayout = function relayout(node) {\n    return relayoutPage(node, fontStore);\n  };\n  var currentBox = _extends({}, page.box, {\n    height: height\n  });\n  var currentPage = relayout(Object.assign({}, page, {\n    box: currentBox,\n    children: currentChilds\n  }));\n  if (nextChilds.length === 0 || allFixed(nextChilds)) return [currentPage, null];\n  var nextBox = omit('height', page.box);\n  var nextProps = omit('bookmark', page.props);\n  var nextPage = relayout(Object.assign({}, page, {\n    props: nextProps,\n    box: nextBox,\n    children: nextChilds\n  }));\n  return [currentPage, nextPage];\n};\nvar resolvePageIndices = function resolvePageIndices(fontStore, page, pageNumber, pages) {\n  var totalPages = pages.length;\n  var props = {\n    totalPages: totalPages,\n    pageNumber: pageNumber + 1,\n    subPageNumber: page.subPageNumber + 1,\n    subPageTotalPages: page.subPageTotalPages\n  };\n  return resolveDynamicPage(props, page, fontStore);\n};\nvar assocSubPageData = function assocSubPageData(subpages) {\n  return subpages.map(function (page, i) {\n    return _extends({}, page, {\n      subPageNumber: i,\n      subPageTotalPages: subpages.length\n    });\n  });\n};\nvar dissocSubPageData = function dissocSubPageData(page) {\n  return omit(['subPageNumber', 'subPageTotalPages'], page);\n};\nvar paginate = function paginate(page, pageNumber, fontStore) {\n  var _page$props;\n  if (!page) return [];\n  if (((_page$props = page.props) === null || _page$props === void 0 ? void 0 : _page$props.wrap) === false) return [page];\n  var splittedPage = splitPage(page, pageNumber, fontStore);\n  var pages = [splittedPage[0]];\n  var nextPage = splittedPage[1];\n  while (nextPage !== null) {\n    splittedPage = splitPage(nextPage, pageNumber + pages.length, fontStore);\n    pages.push(splittedPage[0]);\n    nextPage = splittedPage[1];\n  }\n  return pages;\n};\n\n/**\n * Performs pagination. This is the step responsible of breaking the whole document\n * into pages following pagiation rules, such as `fixed`, `break` and dynamic nodes.\n *\n * @param {Object} node\n * @param {Object} fontStore font store\n * @returns {Object} layout node\n */\nvar resolvePagination = function resolvePagination(doc, fontStore) {\n  var pages = [];\n  var pageNumber = 1;\n  for (var i = 0; i < doc.children.length; i += 1) {\n    var page = doc.children[i];\n    var subpages = paginate(page, pageNumber, fontStore);\n    subpages = assocSubPageData(subpages);\n    pageNumber += subpages.length;\n    pages = pages.concat(subpages);\n  }\n  pages = pages.map(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return dissocSubPageData(resolvePageIndices.apply(void 0, [fontStore].concat(args)));\n  });\n  return assingChildren(pages, doc);\n};\n\n/*\n * Translates page percentage horizontal paddings in fixed ones\n *\n * @param {Object} page container\n * @param {String} padding value\n * @returns {Object} translated padding value\n */\nvar resolvePageHorizontalPadding = function resolvePageHorizontalPadding(container) {\n  return function (value) {\n    var match = matchPercent(value);\n    return match ? match.percent * container.width : value;\n  };\n};\n\n/**\n * Translates page percentage vertical paddings in fixed ones\n *\n * @param {Object} page container\n * @param {String} padding value\n * @returns {Object} translated padding value\n */\nvar resolvePageVerticalPadding = function resolvePageVerticalPadding(container) {\n  return function (value) {\n    var match = matchPercent(value);\n    return match ? match.percent * container.height : value;\n  };\n};\n\n/**\n * Translates page percentage paddings in fixed ones\n *\n * @param {Object} page\n * @returns {Object} page with fixed paddings\n */\nvar resolvePagePaddings = function resolvePagePaddings(page) {\n  var container = page.style;\n  var style = evolve({\n    paddingTop: resolvePageVerticalPadding(container),\n    paddingLeft: resolvePageHorizontalPadding(container),\n    paddingRight: resolvePageHorizontalPadding(container),\n    paddingBottom: resolvePageVerticalPadding(container)\n  }, page.style);\n  return Object.assign({}, page, {\n    style: style\n  });\n};\n\n/**\n * Translates all pages percentage paddings in fixed ones\n * This has to be computed from pages calculated size and not by Yoga\n * because at this point we didn't performed pagination yet.\n *\n * @param {Object} document root\n * @returns {Object} document root with translated page paddings\n */\nvar resolvePagesPaddings = function resolvePagesPaddings(root) {\n  if (!root.children) return root;\n  var children = root.children.map(resolvePagePaddings);\n  return Object.assign({}, root, {\n    children: children\n  });\n};\n\n/**\n *\n * @param {Object} container width and height\n * @param {String | Number} value border radius value\n * @returns {Number} fixed border radius value\n */\nvar resolveRadius = function resolveRadius(container) {\n  return function (value) {\n    if (!value) return undefined;\n    var match = matchPercent(value);\n    return match ? match.percent * Math.min(container.width, container.height) : value;\n  };\n};\n\n/**\n * Transforms percent border radius into fixed values\n *\n * @param {Object} node\n * @returns {Object} node\n */\nvar resolvePercentRadius = function resolvePercentRadius(node) {\n  var style = evolve({\n    borderTopLeftRadius: resolveRadius(node.box),\n    borderTopRightRadius: resolveRadius(node.box),\n    borderBottomRightRadius: resolveRadius(node.box),\n    borderBottomLeftRadius: resolveRadius(node.box)\n  }, node.style || {});\n  var newNode = Object.assign({}, node, {\n    style: style\n  });\n  if (!node.children) return newNode;\n  var children = node.children.map(resolvePercentRadius);\n  return Object.assign({}, newNode, {\n    children: children\n  });\n};\n\n/**\n * Transform percent height into fixed\n *\n * @param {String | number} height\n * @return {number} height\n */\nvar transformHeight = function transformHeight(pageArea, height) {\n  var match = matchPercent(height);\n  return match ? match.percent * pageArea : height;\n};\n\n/**\n * Get page area (height minus paddings)\n *\n * @param {Object} page\n * @return {number} page area\n */\nvar getPageArea = function getPageArea(page) {\n  var _page$style, _page$style2;\n  var pageHeight = page.style.height;\n  var pagePaddingTop = ((_page$style = page.style) === null || _page$style === void 0 ? void 0 : _page$style.paddingTop) || 0;\n  var pagePaddingBottom = ((_page$style2 = page.style) === null || _page$style2 === void 0 ? void 0 : _page$style2.paddingBottom) || 0;\n  return pageHeight - pagePaddingTop - pagePaddingBottom;\n};\n\n/**\n * Transform node percent height to fixed\n *\n * @param {Object} page\n * @param {Object} node\n * @return {Object} transformed node\n */\nvar resolveNodePercentHeight = function resolveNodePercentHeight(page, node) {\n  var _page$style3, _node$style;\n  if (isNil((_page$style3 = page.style) === null || _page$style3 === void 0 ? void 0 : _page$style3.height)) return node;\n  if (isNil((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.height)) return node;\n  var pageArea = getPageArea(page);\n  var height = transformHeight(pageArea, node.style.height);\n  var style = Object.assign({}, node.style, {\n    height: height\n  });\n  return Object.assign({}, node, {\n    style: style\n  });\n};\n\n/**\n * Transform page immediate children with percent height to fixed\n *\n * @param {Object} page\n * @return {Object} transformed page\n */\nvar resolvePagePercentHeight = function resolvePagePercentHeight(page) {\n  if (!page.children) return page;\n  var resolveChild = function resolveChild(child) {\n    return resolveNodePercentHeight(page, child);\n  };\n  var children = page.children.map(resolveChild);\n  return Object.assign({}, page, {\n    children: children\n  });\n};\n\n/**\n * Transform all page immediate children with percent height to fixed.\n * This is needed for computing correct dimensions on pre-pagination layout.\n *\n * @param {Object} document root\n * @return {Object} transformed document root\n */\nvar resolvePercentHeight = function resolvePercentHeight(root) {\n  if (!root.children) return root;\n  var children = root.children.map(resolvePagePercentHeight);\n  return Object.assign({}, root, {\n    children: children\n  });\n};\nvar isType = function isType(type) {\n  return function (node) {\n    return node.type === type;\n  };\n};\nvar isLink = isType(P.Link);\nvar isText = isType(P.Text);\nvar isTextInstance = isType(P.TextInstance);\n\n/**\n * Checks if node has render prop\n *\n * @param {Object} node\n * @returns {Boolean} has render prop?\n */\nvar hasRenderProp = function hasRenderProp(node) {\n  var _node$props;\n  return !!((_node$props = node.props) !== null && _node$props !== void 0 && _node$props.render);\n};\n\n/**\n * Checks if node is text type (Text or TextInstance)\n *\n * @param {Object} node\n * @returns {Boolean} are all children text instances?\n */\nvar isTextType = function isTextType(node) {\n  return isText(node) || isTextInstance(node);\n};\n\n/**\n * Checks if is tet link that needs to be wrapped in Text\n *\n * @param {Object} node\n * @returns {Boolean} are all children text instances?\n */\nvar isTextLink = function isTextLink(node) {\n  var children = node.children || [];\n\n  // Text string inside a Link\n  if (children.every(isTextInstance)) return true;\n\n  // Text node inside a Link\n  if (children.every(isText)) return false;\n  return children.every(isTextType);\n};\n\n/**\n * Wraps node children inside Text node\n *\n * @param {Object} node\n * @returns {Boolean} node with intermediate Text child\n */\nvar wrapText = function wrapText(node) {\n  var textElement = {\n    type: P.Text,\n    props: {},\n    style: {},\n    box: {},\n    children: node.children\n  };\n  return Object.assign({}, node, {\n    children: [textElement]\n  });\n};\nvar transformLink = function transformLink(node) {\n  if (!isLink(node)) return node;\n\n  // If has render prop substitute the instance by a Text, that will\n  // ultimately render the inline Link via the textkit PDF renderer.\n  if (hasRenderProp(node)) return Object.assign({}, node, {\n    type: P.Text\n  });\n\n  // If is a text link (either contains Text or TextInstalce), wrap it\n  // inside a Text element so styles are applied correctly\n\n  if (isTextLink(node)) return wrapText(node);\n  return node;\n};\n\n/**\n * Transforms Link layout to correctly render text and dynamic rendered links\n *\n * @param {Object} node\n * @returns {Object} node with link substitution\n */\nvar resolveLinkSubstitution = function resolveLinkSubstitution(node) {\n  if (!node.children) return node;\n  var resolveChild = compose(transformLink, resolveLinkSubstitution);\n  var children = node.children.map(resolveChild);\n  return Object.assign({}, node, {\n    children: children\n  });\n};\nvar layout = asyncCompose(resolveZIndex, resolveOrigin, resolvePagination, resolveTextLayout, resolvePercentRadius, resolveDimensions, resolveSvg, resolveAssets, resolveInheritance, resolvePercentHeight, resolvePagesPaddings, resolveStyles, resolveLinkSubstitution, resolveBookmarks, resolvePageSizes);\nexport { layout as default };","map":null,"metadata":{},"sourceType":"module"}