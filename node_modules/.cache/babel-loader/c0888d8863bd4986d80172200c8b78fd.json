{"ast":null,"code":"function noop(value) {\n  return value;\n}\nfunction generateMultiplier(multiplier) {\n  if (multiplier.min === 0 && multiplier.max === 0) {\n    return '*';\n  }\n  if (multiplier.min === 0 && multiplier.max === 1) {\n    return '?';\n  }\n  if (multiplier.min === 1 && multiplier.max === 0) {\n    return multiplier.comma ? '#' : '+';\n  }\n  if (multiplier.min === 1 && multiplier.max === 1) {\n    return '';\n  }\n  return (multiplier.comma ? '#' : '') + (multiplier.min === multiplier.max ? '{' + multiplier.min + '}' : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}');\n}\nfunction generateTypeOpts(node) {\n  switch (node.type) {\n    case 'Range':\n      return ' [' + (node.min === null ? '-∞' : node.min) + ',' + (node.max === null ? '∞' : node.max) + ']';\n    default:\n      throw new Error('Unknown node type `' + node.type + '`');\n  }\n}\nfunction generateSequence(node, decorate, forceBraces, compact) {\n  var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';\n  var result = node.terms.map(function (term) {\n    return generate(term, decorate, forceBraces, compact);\n  }).join(combinator);\n  if (node.explicit || forceBraces) {\n    result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');\n  }\n  return result;\n}\nfunction generate(node, decorate, forceBraces, compact) {\n  var result;\n  switch (node.type) {\n    case 'Group':\n      result = generateSequence(node, decorate, forceBraces, compact) + (node.disallowEmpty ? '!' : '');\n      break;\n    case 'Multiplier':\n      // return since node is a composition\n      return generate(node.term, decorate, forceBraces, compact) + decorate(generateMultiplier(node), node);\n    case 'Type':\n      result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';\n      break;\n    case 'Property':\n      result = '<\\'' + node.name + '\\'>';\n      break;\n    case 'Keyword':\n      result = node.name;\n      break;\n    case 'AtKeyword':\n      result = '@' + node.name;\n      break;\n    case 'Function':\n      result = node.name + '(';\n      break;\n    case 'String':\n    case 'Token':\n      result = node.value;\n      break;\n    case 'Comma':\n      result = ',';\n      break;\n    default:\n      throw new Error('Unknown node type `' + node.type + '`');\n  }\n  return decorate(result, node);\n}\nmodule.exports = function (node, options) {\n  var decorate = noop;\n  var forceBraces = false;\n  var compact = false;\n  if (typeof options === 'function') {\n    decorate = options;\n  } else if (options) {\n    forceBraces = Boolean(options.forceBraces);\n    compact = Boolean(options.compact);\n    if (typeof options.decorate === 'function') {\n      decorate = options.decorate;\n    }\n  }\n  return generate(node, decorate, forceBraces, compact);\n};","map":null,"metadata":{},"sourceType":"script"}