{"ast":null,"code":"var hasOwnProperty = Object.prototype.hasOwnProperty;\nvar noop = function noop() {};\nfunction ensureFunction(value) {\n  return typeof value === 'function' ? value : noop;\n}\nfunction invokeForType(fn, type) {\n  return function (node, item, list) {\n    if (node.type === type) {\n      fn.call(this, node, item, list);\n    }\n  };\n}\nfunction getWalkersFromStructure(name, nodeType) {\n  var structure = nodeType.structure;\n  var walkers = [];\n  for (var key in structure) {\n    if (hasOwnProperty.call(structure, key) === false) {\n      continue;\n    }\n    var fieldTypes = structure[key];\n    var walker = {\n      name: key,\n      type: false,\n      nullable: false\n    };\n    if (!Array.isArray(structure[key])) {\n      fieldTypes = [structure[key]];\n    }\n    for (var i = 0; i < fieldTypes.length; i++) {\n      var fieldType = fieldTypes[i];\n      if (fieldType === null) {\n        walker.nullable = true;\n      } else if (typeof fieldType === 'string') {\n        walker.type = 'node';\n      } else if (Array.isArray(fieldType)) {\n        walker.type = 'list';\n      }\n    }\n    if (walker.type) {\n      walkers.push(walker);\n    }\n  }\n  if (walkers.length) {\n    return {\n      context: nodeType.walkContext,\n      fields: walkers\n    };\n  }\n  return null;\n}\nfunction getTypesFromConfig(config) {\n  var types = {};\n  for (var name in config.node) {\n    if (hasOwnProperty.call(config.node, name)) {\n      var nodeType = config.node[name];\n      if (!nodeType.structure) {\n        throw new Error('Missed `structure` field in `' + name + '` node type definition');\n      }\n      types[name] = getWalkersFromStructure(name, nodeType);\n    }\n  }\n  return types;\n}\nfunction createTypeIterator(config, reverse) {\n  var fields = config.fields.slice();\n  var contextName = config.context;\n  var useContext = typeof contextName === 'string';\n  if (reverse) {\n    fields.reverse();\n  }\n  return function (node, context, walk, walkReducer) {\n    var prevContextValue;\n    if (useContext) {\n      prevContextValue = context[contextName];\n      context[contextName] = node;\n    }\n    for (var i = 0; i < fields.length; i++) {\n      var field = fields[i];\n      var ref = node[field.name];\n      if (!field.nullable || ref) {\n        if (field.type === 'list') {\n          var breakWalk = reverse ? ref.reduceRight(walkReducer, false) : ref.reduce(walkReducer, false);\n          if (breakWalk) {\n            return true;\n          }\n        } else if (walk(ref)) {\n          return true;\n        }\n      }\n    }\n    if (useContext) {\n      context[contextName] = prevContextValue;\n    }\n  };\n}\nfunction createFastTraveralMap(iterators) {\n  return {\n    Atrule: {\n      StyleSheet: iterators.StyleSheet,\n      Atrule: iterators.Atrule,\n      Rule: iterators.Rule,\n      Block: iterators.Block\n    },\n    Rule: {\n      StyleSheet: iterators.StyleSheet,\n      Atrule: iterators.Atrule,\n      Rule: iterators.Rule,\n      Block: iterators.Block\n    },\n    Declaration: {\n      StyleSheet: iterators.StyleSheet,\n      Atrule: iterators.Atrule,\n      Rule: iterators.Rule,\n      Block: iterators.Block,\n      DeclarationList: iterators.DeclarationList\n    }\n  };\n}\nmodule.exports = function createWalker(config) {\n  var types = getTypesFromConfig(config);\n  var iteratorsNatural = {};\n  var iteratorsReverse = {};\n  var breakWalk = Symbol('break-walk');\n  var skipNode = Symbol('skip-node');\n  for (var name in types) {\n    if (hasOwnProperty.call(types, name) && types[name] !== null) {\n      iteratorsNatural[name] = createTypeIterator(types[name], false);\n      iteratorsReverse[name] = createTypeIterator(types[name], true);\n    }\n  }\n  var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);\n  var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);\n  var walk = function walk(root, options) {\n    function walkNode(node, item, list) {\n      var enterRet = enter.call(context, node, item, list);\n      if (enterRet === breakWalk) {\n        debugger;\n        return true;\n      }\n      if (enterRet === skipNode) {\n        return false;\n      }\n      if (iterators.hasOwnProperty(node.type)) {\n        if (iterators[node.type](node, context, walkNode, walkReducer)) {\n          return true;\n        }\n      }\n      if (leave.call(context, node, item, list) === breakWalk) {\n        return true;\n      }\n      return false;\n    }\n    var walkReducer = function walkReducer(ret, data, item, list) {\n      return ret || walkNode(data, item, list);\n    };\n    var enter = noop;\n    var leave = noop;\n    var iterators = iteratorsNatural;\n    var context = {\n      break: breakWalk,\n      skip: skipNode,\n      root: root,\n      stylesheet: null,\n      atrule: null,\n      atrulePrelude: null,\n      rule: null,\n      selector: null,\n      block: null,\n      declaration: null,\n      function: null\n    };\n    if (typeof options === 'function') {\n      enter = options;\n    } else if (options) {\n      enter = ensureFunction(options.enter);\n      leave = ensureFunction(options.leave);\n      if (options.reverse) {\n        iterators = iteratorsReverse;\n      }\n      if (options.visit) {\n        if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {\n          iterators = options.reverse ? fastTraversalIteratorsReverse[options.visit] : fastTraversalIteratorsNatural[options.visit];\n        } else if (!types.hasOwnProperty(options.visit)) {\n          throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');\n        }\n        enter = invokeForType(enter, options.visit);\n        leave = invokeForType(leave, options.visit);\n      }\n    }\n    if (enter === noop && leave === noop) {\n      throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\\'t a function');\n    }\n    walkNode(root);\n  };\n  walk.break = breakWalk;\n  walk.skip = skipNode;\n  walk.find = function (ast, fn) {\n    var found = null;\n    walk(ast, function (node, item, list) {\n      if (fn.call(this, node, item, list)) {\n        found = node;\n        return breakWalk;\n      }\n    });\n    return found;\n  };\n  walk.findLast = function (ast, fn) {\n    var found = null;\n    walk(ast, {\n      reverse: true,\n      enter: function enter(node, item, list) {\n        if (fn.call(this, node, item, list)) {\n          found = node;\n          return breakWalk;\n        }\n      }\n    });\n    return found;\n  };\n  walk.findAll = function (ast, fn) {\n    var found = [];\n    walk(ast, function (node, item, list) {\n      if (fn.call(this, node, item, list)) {\n        found.push(node);\n      }\n    });\n    return found;\n  };\n  return walk;\n};","map":null,"metadata":{},"sourceType":"script"}