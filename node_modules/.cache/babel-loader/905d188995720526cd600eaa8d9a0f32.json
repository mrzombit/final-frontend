{"ast":null,"code":"var _slicedToArray = require(\"/Users/koonk/Documents/GitHub/CE65-20/packages/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\nvar SyntaxReferenceError = require('./error').SyntaxReferenceError;\nvar SyntaxMatchError = require('./error').SyntaxMatchError;\nvar names = require('../utils/names');\nvar generic = require('./generic');\nvar parse = require('../definition-syntax/parse');\nvar generate = require('../definition-syntax/generate');\nvar walk = require('../definition-syntax/walk');\nvar prepareTokens = require('./prepare-tokens');\nvar buildMatchGraph = require('./match-graph').buildMatchGraph;\nvar matchAsTree = require('./match').matchAsTree;\nvar trace = require('./trace');\nvar search = require('./search');\nvar getStructureFromConfig = require('./structure').getStructureFromConfig;\nvar cssWideKeywords = buildMatchGraph('inherit | initial | unset');\nvar cssWideKeywordsWithExpression = buildMatchGraph('inherit | initial | unset | <-ms-legacy-expression>');\nfunction dumpMapSyntax(map, compact, syntaxAsAst) {\n  var result = {};\n  for (var name in map) {\n    if (map[name].syntax) {\n      result[name] = syntaxAsAst ? map[name].syntax : generate(map[name].syntax, {\n        compact: compact\n      });\n    }\n  }\n  return result;\n}\nfunction dumpAtruleMapSyntax(map, compact, syntaxAsAst) {\n  var result = {};\n  for (var _i = 0, _Object$entries = Object.entries(map); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n      name = _Object$entries$_i[0],\n      atrule = _Object$entries$_i[1];\n    result[name] = {\n      prelude: atrule.prelude && (syntaxAsAst ? atrule.prelude.syntax : generate(atrule.prelude.syntax, {\n        compact: compact\n      })),\n      descriptors: atrule.descriptors && dumpMapSyntax(atrule.descriptors, compact, syntaxAsAst)\n    };\n  }\n  return result;\n}\nfunction valueHasVar(tokens) {\n  for (var i = 0; i < tokens.length; i++) {\n    if (tokens[i].value.toLowerCase() === 'var(') {\n      return true;\n    }\n  }\n  return false;\n}\nfunction buildMatchResult(match, error, iterations) {\n  return {\n    matched: match,\n    iterations: iterations,\n    error: error,\n    getTrace: trace.getTrace,\n    isType: trace.isType,\n    isProperty: trace.isProperty,\n    isKeyword: trace.isKeyword\n  };\n}\nfunction matchSyntax(lexer, syntax, value, useCommon) {\n  var tokens = prepareTokens(value, lexer.syntax);\n  var result;\n  if (valueHasVar(tokens)) {\n    return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));\n  }\n  if (useCommon) {\n    result = matchAsTree(tokens, lexer.valueCommonSyntax, lexer);\n  }\n  if (!useCommon || !result.match) {\n    result = matchAsTree(tokens, syntax.match, lexer);\n    if (!result.match) {\n      return buildMatchResult(null, new SyntaxMatchError(result.reason, syntax.syntax, value, result), result.iterations);\n    }\n  }\n  return buildMatchResult(result.match, null, result.iterations);\n}\nvar Lexer = function Lexer(config, syntax, structure) {\n  this.valueCommonSyntax = cssWideKeywords;\n  this.syntax = syntax;\n  this.generic = false;\n  this.atrules = {};\n  this.properties = {};\n  this.types = {};\n  this.structure = structure || getStructureFromConfig(config);\n  if (config) {\n    if (config.types) {\n      for (var name in config.types) {\n        this.addType_(name, config.types[name]);\n      }\n    }\n    if (config.generic) {\n      this.generic = true;\n      for (var name in generic) {\n        this.addType_(name, generic[name]);\n      }\n    }\n    if (config.atrules) {\n      for (var name in config.atrules) {\n        this.addAtrule_(name, config.atrules[name]);\n      }\n    }\n    if (config.properties) {\n      for (var name in config.properties) {\n        this.addProperty_(name, config.properties[name]);\n      }\n    }\n  }\n};\nLexer.prototype = {\n  structure: {},\n  checkStructure: function checkStructure(ast) {\n    function collectWarning(node, message) {\n      warns.push({\n        node: node,\n        message: message\n      });\n    }\n    var structure = this.structure;\n    var warns = [];\n    this.syntax.walk(ast, function (node) {\n      if (structure.hasOwnProperty(node.type)) {\n        structure[node.type].check(node, collectWarning);\n      } else {\n        collectWarning(node, 'Unknown node type `' + node.type + '`');\n      }\n    });\n    return warns.length ? warns : false;\n  },\n  createDescriptor: function createDescriptor(syntax, type, name) {\n    var parent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var ref = {\n      type: type,\n      name: name\n    };\n    var descriptor = {\n      type: type,\n      name: name,\n      parent: parent,\n      syntax: null,\n      match: null\n    };\n    if (typeof syntax === 'function') {\n      descriptor.match = buildMatchGraph(syntax, ref);\n    } else {\n      if (typeof syntax === 'string') {\n        // lazy parsing on first access\n        Object.defineProperty(descriptor, 'syntax', {\n          get: function get() {\n            Object.defineProperty(descriptor, 'syntax', {\n              value: parse(syntax)\n            });\n            return descriptor.syntax;\n          }\n        });\n      } else {\n        descriptor.syntax = syntax;\n      }\n\n      // lazy graph build on first access\n      Object.defineProperty(descriptor, 'match', {\n        get: function get() {\n          Object.defineProperty(descriptor, 'match', {\n            value: buildMatchGraph(descriptor.syntax, ref)\n          });\n          return descriptor.match;\n        }\n      });\n    }\n    return descriptor;\n  },\n  addAtrule_: function addAtrule_(name, syntax) {\n    var _this = this;\n    if (!syntax) {\n      return;\n    }\n    this.atrules[name] = {\n      type: 'Atrule',\n      name: name,\n      prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,\n      descriptors: syntax.descriptors ? Object.keys(syntax.descriptors).reduce(function (res, descName) {\n        res[descName] = _this.createDescriptor(syntax.descriptors[descName], 'AtruleDescriptor', descName, name);\n        return res;\n      }, {}) : null\n    };\n  },\n  addProperty_: function addProperty_(name, syntax) {\n    if (!syntax) {\n      return;\n    }\n    this.properties[name] = this.createDescriptor(syntax, 'Property', name);\n  },\n  addType_: function addType_(name, syntax) {\n    if (!syntax) {\n      return;\n    }\n    this.types[name] = this.createDescriptor(syntax, 'Type', name);\n    if (syntax === generic['-ms-legacy-expression']) {\n      this.valueCommonSyntax = cssWideKeywordsWithExpression;\n    }\n  },\n  checkAtruleName: function checkAtruleName(atruleName) {\n    if (!this.getAtrule(atruleName)) {\n      return new SyntaxReferenceError('Unknown at-rule', '@' + atruleName);\n    }\n  },\n  checkAtrulePrelude: function checkAtrulePrelude(atruleName, prelude) {\n    var error = this.checkAtruleName(atruleName);\n    if (error) {\n      return error;\n    }\n    var atrule = this.getAtrule(atruleName);\n    if (!atrule.prelude && prelude) {\n      return new SyntaxError('At-rule `@' + atruleName + '` should not contain a prelude');\n    }\n    if (atrule.prelude && !prelude) {\n      return new SyntaxError('At-rule `@' + atruleName + '` should contain a prelude');\n    }\n  },\n  checkAtruleDescriptorName: function checkAtruleDescriptorName(atruleName, descriptorName) {\n    var error = this.checkAtruleName(atruleName);\n    if (error) {\n      return error;\n    }\n    var atrule = this.getAtrule(atruleName);\n    var descriptor = names.keyword(descriptorName);\n    if (!atrule.descriptors) {\n      return new SyntaxError('At-rule `@' + atruleName + '` has no known descriptors');\n    }\n    if (!atrule.descriptors[descriptor.name] && !atrule.descriptors[descriptor.basename]) {\n      return new SyntaxReferenceError('Unknown at-rule descriptor', descriptorName);\n    }\n  },\n  checkPropertyName: function checkPropertyName(propertyName) {\n    var property = names.property(propertyName);\n\n    // don't match syntax for a custom property\n    if (property.custom) {\n      return new Error('Lexer matching doesn\\'t applicable for custom properties');\n    }\n    if (!this.getProperty(propertyName)) {\n      return new SyntaxReferenceError('Unknown property', propertyName);\n    }\n  },\n  matchAtrulePrelude: function matchAtrulePrelude(atruleName, prelude) {\n    var error = this.checkAtrulePrelude(atruleName, prelude);\n    if (error) {\n      return buildMatchResult(null, error);\n    }\n    if (!prelude) {\n      return buildMatchResult(null, null);\n    }\n    return matchSyntax(this, this.getAtrule(atruleName).prelude, prelude, false);\n  },\n  matchAtruleDescriptor: function matchAtruleDescriptor(atruleName, descriptorName, value) {\n    var error = this.checkAtruleDescriptorName(atruleName, descriptorName);\n    if (error) {\n      return buildMatchResult(null, error);\n    }\n    var atrule = this.getAtrule(atruleName);\n    var descriptor = names.keyword(descriptorName);\n    return matchSyntax(this, atrule.descriptors[descriptor.name] || atrule.descriptors[descriptor.basename], value, false);\n  },\n  matchDeclaration: function matchDeclaration(node) {\n    if (node.type !== 'Declaration') {\n      return buildMatchResult(null, new Error('Not a Declaration node'));\n    }\n    return this.matchProperty(node.property, node.value);\n  },\n  matchProperty: function matchProperty(propertyName, value) {\n    var error = this.checkPropertyName(propertyName);\n    if (error) {\n      return buildMatchResult(null, error);\n    }\n    return matchSyntax(this, this.getProperty(propertyName), value, true);\n  },\n  matchType: function matchType(typeName, value) {\n    var typeSyntax = this.getType(typeName);\n    if (!typeSyntax) {\n      return buildMatchResult(null, new SyntaxReferenceError('Unknown type', typeName));\n    }\n    return matchSyntax(this, typeSyntax, value, false);\n  },\n  match: function match(syntax, value) {\n    if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {\n      return buildMatchResult(null, new SyntaxReferenceError('Bad syntax'));\n    }\n    if (typeof syntax === 'string' || !syntax.match) {\n      syntax = this.createDescriptor(syntax, 'Type', 'anonymous');\n    }\n    return matchSyntax(this, syntax, value, false);\n  },\n  findValueFragments: function findValueFragments(propertyName, value, type, name) {\n    return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);\n  },\n  findDeclarationValueFragments: function findDeclarationValueFragments(declaration, type, name) {\n    return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);\n  },\n  findAllFragments: function findAllFragments(ast, type, name) {\n    var result = [];\n    this.syntax.walk(ast, {\n      visit: 'Declaration',\n      enter: function (declaration) {\n        result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));\n      }.bind(this)\n    });\n    return result;\n  },\n  getAtrule: function getAtrule(atruleName) {\n    var fallbackBasename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var atrule = names.keyword(atruleName);\n    var atruleEntry = atrule.vendor && fallbackBasename ? this.atrules[atrule.name] || this.atrules[atrule.basename] : this.atrules[atrule.name];\n    return atruleEntry || null;\n  },\n  getAtrulePrelude: function getAtrulePrelude(atruleName) {\n    var fallbackBasename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var atrule = this.getAtrule(atruleName, fallbackBasename);\n    return atrule && atrule.prelude || null;\n  },\n  getAtruleDescriptor: function getAtruleDescriptor(atruleName, name) {\n    return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators ? this.atrules[atruleName].declarators[name] || null : null;\n  },\n  getProperty: function getProperty(propertyName) {\n    var fallbackBasename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var property = names.property(propertyName);\n    var propertyEntry = property.vendor && fallbackBasename ? this.properties[property.name] || this.properties[property.basename] : this.properties[property.name];\n    return propertyEntry || null;\n  },\n  getType: function getType(name) {\n    return this.types.hasOwnProperty(name) ? this.types[name] : null;\n  },\n  validate: function validate() {\n    function validate(syntax, name, broken, descriptor) {\n      if (broken.hasOwnProperty(name)) {\n        return broken[name];\n      }\n      broken[name] = false;\n      if (descriptor.syntax !== null) {\n        walk(descriptor.syntax, function (node) {\n          if (node.type !== 'Type' && node.type !== 'Property') {\n            return;\n          }\n          var map = node.type === 'Type' ? syntax.types : syntax.properties;\n          var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;\n          if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {\n            broken[name] = true;\n          }\n        }, this);\n      }\n    }\n    var brokenTypes = {};\n    var brokenProperties = {};\n    for (var key in this.types) {\n      validate(this, key, brokenTypes, this.types[key]);\n    }\n    for (var key in this.properties) {\n      validate(this, key, brokenProperties, this.properties[key]);\n    }\n    brokenTypes = Object.keys(brokenTypes).filter(function (name) {\n      return brokenTypes[name];\n    });\n    brokenProperties = Object.keys(brokenProperties).filter(function (name) {\n      return brokenProperties[name];\n    });\n    if (brokenTypes.length || brokenProperties.length) {\n      return {\n        types: brokenTypes,\n        properties: brokenProperties\n      };\n    }\n    return null;\n  },\n  dump: function dump(syntaxAsAst, pretty) {\n    return {\n      generic: this.generic,\n      types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),\n      properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),\n      atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst)\n    };\n  },\n  toString: function toString() {\n    return JSON.stringify(this.dump());\n  }\n};\nmodule.exports = Lexer;","map":null,"metadata":{},"sourceType":"script"}