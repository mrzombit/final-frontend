{"ast":null,"code":"var _slicedToArray = require(\"/Users/koonk/Documents/GitHub/CE65-20/packages/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar shape = {\n  generic: true,\n  types: appendOrAssign,\n  atrules: {\n    prelude: appendOrAssignOrNull,\n    descriptors: appendOrAssignOrNull\n  },\n  properties: appendOrAssign,\n  parseContext: assign,\n  scope: deepAssign,\n  atrule: ['parse'],\n  pseudo: ['parse'],\n  node: ['name', 'structure', 'parse', 'generate', 'walkContext']\n};\nfunction isObject(value) {\n  return value && value.constructor === Object;\n}\nfunction copy(value) {\n  return isObject(value) ? Object.assign({}, value) : value;\n}\nfunction assign(dest, src) {\n  return Object.assign(dest, src);\n}\nfunction deepAssign(dest, src) {\n  for (var key in src) {\n    if (hasOwnProperty.call(src, key)) {\n      if (isObject(dest[key])) {\n        deepAssign(dest[key], copy(src[key]));\n      } else {\n        dest[key] = copy(src[key]);\n      }\n    }\n  }\n  return dest;\n}\nfunction append(a, b) {\n  if (typeof b === 'string' && /^\\s*\\|/.test(b)) {\n    return typeof a === 'string' ? a + b : b.replace(/^\\s*\\|\\s*/, '');\n  }\n  return b || null;\n}\nfunction appendOrAssign(a, b) {\n  if (typeof b === 'string') {\n    return append(a, b);\n  }\n  var result = Object.assign({}, a);\n  for (var key in b) {\n    if (hasOwnProperty.call(b, key)) {\n      result[key] = append(hasOwnProperty.call(a, key) ? a[key] : undefined, b[key]);\n    }\n  }\n  return result;\n}\nfunction appendOrAssignOrNull(a, b) {\n  var result = appendOrAssign(a, b);\n  return !isObject(result) || Object.keys(result).length ? result : null;\n}\nfunction mix(dest, src, shape) {\n  for (var key in shape) {\n    if (hasOwnProperty.call(shape, key) === false) {\n      continue;\n    }\n    if (shape[key] === true) {\n      if (key in src) {\n        if (hasOwnProperty.call(src, key)) {\n          dest[key] = copy(src[key]);\n        }\n      }\n    } else if (shape[key]) {\n      if (typeof shape[key] === 'function') {\n        var fn = shape[key];\n        dest[key] = fn({}, dest[key]);\n        dest[key] = fn(dest[key] || {}, src[key]);\n      } else if (isObject(shape[key])) {\n        var result = {};\n        for (var name in dest[key]) {\n          result[name] = mix({}, dest[key][name], shape[key]);\n        }\n        for (var _name in src[key]) {\n          result[_name] = mix(result[_name] || {}, src[key][_name], shape[key]);\n        }\n        dest[key] = result;\n      } else if (Array.isArray(shape[key])) {\n        var res = {};\n        var innerShape = shape[key].reduce(function (s, k) {\n          s[k] = true;\n          return s;\n        }, {});\n        for (var _i = 0, _Object$entries = Object.entries(dest[key] || {}); _i < _Object$entries.length; _i++) {\n          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n            _name2 = _Object$entries$_i[0],\n            value = _Object$entries$_i[1];\n          res[_name2] = {};\n          if (value) {\n            mix(res[_name2], value, innerShape);\n          }\n        }\n        for (var _name3 in src[key]) {\n          if (hasOwnProperty.call(src[key], _name3)) {\n            if (!res[_name3]) {\n              res[_name3] = {};\n            }\n            if (src[key] && src[key][_name3]) {\n              mix(res[_name3], src[key][_name3], innerShape);\n            }\n          }\n        }\n        dest[key] = res;\n      }\n    }\n  }\n  return dest;\n}\nmodule.exports = function (dest, src) {\n  return mix(dest, src, shape);\n};","map":null,"metadata":{},"sourceType":"script"}