{"ast":null,"code":"var parse = require('../definition-syntax/parse');\nvar MATCH = {\n  type: 'Match'\n};\nvar MISMATCH = {\n  type: 'Mismatch'\n};\nvar DISALLOW_EMPTY = {\n  type: 'DisallowEmpty'\n};\nvar LEFTPARENTHESIS = 40; // (\nvar RIGHTPARENTHESIS = 41; // )\n\nfunction createCondition(match, thenBranch, elseBranch) {\n  // reduce node count\n  if (thenBranch === MATCH && elseBranch === MISMATCH) {\n    return match;\n  }\n  if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {\n    return match;\n  }\n  if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {\n    thenBranch = match.then;\n    match = match.match;\n  }\n  return {\n    type: 'If',\n    match: match,\n    then: thenBranch,\n    else: elseBranch\n  };\n}\nfunction isFunctionType(name) {\n  return name.length > 2 && name.charCodeAt(name.length - 2) === LEFTPARENTHESIS && name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS;\n}\nfunction isEnumCapatible(term) {\n  return term.type === 'Keyword' || term.type === 'AtKeyword' || term.type === 'Function' || term.type === 'Type' && isFunctionType(term.name);\n}\nfunction buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {\n  switch (combinator) {\n    case ' ':\n      // Juxtaposing components means that all of them must occur, in the given order.\n      //\n      // a b c\n      // =\n      // match a\n      //   then match b\n      //     then match c\n      //       then MATCH\n      //       else MISMATCH\n      //     else MISMATCH\n      //   else MISMATCH\n      var result = MATCH;\n      for (var i = terms.length - 1; i >= 0; i--) {\n        var term = terms[i];\n        result = createCondition(term, result, MISMATCH);\n      }\n      ;\n      return result;\n    case '|':\n      // A bar (|) separates two or more alternatives: exactly one of them must occur.\n      //\n      // a | b | c\n      // =\n      // match a\n      //   then MATCH\n      //   else match b\n      //     then MATCH\n      //     else match c\n      //       then MATCH\n      //       else MISMATCH\n\n      var result = MISMATCH;\n      var map = null;\n      for (var i = terms.length - 1; i >= 0; i--) {\n        var term = terms[i];\n\n        // reduce sequence of keywords into a Enum\n        if (isEnumCapatible(term)) {\n          if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {\n            map = Object.create(null);\n            result = createCondition({\n              type: 'Enum',\n              map: map\n            }, MATCH, result);\n          }\n          if (map !== null) {\n            var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();\n            if (key in map === false) {\n              map[key] = term;\n              continue;\n            }\n          }\n        }\n        map = null;\n\n        // create a new conditonal node\n        result = createCondition(term, MATCH, result);\n      }\n      ;\n      return result;\n    case '&&':\n      // A double ampersand (&&) separates two or more components,\n      // all of which must occur, in any order.\n\n      // Use MatchOnce for groups with a large number of terms,\n      // since &&-groups produces at least N!-node trees\n      if (terms.length > 5) {\n        return {\n          type: 'MatchOnce',\n          terms: terms,\n          all: true\n        };\n      }\n\n      // Use a combination tree for groups with small number of terms\n      //\n      // a && b && c\n      // =\n      // match a\n      //   then [b && c]\n      //   else match b\n      //     then [a && c]\n      //     else match c\n      //       then [a && b]\n      //       else MISMATCH\n      //\n      // a && b\n      // =\n      // match a\n      //   then match b\n      //     then MATCH\n      //     else MISMATCH\n      //   else match b\n      //     then match a\n      //       then MATCH\n      //       else MISMATCH\n      //     else MISMATCH\n      var result = MISMATCH;\n      for (var i = terms.length - 1; i >= 0; i--) {\n        var term = terms[i];\n        var thenClause;\n        if (terms.length > 1) {\n          thenClause = buildGroupMatchGraph(combinator, terms.filter(function (newGroupTerm) {\n            return newGroupTerm !== term;\n          }), false);\n        } else {\n          thenClause = MATCH;\n        }\n        result = createCondition(term, thenClause, result);\n      }\n      ;\n      return result;\n    case '||':\n      // A double bar (||) separates two or more options:\n      // one or more of them must occur, in any order.\n\n      // Use MatchOnce for groups with a large number of terms,\n      // since ||-groups produces at least N!-node trees\n      if (terms.length > 5) {\n        return {\n          type: 'MatchOnce',\n          terms: terms,\n          all: false\n        };\n      }\n\n      // Use a combination tree for groups with small number of terms\n      //\n      // a || b || c\n      // =\n      // match a\n      //   then [b || c]\n      //   else match b\n      //     then [a || c]\n      //     else match c\n      //       then [a || b]\n      //       else MISMATCH\n      //\n      // a || b\n      // =\n      // match a\n      //   then match b\n      //     then MATCH\n      //     else MATCH\n      //   else match b\n      //     then match a\n      //       then MATCH\n      //       else MATCH\n      //     else MISMATCH\n      var result = atLeastOneTermMatched ? MATCH : MISMATCH;\n      for (var i = terms.length - 1; i >= 0; i--) {\n        var term = terms[i];\n        var thenClause;\n        if (terms.length > 1) {\n          thenClause = buildGroupMatchGraph(combinator, terms.filter(function (newGroupTerm) {\n            return newGroupTerm !== term;\n          }), true);\n        } else {\n          thenClause = MATCH;\n        }\n        result = createCondition(term, thenClause, result);\n      }\n      ;\n      return result;\n  }\n}\nfunction buildMultiplierMatchGraph(node) {\n  var result = MATCH;\n  var matchTerm = _buildMatchGraph(node.term);\n  if (node.max === 0) {\n    // disable repeating of empty match to prevent infinite loop\n    matchTerm = createCondition(matchTerm, DISALLOW_EMPTY, MISMATCH);\n\n    // an occurrence count is not limited, make a cycle;\n    // to collect more terms on each following matching mismatch\n    result = createCondition(matchTerm, null,\n    // will be a loop\n    MISMATCH);\n    result.then = createCondition(MATCH, MATCH, result // make a loop\n    );\n\n    if (node.comma) {\n      result.then.else = createCondition({\n        type: 'Comma',\n        syntax: node\n      }, result, MISMATCH);\n    }\n  } else {\n    // create a match node chain for [min .. max] interval with optional matches\n    for (var i = node.min || 1; i <= node.max; i++) {\n      if (node.comma && result !== MATCH) {\n        result = createCondition({\n          type: 'Comma',\n          syntax: node\n        }, result, MISMATCH);\n      }\n      result = createCondition(matchTerm, createCondition(MATCH, MATCH, result), MISMATCH);\n    }\n  }\n  if (node.min === 0) {\n    // allow zero match\n    result = createCondition(MATCH, MATCH, result);\n  } else {\n    // create a match node chain to collect [0 ... min - 1] required matches\n    for (var i = 0; i < node.min - 1; i++) {\n      if (node.comma && result !== MATCH) {\n        result = createCondition({\n          type: 'Comma',\n          syntax: node\n        }, result, MISMATCH);\n      }\n      result = createCondition(matchTerm, result, MISMATCH);\n    }\n  }\n  return result;\n}\nfunction _buildMatchGraph(node) {\n  if (typeof node === 'function') {\n    return {\n      type: 'Generic',\n      fn: node\n    };\n  }\n  switch (node.type) {\n    case 'Group':\n      var result = buildGroupMatchGraph(node.combinator, node.terms.map(_buildMatchGraph), false);\n      if (node.disallowEmpty) {\n        result = createCondition(result, DISALLOW_EMPTY, MISMATCH);\n      }\n      return result;\n    case 'Multiplier':\n      return buildMultiplierMatchGraph(node);\n    case 'Type':\n    case 'Property':\n      return {\n        type: node.type,\n        name: node.name,\n        syntax: node\n      };\n    case 'Keyword':\n      return {\n        type: node.type,\n        name: node.name.toLowerCase(),\n        syntax: node\n      };\n    case 'AtKeyword':\n      return {\n        type: node.type,\n        name: '@' + node.name.toLowerCase(),\n        syntax: node\n      };\n    case 'Function':\n      return {\n        type: node.type,\n        name: node.name.toLowerCase() + '(',\n        syntax: node\n      };\n    case 'String':\n      // convert a one char length String to a Token\n      if (node.value.length === 3) {\n        return {\n          type: 'Token',\n          value: node.value.charAt(1),\n          syntax: node\n        };\n      }\n\n      // otherwise use it as is\n      return {\n        type: node.type,\n        value: node.value.substr(1, node.value.length - 2).replace(/\\\\'/g, '\\''),\n        syntax: node\n      };\n    case 'Token':\n      return {\n        type: node.type,\n        value: node.value,\n        syntax: node\n      };\n    case 'Comma':\n      return {\n        type: node.type,\n        syntax: node\n      };\n    default:\n      throw new Error('Unknown node type:', node.type);\n  }\n}\nmodule.exports = {\n  MATCH: MATCH,\n  MISMATCH: MISMATCH,\n  DISALLOW_EMPTY: DISALLOW_EMPTY,\n  buildMatchGraph: function buildMatchGraph(syntaxTree, ref) {\n    if (typeof syntaxTree === 'string') {\n      syntaxTree = parse(syntaxTree);\n    }\n    return {\n      type: 'MatchGraph',\n      match: _buildMatchGraph(syntaxTree),\n      syntax: ref || null,\n      source: syntaxTree\n    };\n  }\n};","map":null,"metadata":{},"sourceType":"script"}