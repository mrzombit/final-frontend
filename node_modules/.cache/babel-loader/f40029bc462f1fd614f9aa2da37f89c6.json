{"ast":null,"code":"var constants = require('../tokenizer/const');\nvar TYPE = constants.TYPE;\nvar NAME = constants.NAME;\nvar utils = require('../tokenizer/utils');\nvar cmpStr = utils.cmpStr;\nvar EOF = TYPE.EOF;\nvar WHITESPACE = TYPE.WhiteSpace;\nvar COMMENT = TYPE.Comment;\nvar OFFSET_MASK = 0x00FFFFFF;\nvar TYPE_SHIFT = 24;\nvar TokenStream = function TokenStream() {\n  this.offsetAndType = null;\n  this.balance = null;\n  this.reset();\n};\nTokenStream.prototype = {\n  reset: function reset() {\n    this.eof = false;\n    this.tokenIndex = -1;\n    this.tokenType = 0;\n    this.tokenStart = this.firstCharOffset;\n    this.tokenEnd = this.firstCharOffset;\n  },\n  lookupType: function lookupType(offset) {\n    offset += this.tokenIndex;\n    if (offset < this.tokenCount) {\n      return this.offsetAndType[offset] >> TYPE_SHIFT;\n    }\n    return EOF;\n  },\n  lookupOffset: function lookupOffset(offset) {\n    offset += this.tokenIndex;\n    if (offset < this.tokenCount) {\n      return this.offsetAndType[offset - 1] & OFFSET_MASK;\n    }\n    return this.source.length;\n  },\n  lookupValue: function lookupValue(offset, referenceStr) {\n    offset += this.tokenIndex;\n    if (offset < this.tokenCount) {\n      return cmpStr(this.source, this.offsetAndType[offset - 1] & OFFSET_MASK, this.offsetAndType[offset] & OFFSET_MASK, referenceStr);\n    }\n    return false;\n  },\n  getTokenStart: function getTokenStart(tokenIndex) {\n    if (tokenIndex === this.tokenIndex) {\n      return this.tokenStart;\n    }\n    if (tokenIndex > 0) {\n      return tokenIndex < this.tokenCount ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK : this.offsetAndType[this.tokenCount] & OFFSET_MASK;\n    }\n    return this.firstCharOffset;\n  },\n  // TODO: -> skipUntilBalanced\n  getRawLength: function getRawLength(startToken, mode) {\n    var cursor = startToken;\n    var balanceEnd;\n    var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;\n    var type;\n    loop: for (; cursor < this.tokenCount; cursor++) {\n      balanceEnd = this.balance[cursor];\n\n      // stop scanning on balance edge that points to offset before start token\n      if (balanceEnd < startToken) {\n        break loop;\n      }\n      type = this.offsetAndType[cursor] >> TYPE_SHIFT;\n\n      // check token is stop type\n      switch (mode(type, this.source, offset)) {\n        case 1:\n          break loop;\n        case 2:\n          cursor++;\n          break loop;\n        default:\n          // fast forward to the end of balanced block\n          if (this.balance[balanceEnd] === cursor) {\n            cursor = balanceEnd;\n          }\n          offset = this.offsetAndType[cursor] & OFFSET_MASK;\n      }\n    }\n    return cursor - this.tokenIndex;\n  },\n  isBalanceEdge: function isBalanceEdge(pos) {\n    return this.balance[this.tokenIndex] < pos;\n  },\n  isDelim: function isDelim(code, offset) {\n    if (offset) {\n      return this.lookupType(offset) === TYPE.Delim && this.source.charCodeAt(this.lookupOffset(offset)) === code;\n    }\n    return this.tokenType === TYPE.Delim && this.source.charCodeAt(this.tokenStart) === code;\n  },\n  getTokenValue: function getTokenValue() {\n    return this.source.substring(this.tokenStart, this.tokenEnd);\n  },\n  getTokenLength: function getTokenLength() {\n    return this.tokenEnd - this.tokenStart;\n  },\n  substrToCursor: function substrToCursor(start) {\n    return this.source.substring(start, this.tokenStart);\n  },\n  skipWS: function skipWS() {\n    for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {\n      if (this.offsetAndType[i] >> TYPE_SHIFT !== WHITESPACE) {\n        break;\n      }\n    }\n    if (skipTokenCount > 0) {\n      this.skip(skipTokenCount);\n    }\n  },\n  skipSC: function skipSC() {\n    while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {\n      this.next();\n    }\n  },\n  skip: function skip(tokenCount) {\n    var next = this.tokenIndex + tokenCount;\n    if (next < this.tokenCount) {\n      this.tokenIndex = next;\n      this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;\n      next = this.offsetAndType[next];\n      this.tokenType = next >> TYPE_SHIFT;\n      this.tokenEnd = next & OFFSET_MASK;\n    } else {\n      this.tokenIndex = this.tokenCount;\n      this.next();\n    }\n  },\n  next: function next() {\n    var next = this.tokenIndex + 1;\n    if (next < this.tokenCount) {\n      this.tokenIndex = next;\n      this.tokenStart = this.tokenEnd;\n      next = this.offsetAndType[next];\n      this.tokenType = next >> TYPE_SHIFT;\n      this.tokenEnd = next & OFFSET_MASK;\n    } else {\n      this.tokenIndex = this.tokenCount;\n      this.eof = true;\n      this.tokenType = EOF;\n      this.tokenStart = this.tokenEnd = this.source.length;\n    }\n  },\n  forEachToken: function forEachToken(fn) {\n    for (var i = 0, offset = this.firstCharOffset; i < this.tokenCount; i++) {\n      var start = offset;\n      var item = this.offsetAndType[i];\n      var end = item & OFFSET_MASK;\n      var type = item >> TYPE_SHIFT;\n      offset = end;\n      fn(type, start, end, i);\n    }\n  },\n  dump: function dump() {\n    var _this = this;\n    var tokens = new Array(this.tokenCount);\n    this.forEachToken(function (type, start, end, index) {\n      tokens[index] = {\n        idx: index,\n        type: NAME[type],\n        chunk: _this.source.substring(start, end),\n        balance: _this.balance[index]\n      };\n    });\n    return tokens;\n  }\n};\nmodule.exports = TokenStream;","map":null,"metadata":{},"sourceType":"script"}