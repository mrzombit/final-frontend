{"ast":null,"code":"import _extends from '@babel/runtime/helpers/extends';\nimport * as primitives from '@react-pdf/primitives';\nexport * from '@react-pdf/primitives';\nimport queue from 'queue';\nimport require$$1, { useRef, useState, useEffect } from 'react';\nimport _regeneratorRuntime from '@babel/runtime/helpers/regeneratorRuntime';\nimport _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';\nimport FontStore from '@react-pdf/font';\nimport renderPDF from '@react-pdf/render';\nimport PDFDocument from '@react-pdf/pdfkit';\nimport layoutDocument from '@react-pdf/layout';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/objectWithoutPropertiesLoose';\nimport require$$0 from 'object-assign';\nimport * as scheduler from 'scheduler';\nimport { jsx } from 'react/jsx-runtime';\nfunction getAugmentedNamespace(n) {\n  if (n.__esModule) return n;\n  var a = Object.defineProperty({}, '__esModule', {\n    value: true\n  });\n  Object.keys(n).forEach(function (k) {\n    var d = Object.getOwnPropertyDescriptor(n, k);\n    Object.defineProperty(a, k, d.get ? d : {\n      enumerable: true,\n      get: function get() {\n        return n[k];\n      }\n    });\n  });\n  return a;\n}\nvar reactReconciler_production_min = {\n  exports: {}\n};\nvar require$$2 = /*@__PURE__*/getAugmentedNamespace(scheduler);\n\n/** @license React v0.23.0\n * react-reconciler.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n(function (module) {\n  module.exports = function $$$reconciler($$$hostConfig) {\n    var aa = require$$0,\n      ba = require$$1,\n      m = require$$2;\n    function n(a) {\n      for (var b = \"https://reactjs.org/docs/error-decoder.html?invariant=\" + a, c = 1; c < arguments.length; c++) b += \"&args[]=\" + encodeURIComponent(arguments[c]);\n      return \"Minified React error #\" + a + \"; visit \" + b + \" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.\";\n    }\n    var q = ba.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    q.hasOwnProperty(\"ReactCurrentDispatcher\") || (q.ReactCurrentDispatcher = {\n      current: null\n    });\n    q.hasOwnProperty(\"ReactCurrentBatchConfig\") || (q.ReactCurrentBatchConfig = {\n      suspense: null\n    });\n    var u = \"function\" === typeof Symbol && Symbol.for,\n      ca = u ? Symbol.for(\"react.element\") : 60103,\n      da = u ? Symbol.for(\"react.portal\") : 60106,\n      ea = u ? Symbol.for(\"react.fragment\") : 60107,\n      fa = u ? Symbol.for(\"react.strict_mode\") : 60108,\n      ha = u ? Symbol.for(\"react.profiler\") : 60114,\n      ia = u ? Symbol.for(\"react.provider\") : 60109,\n      ja = u ? Symbol.for(\"react.context\") : 60110,\n      ka = u ? Symbol.for(\"react.concurrent_mode\") : 60111,\n      la = u ? Symbol.for(\"react.forward_ref\") : 60112,\n      ma = u ? Symbol.for(\"react.suspense\") : 60113,\n      na = u ? Symbol.for(\"react.suspense_list\") : 60120,\n      oa = u ? Symbol.for(\"react.memo\") : 60115,\n      pa = u ? Symbol.for(\"react.lazy\") : 60116;\n    var qa = \"function\" === typeof Symbol && Symbol.iterator;\n    function ra(a) {\n      if (null === a || \"object\" !== typeof a) return null;\n      a = qa && a[qa] || a[\"@@iterator\"];\n      return \"function\" === typeof a ? a : null;\n    }\n    function sa(a) {\n      if (-1 === a._status) {\n        a._status = 0;\n        var b = a._ctor;\n        b = b();\n        a._result = b;\n        b.then(function (b) {\n          0 === a._status && (b = b.default, a._status = 1, a._result = b);\n        }, function (b) {\n          0 === a._status && (a._status = 2, a._result = b);\n        });\n      }\n    }\n    function ta(a) {\n      if (null == a) return null;\n      if (\"function\" === typeof a) return a.displayName || a.name || null;\n      if (\"string\" === typeof a) return a;\n      switch (a) {\n        case ea:\n          return \"Fragment\";\n        case da:\n          return \"Portal\";\n        case ha:\n          return \"Profiler\";\n        case fa:\n          return \"StrictMode\";\n        case ma:\n          return \"Suspense\";\n        case na:\n          return \"SuspenseList\";\n      }\n      if (\"object\" === typeof a) switch (a.$$typeof) {\n        case ja:\n          return \"Context.Consumer\";\n        case ia:\n          return \"Context.Provider\";\n        case la:\n          var b = a.render;\n          b = b.displayName || b.name || \"\";\n          return a.displayName || (\"\" !== b ? \"ForwardRef(\" + b + \")\" : \"ForwardRef\");\n        case oa:\n          return ta(a.type);\n        case pa:\n          if (a = 1 === a._status ? a._result : null) return ta(a);\n      }\n      return null;\n    }\n    function ua(a) {\n      var b = a,\n        c = a;\n      if (a.alternate) for (; b.return;) b = b.return;else {\n        a = b;\n        do b = a, 0 !== (b.effectTag & 1026) && (c = b.return), a = b.return; while (a);\n      }\n      return 3 === b.tag ? c : null;\n    }\n    function va(a) {\n      if (ua(a) !== a) throw Error(n(188));\n    }\n    function wa(a) {\n      var b = a.alternate;\n      if (!b) {\n        b = ua(a);\n        if (null === b) throw Error(n(188));\n        return b !== a ? null : a;\n      }\n      for (var c = a, d = b;;) {\n        var e = c.return;\n        if (null === e) break;\n        var f = e.alternate;\n        if (null === f) {\n          d = e.return;\n          if (null !== d) {\n            c = d;\n            continue;\n          }\n          break;\n        }\n        if (e.child === f.child) {\n          for (f = e.child; f;) {\n            if (f === c) return va(e), a;\n            if (f === d) return va(e), b;\n            f = f.sibling;\n          }\n          throw Error(n(188));\n        }\n        if (c.return !== d.return) c = e, d = f;else {\n          for (var g = !1, l = e.child; l;) {\n            if (l === c) {\n              g = !0;\n              c = e;\n              d = f;\n              break;\n            }\n            if (l === d) {\n              g = !0;\n              d = e;\n              c = f;\n              break;\n            }\n            l = l.sibling;\n          }\n          if (!g) {\n            for (l = f.child; l;) {\n              if (l === c) {\n                g = !0;\n                c = f;\n                d = e;\n                break;\n              }\n              if (l === d) {\n                g = !0;\n                d = f;\n                c = e;\n                break;\n              }\n              l = l.sibling;\n            }\n            if (!g) throw Error(n(189));\n          }\n        }\n        if (c.alternate !== d) throw Error(n(190));\n      }\n      if (3 !== c.tag) throw Error(n(188));\n      return c.stateNode.current === c ? a : b;\n    }\n    function xa(a) {\n      a = wa(a);\n      if (!a) return null;\n      for (var b = a;;) {\n        if (5 === b.tag || 6 === b.tag) return b;\n        if (b.child) b.child.return = b, b = b.child;else {\n          if (b === a) break;\n          for (; !b.sibling;) {\n            if (!b.return || b.return === a) return null;\n            b = b.return;\n          }\n          b.sibling.return = b.return;\n          b = b.sibling;\n        }\n      }\n      return null;\n    }\n    function ya(a) {\n      a = wa(a);\n      if (!a) return null;\n      for (var b = a;;) {\n        if (5 === b.tag || 6 === b.tag) return b;\n        if (b.child && 4 !== b.tag) b.child.return = b, b = b.child;else {\n          if (b === a) break;\n          for (; !b.sibling;) {\n            if (!b.return || b.return === a) return null;\n            b = b.return;\n          }\n          b.sibling.return = b.return;\n          b = b.sibling;\n        }\n      }\n      return null;\n    }\n    var za = $$$hostConfig.getPublicInstance,\n      Aa = $$$hostConfig.getRootHostContext,\n      Ba = $$$hostConfig.getChildHostContext,\n      Ca = $$$hostConfig.prepareForCommit,\n      Da = $$$hostConfig.resetAfterCommit,\n      Ea = $$$hostConfig.createInstance,\n      Fa = $$$hostConfig.appendInitialChild,\n      Ga = $$$hostConfig.finalizeInitialChildren,\n      Ia = $$$hostConfig.prepareUpdate,\n      Ja = $$$hostConfig.shouldSetTextContent,\n      Ka = $$$hostConfig.shouldDeprioritizeSubtree,\n      La = $$$hostConfig.createTextInstance,\n      Ma = $$$hostConfig.setTimeout,\n      Na = $$$hostConfig.clearTimeout,\n      Oa = $$$hostConfig.noTimeout,\n      Pa = $$$hostConfig.isPrimaryRenderer,\n      Qa = $$$hostConfig.supportsMutation,\n      Ra = $$$hostConfig.supportsPersistence,\n      Sa = $$$hostConfig.supportsHydration,\n      Ta = $$$hostConfig.appendChild,\n      Ua = $$$hostConfig.appendChildToContainer,\n      Va = $$$hostConfig.commitTextUpdate,\n      Wa = $$$hostConfig.commitMount,\n      Xa = $$$hostConfig.commitUpdate,\n      Ya = $$$hostConfig.insertBefore,\n      Za = $$$hostConfig.insertInContainerBefore,\n      $a = $$$hostConfig.removeChild,\n      ab = $$$hostConfig.removeChildFromContainer,\n      bb = $$$hostConfig.resetTextContent,\n      cb = $$$hostConfig.hideInstance,\n      db = $$$hostConfig.hideTextInstance,\n      eb = $$$hostConfig.unhideInstance,\n      fb = $$$hostConfig.unhideTextInstance,\n      gb = $$$hostConfig.cloneInstance,\n      hb = $$$hostConfig.createContainerChildSet,\n      ib = $$$hostConfig.appendChildToContainerChildSet,\n      kb = $$$hostConfig.finalizeContainerChildren,\n      lb = $$$hostConfig.replaceContainerChildren,\n      mb = $$$hostConfig.cloneHiddenInstance,\n      nb = $$$hostConfig.cloneHiddenTextInstance,\n      ob = $$$hostConfig.canHydrateInstance,\n      pb = $$$hostConfig.canHydrateTextInstance,\n      qb = $$$hostConfig.isSuspenseInstancePending,\n      rb = $$$hostConfig.isSuspenseInstanceFallback,\n      sb = $$$hostConfig.getNextHydratableSibling,\n      tb = $$$hostConfig.getFirstHydratableChild,\n      ub = $$$hostConfig.hydrateInstance,\n      vb = $$$hostConfig.hydrateTextInstance,\n      wb = $$$hostConfig.getNextHydratableInstanceAfterSuspenseInstance,\n      xb = $$$hostConfig.commitHydratedContainer,\n      yb = $$$hostConfig.commitHydratedSuspenseInstance,\n      zb = /^(.*)[\\\\\\/]/;\n    function Ab(a) {\n      var b = \"\";\n      do {\n        a: switch (a.tag) {\n          case 3:\n          case 4:\n          case 6:\n          case 7:\n          case 10:\n          case 9:\n            var c = \"\";\n            break a;\n          default:\n            var d = a._debugOwner,\n              e = a._debugSource,\n              f = ta(a.type);\n            c = null;\n            d && (c = ta(d.type));\n            d = f;\n            f = \"\";\n            e ? f = \" (at \" + e.fileName.replace(zb, \"\") + \":\" + e.lineNumber + \")\" : c && (f = \" (created by \" + c + \")\");\n            c = \"\\n    in \" + (d || \"Unknown\") + f;\n        }\n        b += c;\n        a = a.return;\n      } while (a);\n      return b;\n    }\n    var Bb = [],\n      Cb = -1;\n    function y(a) {\n      0 > Cb || (a.current = Bb[Cb], Bb[Cb] = null, Cb--);\n    }\n    function z(a, b) {\n      Cb++;\n      Bb[Cb] = a.current;\n      a.current = b;\n    }\n    var Db = {},\n      A = {\n        current: Db\n      },\n      B = {\n        current: !1\n      },\n      Eb = Db;\n    function Fb(a, b) {\n      var c = a.type.contextTypes;\n      if (!c) return Db;\n      var d = a.stateNode;\n      if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;\n      var e = {},\n        f;\n      for (f in c) e[f] = b[f];\n      d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);\n      return e;\n    }\n    function C(a) {\n      a = a.childContextTypes;\n      return null !== a && void 0 !== a;\n    }\n    function Gb(a) {\n      y(B);\n      y(A);\n    }\n    function Hb(a) {\n      y(B);\n      y(A);\n    }\n    function Ib(a, b, c) {\n      if (A.current !== Db) throw Error(n(168));\n      z(A, b);\n      z(B, c);\n    }\n    function Jb(a, b, c) {\n      var d = a.stateNode;\n      a = b.childContextTypes;\n      if (\"function\" !== typeof d.getChildContext) return c;\n      d = d.getChildContext();\n      for (var e in d) if (!(e in a)) throw Error(n(108, ta(b) || \"Unknown\", e));\n      return aa({}, c, {}, d);\n    }\n    function Kb(a) {\n      var b = a.stateNode;\n      b = b && b.__reactInternalMemoizedMergedChildContext || Db;\n      Eb = A.current;\n      z(A, b);\n      z(B, B.current);\n      return !0;\n    }\n    function Lb(a, b, c) {\n      var d = a.stateNode;\n      if (!d) throw Error(n(169));\n      c ? (b = Jb(a, b, Eb), d.__reactInternalMemoizedMergedChildContext = b, y(B), y(A), z(A, b)) : y(B);\n      z(B, c);\n    }\n    var Mb = m.unstable_runWithPriority,\n      Nb = m.unstable_scheduleCallback,\n      Ob = m.unstable_cancelCallback,\n      Pb = m.unstable_shouldYield,\n      Qb = m.unstable_requestPaint,\n      Tb = m.unstable_now,\n      Ub = m.unstable_getCurrentPriorityLevel,\n      Vb = m.unstable_ImmediatePriority,\n      Wb = m.unstable_UserBlockingPriority,\n      Xb = m.unstable_NormalPriority,\n      Yb = m.unstable_LowPriority,\n      Zb = m.unstable_IdlePriority,\n      $b = {},\n      ac = void 0 !== Qb ? Qb : function () {},\n      bc = null,\n      cc = null,\n      dc = !1,\n      ec = Tb(),\n      E = 1E4 > ec ? Tb : function () {\n        return Tb() - ec;\n      };\n    function fc() {\n      switch (Ub()) {\n        case Vb:\n          return 99;\n        case Wb:\n          return 98;\n        case Xb:\n          return 97;\n        case Yb:\n          return 96;\n        case Zb:\n          return 95;\n        default:\n          throw Error(n(332));\n      }\n    }\n    function gc(a) {\n      switch (a) {\n        case 99:\n          return Vb;\n        case 98:\n          return Wb;\n        case 97:\n          return Xb;\n        case 96:\n          return Yb;\n        case 95:\n          return Zb;\n        default:\n          throw Error(n(332));\n      }\n    }\n    function hc(a, b) {\n      a = gc(a);\n      return Mb(a, b);\n    }\n    function ic(a, b, c) {\n      a = gc(a);\n      return Nb(a, b, c);\n    }\n    function jc(a) {\n      null === bc ? (bc = [a], cc = Nb(Vb, kc)) : bc.push(a);\n      return $b;\n    }\n    function F() {\n      if (null !== cc) {\n        var a = cc;\n        cc = null;\n        Ob(a);\n      }\n      kc();\n    }\n    function kc() {\n      if (!dc && null !== bc) {\n        dc = !0;\n        var a = 0;\n        try {\n          var b = bc;\n          hc(99, function () {\n            for (; a < b.length; a++) {\n              var c = b[a];\n              do c = c(!0); while (null !== c);\n            }\n          });\n          bc = null;\n        } catch (c) {\n          throw null !== bc && (bc = bc.slice(a + 1)), Nb(Vb, F), c;\n        } finally {\n          dc = !1;\n        }\n      }\n    }\n    var lc = 3;\n    function mc(a, b, c) {\n      c /= 10;\n      return 1073741821 - (((1073741821 - a + b / 10) / c | 0) + 1) * c;\n    }\n    function nc(a, b) {\n      return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;\n    }\n    var oc = \"function\" === typeof Object.is ? Object.is : nc,\n      pc = Object.prototype.hasOwnProperty;\n    function qc(a, b) {\n      if (oc(a, b)) return !0;\n      if (\"object\" !== typeof a || null === a || \"object\" !== typeof b || null === b) return !1;\n      var c = Object.keys(a),\n        d = Object.keys(b);\n      if (c.length !== d.length) return !1;\n      for (d = 0; d < c.length; d++) if (!pc.call(b, c[d]) || !oc(a[c[d]], b[c[d]])) return !1;\n      return !0;\n    }\n    function rc(a, b) {\n      if (a && a.defaultProps) {\n        b = aa({}, b);\n        a = a.defaultProps;\n        for (var c in a) void 0 === b[c] && (b[c] = a[c]);\n      }\n      return b;\n    }\n    var sc = {\n        current: null\n      },\n      tc = null,\n      uc = null,\n      vc = null;\n    function wc() {\n      vc = uc = tc = null;\n    }\n    function xc(a, b) {\n      var c = a.type._context;\n      Pa ? (z(sc, c._currentValue), c._currentValue = b) : (z(sc, c._currentValue2), c._currentValue2 = b);\n    }\n    function yc(a) {\n      var b = sc.current;\n      y(sc);\n      a = a.type._context;\n      Pa ? a._currentValue = b : a._currentValue2 = b;\n    }\n    function zc(a, b) {\n      for (; null !== a;) {\n        var c = a.alternate;\n        if (a.childExpirationTime < b) a.childExpirationTime = b, null !== c && c.childExpirationTime < b && (c.childExpirationTime = b);else if (null !== c && c.childExpirationTime < b) c.childExpirationTime = b;else break;\n        a = a.return;\n      }\n    }\n    function Ac(a, b) {\n      tc = a;\n      vc = uc = null;\n      a = a.dependencies;\n      null !== a && null !== a.firstContext && (a.expirationTime >= b && (Bc = !0), a.firstContext = null);\n    }\n    function Cc(a, b) {\n      if (vc !== a && !1 !== b && 0 !== b) {\n        if (\"number\" !== typeof b || 1073741823 === b) vc = a, b = 1073741823;\n        b = {\n          context: a,\n          observedBits: b,\n          next: null\n        };\n        if (null === uc) {\n          if (null === tc) throw Error(n(308));\n          uc = b;\n          tc.dependencies = {\n            expirationTime: 0,\n            firstContext: b,\n            responders: null\n          };\n        } else uc = uc.next = b;\n      }\n      return Pa ? a._currentValue : a._currentValue2;\n    }\n    var Dc = !1;\n    function Ec(a) {\n      return {\n        baseState: a,\n        firstUpdate: null,\n        lastUpdate: null,\n        firstCapturedUpdate: null,\n        lastCapturedUpdate: null,\n        firstEffect: null,\n        lastEffect: null,\n        firstCapturedEffect: null,\n        lastCapturedEffect: null\n      };\n    }\n    function Fc(a) {\n      return {\n        baseState: a.baseState,\n        firstUpdate: a.firstUpdate,\n        lastUpdate: a.lastUpdate,\n        firstCapturedUpdate: null,\n        lastCapturedUpdate: null,\n        firstEffect: null,\n        lastEffect: null,\n        firstCapturedEffect: null,\n        lastCapturedEffect: null\n      };\n    }\n    function Gc(a, b) {\n      return {\n        expirationTime: a,\n        suspenseConfig: b,\n        tag: 0,\n        payload: null,\n        callback: null,\n        next: null,\n        nextEffect: null\n      };\n    }\n    function Hc(a, b) {\n      null === a.lastUpdate ? a.firstUpdate = a.lastUpdate = b : (a.lastUpdate.next = b, a.lastUpdate = b);\n    }\n    function Ic(a, b) {\n      var c = a.alternate;\n      if (null === c) {\n        var d = a.updateQueue;\n        var e = null;\n        null === d && (d = a.updateQueue = Ec(a.memoizedState));\n      } else d = a.updateQueue, e = c.updateQueue, null === d ? null === e ? (d = a.updateQueue = Ec(a.memoizedState), e = c.updateQueue = Ec(c.memoizedState)) : d = a.updateQueue = Fc(e) : null === e && (e = c.updateQueue = Fc(d));\n      null === e || d === e ? Hc(d, b) : null === d.lastUpdate || null === e.lastUpdate ? (Hc(d, b), Hc(e, b)) : (Hc(d, b), e.lastUpdate = b);\n    }\n    function Jc(a, b) {\n      var c = a.updateQueue;\n      c = null === c ? a.updateQueue = Ec(a.memoizedState) : Kc(a, c);\n      null === c.lastCapturedUpdate ? c.firstCapturedUpdate = c.lastCapturedUpdate = b : (c.lastCapturedUpdate.next = b, c.lastCapturedUpdate = b);\n    }\n    function Kc(a, b) {\n      var c = a.alternate;\n      null !== c && b === c.updateQueue && (b = a.updateQueue = Fc(b));\n      return b;\n    }\n    function Lc(a, b, c, d, e, f) {\n      switch (c.tag) {\n        case 1:\n          return a = c.payload, \"function\" === typeof a ? a.call(f, d, e) : a;\n        case 3:\n          a.effectTag = a.effectTag & -4097 | 64;\n        case 0:\n          a = c.payload;\n          e = \"function\" === typeof a ? a.call(f, d, e) : a;\n          if (null === e || void 0 === e) break;\n          return aa({}, d, e);\n        case 2:\n          Dc = !0;\n      }\n      return d;\n    }\n    function Nc(a, b, c, d, e) {\n      Dc = !1;\n      b = Kc(a, b);\n      for (var f = b.baseState, g = null, l = 0, h = b.firstUpdate, k = f; null !== h;) {\n        var p = h.expirationTime;\n        p < e ? (null === g && (g = h, f = k), l < p && (l = p)) : (Oc(p, h.suspenseConfig), k = Lc(a, b, h, k, c, d), null !== h.callback && (a.effectTag |= 32, h.nextEffect = null, null === b.lastEffect ? b.firstEffect = b.lastEffect = h : (b.lastEffect.nextEffect = h, b.lastEffect = h)));\n        h = h.next;\n      }\n      p = null;\n      for (h = b.firstCapturedUpdate; null !== h;) {\n        var D = h.expirationTime;\n        D < e ? (null === p && (p = h, null === g && (f = k)), l < D && (l = D)) : (k = Lc(a, b, h, k, c, d), null !== h.callback && (a.effectTag |= 32, h.nextEffect = null, null === b.lastCapturedEffect ? b.firstCapturedEffect = b.lastCapturedEffect = h : (b.lastCapturedEffect.nextEffect = h, b.lastCapturedEffect = h)));\n        h = h.next;\n      }\n      null === g && (b.lastUpdate = null);\n      null === p ? b.lastCapturedUpdate = null : a.effectTag |= 32;\n      null === g && null === p && (f = k);\n      b.baseState = f;\n      b.firstUpdate = g;\n      b.firstCapturedUpdate = p;\n      Pc(l);\n      a.expirationTime = l;\n      a.memoizedState = k;\n    }\n    function Qc(a, b, c) {\n      null !== b.firstCapturedUpdate && (null !== b.lastUpdate && (b.lastUpdate.next = b.firstCapturedUpdate, b.lastUpdate = b.lastCapturedUpdate), b.firstCapturedUpdate = b.lastCapturedUpdate = null);\n      Rc(b.firstEffect, c);\n      b.firstEffect = b.lastEffect = null;\n      Rc(b.firstCapturedEffect, c);\n      b.firstCapturedEffect = b.lastCapturedEffect = null;\n    }\n    function Rc(a, b) {\n      for (; null !== a;) {\n        var c = a.callback;\n        if (null !== c) {\n          a.callback = null;\n          var d = b;\n          if (\"function\" !== typeof c) throw Error(n(191, c));\n          c.call(d);\n        }\n        a = a.nextEffect;\n      }\n    }\n    var Sc = q.ReactCurrentBatchConfig,\n      Tc = new ba.Component().refs;\n    function Uc(a, b, c, d) {\n      b = a.memoizedState;\n      c = c(d, b);\n      c = null === c || void 0 === c ? b : aa({}, b, c);\n      a.memoizedState = c;\n      d = a.updateQueue;\n      null !== d && 0 === a.expirationTime && (d.baseState = c);\n    }\n    var Xc = {\n      isMounted: function isMounted(a) {\n        return (a = a._reactInternalFiber) ? ua(a) === a : !1;\n      },\n      enqueueSetState: function enqueueSetState(a, b, c) {\n        a = a._reactInternalFiber;\n        var d = G(),\n          e = Sc.suspense;\n        d = Vc(d, a, e);\n        e = Gc(d, e);\n        e.payload = b;\n        void 0 !== c && null !== c && (e.callback = c);\n        Ic(a, e);\n        Wc(a, d);\n      },\n      enqueueReplaceState: function enqueueReplaceState(a, b, c) {\n        a = a._reactInternalFiber;\n        var d = G(),\n          e = Sc.suspense;\n        d = Vc(d, a, e);\n        e = Gc(d, e);\n        e.tag = 1;\n        e.payload = b;\n        void 0 !== c && null !== c && (e.callback = c);\n        Ic(a, e);\n        Wc(a, d);\n      },\n      enqueueForceUpdate: function enqueueForceUpdate(a, b) {\n        a = a._reactInternalFiber;\n        var c = G(),\n          d = Sc.suspense;\n        c = Vc(c, a, d);\n        d = Gc(c, d);\n        d.tag = 2;\n        void 0 !== b && null !== b && (d.callback = b);\n        Ic(a, d);\n        Wc(a, c);\n      }\n    };\n    function Yc(a, b, c, d, e, f, g) {\n      a = a.stateNode;\n      return \"function\" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !qc(c, d) || !qc(e, f) : !0;\n    }\n    function Zc(a, b, c) {\n      var d = !1,\n        e = Db;\n      var f = b.contextType;\n      \"object\" === typeof f && null !== f ? f = Cc(f) : (e = C(b) ? Eb : A.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Fb(a, e) : Db);\n      b = new b(c, f);\n      a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;\n      b.updater = Xc;\n      a.stateNode = b;\n      b._reactInternalFiber = a;\n      d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);\n      return b;\n    }\n    function $c(a, b, c, d) {\n      a = b.state;\n      \"function\" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);\n      \"function\" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);\n      b.state !== a && Xc.enqueueReplaceState(b, b.state, null);\n    }\n    function ad(a, b, c, d) {\n      var e = a.stateNode;\n      e.props = c;\n      e.state = a.memoizedState;\n      e.refs = Tc;\n      var f = b.contextType;\n      \"object\" === typeof f && null !== f ? e.context = Cc(f) : (f = C(b) ? Eb : A.current, e.context = Fb(a, f));\n      f = a.updateQueue;\n      null !== f && (Nc(a, f, c, e, d), e.state = a.memoizedState);\n      f = b.getDerivedStateFromProps;\n      \"function\" === typeof f && (Uc(a, b, f, c), e.state = a.memoizedState);\n      \"function\" === typeof b.getDerivedStateFromProps || \"function\" === typeof e.getSnapshotBeforeUpdate || \"function\" !== typeof e.UNSAFE_componentWillMount && \"function\" !== typeof e.componentWillMount || (b = e.state, \"function\" === typeof e.componentWillMount && e.componentWillMount(), \"function\" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Xc.enqueueReplaceState(e, e.state, null), f = a.updateQueue, null !== f && (Nc(a, f, c, e, d), e.state = a.memoizedState));\n      \"function\" === typeof e.componentDidMount && (a.effectTag |= 4);\n    }\n    var bd = Array.isArray;\n    function cd(a, b, c) {\n      a = c.ref;\n      if (null !== a && \"function\" !== typeof a && \"object\" !== typeof a) {\n        if (c._owner) {\n          c = c._owner;\n          if (c) {\n            if (1 !== c.tag) throw Error(n(309));\n            var d = c.stateNode;\n          }\n          if (!d) throw Error(n(147, a));\n          var e = \"\" + a;\n          if (null !== b && null !== b.ref && \"function\" === typeof b.ref && b.ref._stringRef === e) return b.ref;\n          b = function b(_b) {\n            var a = d.refs;\n            a === Tc && (a = d.refs = {});\n            null === _b ? delete a[e] : a[e] = _b;\n          };\n          b._stringRef = e;\n          return b;\n        }\n        if (\"string\" !== typeof a) throw Error(n(284));\n        if (!c._owner) throw Error(n(290, a));\n      }\n      return a;\n    }\n    function dd(a, b) {\n      if (\"textarea\" !== a.type) throw Error(n(31, \"[object Object]\" === Object.prototype.toString.call(b) ? \"object with keys {\" + Object.keys(b).join(\", \") + \"}\" : b, \"\"));\n    }\n    function ed(a) {\n      function b(b, c) {\n        if (a) {\n          var d = b.lastEffect;\n          null !== d ? (d.nextEffect = c, b.lastEffect = c) : b.firstEffect = b.lastEffect = c;\n          c.nextEffect = null;\n          c.effectTag = 8;\n        }\n      }\n      function c(c, d) {\n        if (!a) return null;\n        for (; null !== d;) b(c, d), d = d.sibling;\n        return null;\n      }\n      function d(b, a) {\n        for (b = new Map(); null !== a;) null !== a.key ? b.set(a.key, a) : b.set(a.index, a), a = a.sibling;\n        return b;\n      }\n      function e(b, a, c) {\n        b = fd(b, a);\n        b.index = 0;\n        b.sibling = null;\n        return b;\n      }\n      function f(b, c, d) {\n        b.index = d;\n        if (!a) return c;\n        d = b.alternate;\n        if (null !== d) return d = d.index, d < c ? (b.effectTag = 2, c) : d;\n        b.effectTag = 2;\n        return c;\n      }\n      function g(b) {\n        a && null === b.alternate && (b.effectTag = 2);\n        return b;\n      }\n      function l(b, a, c, d) {\n        if (null === a || 6 !== a.tag) return a = gd(c, b.mode, d), a.return = b, a;\n        a = e(a, c);\n        a.return = b;\n        return a;\n      }\n      function h(b, a, c, d) {\n        if (null !== a && a.elementType === c.type) return d = e(a, c.props), d.ref = cd(b, a, c), d.return = b, d;\n        d = hd(c.type, c.key, c.props, null, b.mode, d);\n        d.ref = cd(b, a, c);\n        d.return = b;\n        return d;\n      }\n      function k(b, a, c, d) {\n        if (null === a || 4 !== a.tag || a.stateNode.containerInfo !== c.containerInfo || a.stateNode.implementation !== c.implementation) return a = id(c, b.mode, d), a.return = b, a;\n        a = e(a, c.children || []);\n        a.return = b;\n        return a;\n      }\n      function p(b, a, c, d, f) {\n        if (null === a || 7 !== a.tag) return a = jd(c, b.mode, d, f), a.return = b, a;\n        a = e(a, c);\n        a.return = b;\n        return a;\n      }\n      function D(b, a, c) {\n        if (\"string\" === typeof a || \"number\" === typeof a) return a = gd(\"\" + a, b.mode, c), a.return = b, a;\n        if (\"object\" === typeof a && null !== a) {\n          switch (a.$$typeof) {\n            case ca:\n              return c = hd(a.type, a.key, a.props, null, b.mode, c), c.ref = cd(b, null, a), c.return = b, c;\n            case da:\n              return a = id(a, b.mode, c), a.return = b, a;\n          }\n          if (bd(a) || ra(a)) return a = jd(a, b.mode, c, null), a.return = b, a;\n          dd(b, a);\n        }\n        return null;\n      }\n      function x(b, a, c, d) {\n        var e = null !== a ? a.key : null;\n        if (\"string\" === typeof c || \"number\" === typeof c) return null !== e ? null : l(b, a, \"\" + c, d);\n        if (\"object\" === typeof c && null !== c) {\n          switch (c.$$typeof) {\n            case ca:\n              return c.key === e ? c.type === ea ? p(b, a, c.props.children, d, e) : h(b, a, c, d) : null;\n            case da:\n              return c.key === e ? k(b, a, c, d) : null;\n          }\n          if (bd(c) || ra(c)) return null !== e ? null : p(b, a, c, d, null);\n          dd(b, c);\n        }\n        return null;\n      }\n      function K(b, a, c, d, e) {\n        if (\"string\" === typeof d || \"number\" === typeof d) return b = b.get(c) || null, l(a, b, \"\" + d, e);\n        if (\"object\" === typeof d && null !== d) {\n          switch (d.$$typeof) {\n            case ca:\n              return b = b.get(null === d.key ? c : d.key) || null, d.type === ea ? p(a, b, d.props.children, e, d.key) : h(a, b, d, e);\n            case da:\n              return b = b.get(null === d.key ? c : d.key) || null, k(a, b, d, e);\n          }\n          if (bd(d) || ra(d)) return b = b.get(c) || null, p(a, b, d, e, null);\n          dd(a, d);\n        }\n        return null;\n      }\n      function Ha(e, g, h, l) {\n        for (var k = null, w = null, t = g, r = g = 0, p = null; null !== t && r < h.length; r++) {\n          t.index > r ? (p = t, t = null) : p = t.sibling;\n          var v = x(e, t, h[r], l);\n          if (null === v) {\n            null === t && (t = p);\n            break;\n          }\n          a && t && null === v.alternate && b(e, t);\n          g = f(v, g, r);\n          null === w ? k = v : w.sibling = v;\n          w = v;\n          t = p;\n        }\n        if (r === h.length) return c(e, t), k;\n        if (null === t) {\n          for (; r < h.length; r++) t = D(e, h[r], l), null !== t && (g = f(t, g, r), null === w ? k = t : w.sibling = t, w = t);\n          return k;\n        }\n        for (t = d(e, t); r < h.length; r++) p = K(t, e, r, h[r], l), null !== p && (a && null !== p.alternate && t.delete(null === p.key ? r : p.key), g = f(p, g, r), null === w ? k = p : w.sibling = p, w = p);\n        a && t.forEach(function (a) {\n          return b(e, a);\n        });\n        return k;\n      }\n      function O(e, g, h, l) {\n        var k = ra(h);\n        if (\"function\" !== typeof k) throw Error(n(150));\n        h = k.call(h);\n        if (null == h) throw Error(n(151));\n        for (var t = k = null, r = g, w = g = 0, p = null, v = h.next(); null !== r && !v.done; w++, v = h.next()) {\n          r.index > w ? (p = r, r = null) : p = r.sibling;\n          var N = x(e, r, v.value, l);\n          if (null === N) {\n            null === r && (r = p);\n            break;\n          }\n          a && r && null === N.alternate && b(e, r);\n          g = f(N, g, w);\n          null === t ? k = N : t.sibling = N;\n          t = N;\n          r = p;\n        }\n        if (v.done) return c(e, r), k;\n        if (null === r) {\n          for (; !v.done; w++, v = h.next()) v = D(e, v.value, l), null !== v && (g = f(v, g, w), null === t ? k = v : t.sibling = v, t = v);\n          return k;\n        }\n        for (r = d(e, r); !v.done; w++, v = h.next()) v = K(r, e, w, v.value, l), null !== v && (a && null !== v.alternate && r.delete(null === v.key ? w : v.key), g = f(v, g, w), null === t ? k = v : t.sibling = v, t = v);\n        a && r.forEach(function (a) {\n          return b(e, a);\n        });\n        return k;\n      }\n      return function (a, d, f, h) {\n        var k = \"object\" === typeof f && null !== f && f.type === ea && null === f.key;\n        k && (f = f.props.children);\n        var l = \"object\" === typeof f && null !== f;\n        if (l) switch (f.$$typeof) {\n          case ca:\n            a: {\n              l = f.key;\n              for (k = d; null !== k;) {\n                if (k.key === l) {\n                  if (7 === k.tag ? f.type === ea : k.elementType === f.type) {\n                    c(a, k.sibling);\n                    d = e(k, f.type === ea ? f.props.children : f.props);\n                    d.ref = cd(a, k, f);\n                    d.return = a;\n                    a = d;\n                    break a;\n                  } else {\n                    c(a, k);\n                    break;\n                  }\n                } else b(a, k);\n                k = k.sibling;\n              }\n              f.type === ea ? (d = jd(f.props.children, a.mode, h, f.key), d.return = a, a = d) : (h = hd(f.type, f.key, f.props, null, a.mode, h), h.ref = cd(a, d, f), h.return = a, a = h);\n            }\n            return g(a);\n          case da:\n            a: {\n              for (k = f.key; null !== d;) {\n                if (d.key === k) {\n                  if (4 === d.tag && d.stateNode.containerInfo === f.containerInfo && d.stateNode.implementation === f.implementation) {\n                    c(a, d.sibling);\n                    d = e(d, f.children || []);\n                    d.return = a;\n                    a = d;\n                    break a;\n                  } else {\n                    c(a, d);\n                    break;\n                  }\n                } else b(a, d);\n                d = d.sibling;\n              }\n              d = id(f, a.mode, h);\n              d.return = a;\n              a = d;\n            }\n            return g(a);\n        }\n        if (\"string\" === typeof f || \"number\" === typeof f) return f = \"\" + f, null !== d && 6 === d.tag ? (c(a, d.sibling), d = e(d, f), d.return = a, a = d) : (c(a, d), d = gd(f, a.mode, h), d.return = a, a = d), g(a);\n        if (bd(f)) return Ha(a, d, f, h);\n        if (ra(f)) return O(a, d, f, h);\n        l && dd(a, f);\n        if (\"undefined\" === typeof f && !k) switch (a.tag) {\n          case 1:\n          case 0:\n            throw a = a.type, Error(n(152, a.displayName || a.name || \"Component\"));\n        }\n        return c(a, d);\n      };\n    }\n    var kd = ed(!0),\n      ld = ed(!1),\n      md = {},\n      H = {\n        current: md\n      },\n      nd = {\n        current: md\n      },\n      od = {\n        current: md\n      };\n    function pd(a) {\n      if (a === md) throw Error(n(174));\n      return a;\n    }\n    function qd(a, b) {\n      z(od, b);\n      z(nd, a);\n      z(H, md);\n      b = Aa(b);\n      y(H);\n      z(H, b);\n    }\n    function rd(a) {\n      y(H);\n      y(nd);\n      y(od);\n    }\n    function sd(a) {\n      var b = pd(od.current),\n        c = pd(H.current);\n      b = Ba(c, a.type, b);\n      c !== b && (z(nd, a), z(H, b));\n    }\n    function td(a) {\n      nd.current === a && (y(H), y(nd));\n    }\n    var I = {\n      current: 0\n    };\n    function ud(a) {\n      for (var b = a; null !== b;) {\n        if (13 === b.tag) {\n          var c = b.memoizedState;\n          if (null !== c && (c = c.dehydrated, null === c || qb(c) || rb(c))) return b;\n        } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {\n          if (0 !== (b.effectTag & 64)) return b;\n        } else if (null !== b.child) {\n          b.child.return = b;\n          b = b.child;\n          continue;\n        }\n        if (b === a) break;\n        for (; null === b.sibling;) {\n          if (null === b.return || b.return === a) return null;\n          b = b.return;\n        }\n        b.sibling.return = b.return;\n        b = b.sibling;\n      }\n      return null;\n    }\n    function vd(a, b) {\n      return {\n        responder: a,\n        props: b\n      };\n    }\n    var wd = q.ReactCurrentDispatcher,\n      J = q.ReactCurrentBatchConfig,\n      xd = 0,\n      yd = null,\n      L = null,\n      zd = null,\n      Ad = null,\n      M = null,\n      Bd = null,\n      Cd = 0,\n      Dd = null,\n      Ed = 0,\n      Fd = !1,\n      Gd = null,\n      Hd = 0;\n    function P() {\n      throw Error(n(321));\n    }\n    function Id(a, b) {\n      if (null === b) return !1;\n      for (var c = 0; c < b.length && c < a.length; c++) if (!oc(a[c], b[c])) return !1;\n      return !0;\n    }\n    function Jd(a, b, c, d, e, f) {\n      xd = f;\n      yd = b;\n      zd = null !== a ? a.memoizedState : null;\n      wd.current = null === zd ? Kd : Ld;\n      b = c(d, e);\n      if (Fd) {\n        do Fd = !1, Hd += 1, zd = null !== a ? a.memoizedState : null, Bd = Ad, Dd = M = L = null, wd.current = Ld, b = c(d, e); while (Fd);\n        Gd = null;\n        Hd = 0;\n      }\n      wd.current = Md;\n      a = yd;\n      a.memoizedState = Ad;\n      a.expirationTime = Cd;\n      a.updateQueue = Dd;\n      a.effectTag |= Ed;\n      a = null !== L && null !== L.next;\n      xd = 0;\n      Bd = M = Ad = zd = L = yd = null;\n      Cd = 0;\n      Dd = null;\n      Ed = 0;\n      if (a) throw Error(n(300));\n      return b;\n    }\n    function Nd() {\n      wd.current = Md;\n      xd = 0;\n      Bd = M = Ad = zd = L = yd = null;\n      Cd = 0;\n      Dd = null;\n      Ed = 0;\n      Fd = !1;\n      Gd = null;\n      Hd = 0;\n    }\n    function Od() {\n      var a = {\n        memoizedState: null,\n        baseState: null,\n        queue: null,\n        baseUpdate: null,\n        next: null\n      };\n      null === M ? Ad = M = a : M = M.next = a;\n      return M;\n    }\n    function Pd() {\n      if (null !== Bd) M = Bd, Bd = M.next, L = zd, zd = null !== L ? L.next : null;else {\n        if (null === zd) throw Error(n(310));\n        L = zd;\n        var a = {\n          memoizedState: L.memoizedState,\n          baseState: L.baseState,\n          queue: L.queue,\n          baseUpdate: L.baseUpdate,\n          next: null\n        };\n        M = null === M ? Ad = a : M.next = a;\n        zd = L.next;\n      }\n      return M;\n    }\n    function Qd(a, b) {\n      return \"function\" === typeof b ? b(a) : b;\n    }\n    function Rd(a) {\n      var b = Pd(),\n        c = b.queue;\n      if (null === c) throw Error(n(311));\n      c.lastRenderedReducer = a;\n      if (0 < Hd) {\n        var d = c.dispatch;\n        if (null !== Gd) {\n          var e = Gd.get(c);\n          if (void 0 !== e) {\n            Gd.delete(c);\n            var f = b.memoizedState;\n            do f = a(f, e.action), e = e.next; while (null !== e);\n            oc(f, b.memoizedState) || (Bc = !0);\n            b.memoizedState = f;\n            b.baseUpdate === c.last && (b.baseState = f);\n            c.lastRenderedState = f;\n            return [f, d];\n          }\n        }\n        return [b.memoizedState, d];\n      }\n      d = c.last;\n      var g = b.baseUpdate;\n      f = b.baseState;\n      null !== g ? (null !== d && (d.next = null), d = g.next) : d = null !== d ? d.next : null;\n      if (null !== d) {\n        var l = e = null,\n          h = d,\n          k = !1;\n        do {\n          var p = h.expirationTime;\n          p < xd ? (k || (k = !0, l = g, e = f), p > Cd && (Cd = p, Pc(Cd))) : (Oc(p, h.suspenseConfig), f = h.eagerReducer === a ? h.eagerState : a(f, h.action));\n          g = h;\n          h = h.next;\n        } while (null !== h && h !== d);\n        k || (l = g, e = f);\n        oc(f, b.memoizedState) || (Bc = !0);\n        b.memoizedState = f;\n        b.baseUpdate = l;\n        b.baseState = e;\n        c.lastRenderedState = f;\n      }\n      return [b.memoizedState, c.dispatch];\n    }\n    function Sd(a) {\n      var b = Od();\n      \"function\" === typeof a && (a = a());\n      b.memoizedState = b.baseState = a;\n      a = b.queue = {\n        last: null,\n        dispatch: null,\n        lastRenderedReducer: Qd,\n        lastRenderedState: a\n      };\n      a = a.dispatch = Td.bind(null, yd, a);\n      return [b.memoizedState, a];\n    }\n    function Ud(a) {\n      return Rd(Qd);\n    }\n    function Vd(a, b, c, d) {\n      a = {\n        tag: a,\n        create: b,\n        destroy: c,\n        deps: d,\n        next: null\n      };\n      null === Dd ? (Dd = {\n        lastEffect: null\n      }, Dd.lastEffect = a.next = a) : (b = Dd.lastEffect, null === b ? Dd.lastEffect = a.next = a : (c = b.next, b.next = a, a.next = c, Dd.lastEffect = a));\n      return a;\n    }\n    function Wd(a, b, c, d) {\n      var e = Od();\n      Ed |= a;\n      e.memoizedState = Vd(b, c, void 0, void 0 === d ? null : d);\n    }\n    function Xd(a, b, c, d) {\n      var e = Pd();\n      d = void 0 === d ? null : d;\n      var f = void 0;\n      if (null !== L) {\n        var g = L.memoizedState;\n        f = g.destroy;\n        if (null !== d && Id(d, g.deps)) {\n          Vd(0, c, f, d);\n          return;\n        }\n      }\n      Ed |= a;\n      e.memoizedState = Vd(b, c, f, d);\n    }\n    function Yd(a, b) {\n      return Wd(516, 192, a, b);\n    }\n    function Zd(a, b) {\n      return Xd(516, 192, a, b);\n    }\n    function $d(a, b) {\n      if (\"function\" === typeof b) return a = a(), b(a), function () {\n        b(null);\n      };\n      if (null !== b && void 0 !== b) return a = a(), b.current = a, function () {\n        b.current = null;\n      };\n    }\n    function ae() {}\n    function be(a, b) {\n      Od().memoizedState = [a, void 0 === b ? null : b];\n      return a;\n    }\n    function ce(a, b) {\n      var c = Pd();\n      b = void 0 === b ? null : b;\n      var d = c.memoizedState;\n      if (null !== d && null !== b && Id(b, d[1])) return d[0];\n      c.memoizedState = [a, b];\n      return a;\n    }\n    function Td(a, b, c) {\n      if (!(25 > Hd)) throw Error(n(301));\n      var d = a.alternate;\n      if (a === yd || null !== d && d === yd) {\n        if (Fd = !0, a = {\n          expirationTime: xd,\n          suspenseConfig: null,\n          action: c,\n          eagerReducer: null,\n          eagerState: null,\n          next: null\n        }, null === Gd && (Gd = new Map()), c = Gd.get(b), void 0 === c) Gd.set(b, a);else {\n          for (b = c; null !== b.next;) b = b.next;\n          b.next = a;\n        }\n      } else {\n        var e = G(),\n          f = Sc.suspense;\n        e = Vc(e, a, f);\n        f = {\n          expirationTime: e,\n          suspenseConfig: f,\n          action: c,\n          eagerReducer: null,\n          eagerState: null,\n          next: null\n        };\n        var g = b.last;\n        if (null === g) f.next = f;else {\n          var l = g.next;\n          null !== l && (f.next = l);\n          g.next = f;\n        }\n        b.last = f;\n        if (0 === a.expirationTime && (null === d || 0 === d.expirationTime) && (d = b.lastRenderedReducer, null !== d)) try {\n          var h = b.lastRenderedState,\n            k = d(h, c);\n          f.eagerReducer = d;\n          f.eagerState = k;\n          if (oc(k, h)) return;\n        } catch (p) {} finally {}\n        Wc(a, e);\n      }\n    }\n    var Md = {\n        readContext: Cc,\n        useCallback: P,\n        useContext: P,\n        useEffect: P,\n        useImperativeHandle: P,\n        useLayoutEffect: P,\n        useMemo: P,\n        useReducer: P,\n        useRef: P,\n        useState: P,\n        useDebugValue: P,\n        useResponder: P,\n        useDeferredValue: P,\n        useTransition: P\n      },\n      Kd = {\n        readContext: Cc,\n        useCallback: be,\n        useContext: Cc,\n        useEffect: Yd,\n        useImperativeHandle: function useImperativeHandle(a, b, c) {\n          c = null !== c && void 0 !== c ? c.concat([a]) : null;\n          return Wd(4, 36, $d.bind(null, b, a), c);\n        },\n        useLayoutEffect: function useLayoutEffect(a, b) {\n          return Wd(4, 36, a, b);\n        },\n        useMemo: function useMemo(a, b) {\n          var c = Od();\n          b = void 0 === b ? null : b;\n          a = a();\n          c.memoizedState = [a, b];\n          return a;\n        },\n        useReducer: function useReducer(a, b, c) {\n          var d = Od();\n          b = void 0 !== c ? c(b) : b;\n          d.memoizedState = d.baseState = b;\n          a = d.queue = {\n            last: null,\n            dispatch: null,\n            lastRenderedReducer: a,\n            lastRenderedState: b\n          };\n          a = a.dispatch = Td.bind(null, yd, a);\n          return [d.memoizedState, a];\n        },\n        useRef: function useRef(a) {\n          var b = Od();\n          a = {\n            current: a\n          };\n          return b.memoizedState = a;\n        },\n        useState: Sd,\n        useDebugValue: ae,\n        useResponder: vd,\n        useDeferredValue: function useDeferredValue(a, b) {\n          var c = Sd(a),\n            d = c[0],\n            e = c[1];\n          Yd(function () {\n            m.unstable_next(function () {\n              var c = J.suspense;\n              J.suspense = void 0 === b ? null : b;\n              try {\n                e(a);\n              } finally {\n                J.suspense = c;\n              }\n            });\n          }, [a, b]);\n          return d;\n        },\n        useTransition: function useTransition(a) {\n          var b = Sd(!1),\n            c = b[0],\n            d = b[1];\n          return [be(function (b) {\n            d(!0);\n            m.unstable_next(function () {\n              var c = J.suspense;\n              J.suspense = void 0 === a ? null : a;\n              try {\n                d(!1), b();\n              } finally {\n                J.suspense = c;\n              }\n            });\n          }, [a, c]), c];\n        }\n      },\n      Ld = {\n        readContext: Cc,\n        useCallback: ce,\n        useContext: Cc,\n        useEffect: Zd,\n        useImperativeHandle: function useImperativeHandle(a, b, c) {\n          c = null !== c && void 0 !== c ? c.concat([a]) : null;\n          return Xd(4, 36, $d.bind(null, b, a), c);\n        },\n        useLayoutEffect: function useLayoutEffect(a, b) {\n          return Xd(4, 36, a, b);\n        },\n        useMemo: function useMemo(a, b) {\n          var c = Pd();\n          b = void 0 === b ? null : b;\n          var d = c.memoizedState;\n          if (null !== d && null !== b && Id(b, d[1])) return d[0];\n          a = a();\n          c.memoizedState = [a, b];\n          return a;\n        },\n        useReducer: Rd,\n        useRef: function useRef() {\n          return Pd().memoizedState;\n        },\n        useState: Ud,\n        useDebugValue: ae,\n        useResponder: vd,\n        useDeferredValue: function useDeferredValue(a, b) {\n          var c = Ud(),\n            d = c[0],\n            e = c[1];\n          Zd(function () {\n            m.unstable_next(function () {\n              var c = J.suspense;\n              J.suspense = void 0 === b ? null : b;\n              try {\n                e(a);\n              } finally {\n                J.suspense = c;\n              }\n            });\n          }, [a, b]);\n          return d;\n        },\n        useTransition: function useTransition(a) {\n          var b = Ud(),\n            c = b[0],\n            d = b[1];\n          return [ce(function (b) {\n            d(!0);\n            m.unstable_next(function () {\n              var c = J.suspense;\n              J.suspense = void 0 === a ? null : a;\n              try {\n                d(!1), b();\n              } finally {\n                J.suspense = c;\n              }\n            });\n          }, [a, c]), c];\n        }\n      },\n      de = null,\n      ee = null,\n      fe = !1;\n    function ge(a, b) {\n      var c = he(5, null, null, 0);\n      c.elementType = \"DELETED\";\n      c.type = \"DELETED\";\n      c.stateNode = b;\n      c.return = a;\n      c.effectTag = 8;\n      null !== a.lastEffect ? (a.lastEffect.nextEffect = c, a.lastEffect = c) : a.firstEffect = a.lastEffect = c;\n    }\n    function ie(a, b) {\n      switch (a.tag) {\n        case 5:\n          return b = ob(b, a.type, a.pendingProps), null !== b ? (a.stateNode = b, !0) : !1;\n        case 6:\n          return b = pb(b, a.pendingProps), null !== b ? (a.stateNode = b, !0) : !1;\n        case 13:\n          return !1;\n        default:\n          return !1;\n      }\n    }\n    function je(a) {\n      if (fe) {\n        var b = ee;\n        if (b) {\n          var c = b;\n          if (!ie(a, b)) {\n            b = sb(c);\n            if (!b || !ie(a, b)) {\n              a.effectTag = a.effectTag & -1025 | 2;\n              fe = !1;\n              de = a;\n              return;\n            }\n            ge(de, c);\n          }\n          de = a;\n          ee = tb(b);\n        } else a.effectTag = a.effectTag & -1025 | 2, fe = !1, de = a;\n      }\n    }\n    function ke(a) {\n      for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag;) a = a.return;\n      de = a;\n    }\n    function ne(a) {\n      if (!Sa || a !== de) return !1;\n      if (!fe) return ke(a), fe = !0, !1;\n      var b = a.type;\n      if (5 !== a.tag || \"head\" !== b && \"body\" !== b && !Ja(b, a.memoizedProps)) for (b = ee; b;) ge(a, b), b = sb(b);\n      ke(a);\n      if (13 === a.tag) {\n        if (!Sa) throw Error(n(316));\n        a = a.memoizedState;\n        a = null !== a ? a.dehydrated : null;\n        if (!a) throw Error(n(317));\n        ee = wb(a);\n      } else ee = de ? sb(a.stateNode) : null;\n      return !0;\n    }\n    function oe() {\n      Sa && (ee = de = null, fe = !1);\n    }\n    var pe = q.ReactCurrentOwner,\n      Bc = !1;\n    function Q(a, b, c, d) {\n      b.child = null === a ? ld(b, null, c, d) : kd(b, a.child, c, d);\n    }\n    function qe(a, b, c, d, e) {\n      c = c.render;\n      var f = b.ref;\n      Ac(b, e);\n      d = Jd(a, b, c, d, f, e);\n      if (null !== a && !Bc) return b.updateQueue = a.updateQueue, b.effectTag &= -517, a.expirationTime <= e && (a.expirationTime = 0), re(a, b, e);\n      b.effectTag |= 1;\n      Q(a, b, d, e);\n      return b.child;\n    }\n    function se(a, b, c, d, e, f) {\n      if (null === a) {\n        var g = c.type;\n        if (\"function\" === typeof g && !te(g) && void 0 === g.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = g, ue(a, b, g, d, e, f);\n        a = hd(c.type, null, d, null, b.mode, f);\n        a.ref = b.ref;\n        a.return = b;\n        return b.child = a;\n      }\n      g = a.child;\n      if (e < f && (e = g.memoizedProps, c = c.compare, c = null !== c ? c : qc, c(e, d) && a.ref === b.ref)) return re(a, b, f);\n      b.effectTag |= 1;\n      a = fd(g, d);\n      a.ref = b.ref;\n      a.return = b;\n      return b.child = a;\n    }\n    function ue(a, b, c, d, e, f) {\n      return null !== a && qc(a.memoizedProps, d) && a.ref === b.ref && (Bc = !1, e < f) ? re(a, b, f) : ve(a, b, c, d, f);\n    }\n    function we(a, b) {\n      var c = b.ref;\n      if (null === a && null !== c || null !== a && a.ref !== c) b.effectTag |= 128;\n    }\n    function ve(a, b, c, d, e) {\n      var f = C(c) ? Eb : A.current;\n      f = Fb(b, f);\n      Ac(b, e);\n      c = Jd(a, b, c, d, f, e);\n      if (null !== a && !Bc) return b.updateQueue = a.updateQueue, b.effectTag &= -517, a.expirationTime <= e && (a.expirationTime = 0), re(a, b, e);\n      b.effectTag |= 1;\n      Q(a, b, c, e);\n      return b.child;\n    }\n    function xe(a, b, c, d, e) {\n      if (C(c)) {\n        var f = !0;\n        Kb(b);\n      } else f = !1;\n      Ac(b, e);\n      if (null === b.stateNode) null !== a && (a.alternate = null, b.alternate = null, b.effectTag |= 2), Zc(b, c, d), ad(b, c, d, e), d = !0;else if (null === a) {\n        var g = b.stateNode,\n          l = b.memoizedProps;\n        g.props = l;\n        var h = g.context,\n          k = c.contextType;\n        \"object\" === typeof k && null !== k ? k = Cc(k) : (k = C(c) ? Eb : A.current, k = Fb(b, k));\n        var p = c.getDerivedStateFromProps,\n          D = \"function\" === typeof p || \"function\" === typeof g.getSnapshotBeforeUpdate;\n        D || \"function\" !== typeof g.UNSAFE_componentWillReceiveProps && \"function\" !== typeof g.componentWillReceiveProps || (l !== d || h !== k) && $c(b, g, d, k);\n        Dc = !1;\n        var x = b.memoizedState;\n        h = g.state = x;\n        var K = b.updateQueue;\n        null !== K && (Nc(b, K, d, g, e), h = b.memoizedState);\n        l !== d || x !== h || B.current || Dc ? (\"function\" === typeof p && (Uc(b, c, p, d), h = b.memoizedState), (l = Dc || Yc(b, c, l, d, x, h, k)) ? (D || \"function\" !== typeof g.UNSAFE_componentWillMount && \"function\" !== typeof g.componentWillMount || (\"function\" === typeof g.componentWillMount && g.componentWillMount(), \"function\" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), \"function\" === typeof g.componentDidMount && (b.effectTag |= 4)) : (\"function\" === typeof g.componentDidMount && (b.effectTag |= 4), b.memoizedProps = d, b.memoizedState = h), g.props = d, g.state = h, g.context = k, d = l) : (\"function\" === typeof g.componentDidMount && (b.effectTag |= 4), d = !1);\n      } else g = b.stateNode, l = b.memoizedProps, g.props = b.type === b.elementType ? l : rc(b.type, l), h = g.context, k = c.contextType, \"object\" === typeof k && null !== k ? k = Cc(k) : (k = C(c) ? Eb : A.current, k = Fb(b, k)), p = c.getDerivedStateFromProps, (D = \"function\" === typeof p || \"function\" === typeof g.getSnapshotBeforeUpdate) || \"function\" !== typeof g.UNSAFE_componentWillReceiveProps && \"function\" !== typeof g.componentWillReceiveProps || (l !== d || h !== k) && $c(b, g, d, k), Dc = !1, h = b.memoizedState, x = g.state = h, K = b.updateQueue, null !== K && (Nc(b, K, d, g, e), x = b.memoizedState), l !== d || h !== x || B.current || Dc ? (\"function\" === typeof p && (Uc(b, c, p, d), x = b.memoizedState), (p = Dc || Yc(b, c, l, d, h, x, k)) ? (D || \"function\" !== typeof g.UNSAFE_componentWillUpdate && \"function\" !== typeof g.componentWillUpdate || (\"function\" === typeof g.componentWillUpdate && g.componentWillUpdate(d, x, k), \"function\" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, x, k)), \"function\" === typeof g.componentDidUpdate && (b.effectTag |= 4), \"function\" === typeof g.getSnapshotBeforeUpdate && (b.effectTag |= 256)) : (\"function\" !== typeof g.componentDidUpdate || l === a.memoizedProps && h === a.memoizedState || (b.effectTag |= 4), \"function\" !== typeof g.getSnapshotBeforeUpdate || l === a.memoizedProps && h === a.memoizedState || (b.effectTag |= 256), b.memoizedProps = d, b.memoizedState = x), g.props = d, g.state = x, g.context = k, d = p) : (\"function\" !== typeof g.componentDidUpdate || l === a.memoizedProps && h === a.memoizedState || (b.effectTag |= 4), \"function\" !== typeof g.getSnapshotBeforeUpdate || l === a.memoizedProps && h === a.memoizedState || (b.effectTag |= 256), d = !1);\n      return ye(a, b, c, d, f, e);\n    }\n    function ye(a, b, c, d, e, f) {\n      we(a, b);\n      var g = 0 !== (b.effectTag & 64);\n      if (!d && !g) return e && Lb(b, c, !1), re(a, b, f);\n      d = b.stateNode;\n      pe.current = b;\n      var l = g && \"function\" !== typeof c.getDerivedStateFromError ? null : d.render();\n      b.effectTag |= 1;\n      null !== a && g ? (b.child = kd(b, a.child, null, f), b.child = kd(b, null, l, f)) : Q(a, b, l, f);\n      b.memoizedState = d.state;\n      e && Lb(b, c, !0);\n      return b.child;\n    }\n    function ze(a) {\n      var b = a.stateNode;\n      b.pendingContext ? Ib(a, b.pendingContext, b.pendingContext !== b.context) : b.context && Ib(a, b.context, !1);\n      qd(a, b.containerInfo);\n    }\n    var Ae = {\n      dehydrated: null,\n      retryTime: 0\n    };\n    function Be(a, b, c) {\n      var d = b.mode,\n        e = b.pendingProps,\n        f = I.current,\n        g = !1,\n        l;\n      (l = 0 !== (b.effectTag & 64)) || (l = 0 !== (f & 2) && (null === a || null !== a.memoizedState));\n      l ? (g = !0, b.effectTag &= -65) : null !== a && null === a.memoizedState || void 0 === e.fallback || !0 === e.unstable_avoidThisFallback || (f |= 1);\n      z(I, f & 1);\n      if (null === a) {\n        void 0 !== e.fallback && je(b);\n        if (g) {\n          g = e.fallback;\n          e = jd(null, d, 0, null);\n          e.return = b;\n          if (0 === (b.mode & 2)) for (a = null !== b.memoizedState ? b.child.child : b.child, e.child = a; null !== a;) a.return = e, a = a.sibling;\n          c = jd(g, d, c, null);\n          c.return = b;\n          e.sibling = c;\n          b.memoizedState = Ae;\n          b.child = e;\n          return c;\n        }\n        d = e.children;\n        b.memoizedState = null;\n        return b.child = ld(b, null, d, c);\n      }\n      if (null !== a.memoizedState) {\n        a = a.child;\n        d = a.sibling;\n        if (g) {\n          e = e.fallback;\n          c = fd(a, a.pendingProps);\n          c.return = b;\n          if (0 === (b.mode & 2) && (g = null !== b.memoizedState ? b.child.child : b.child, g !== a.child)) for (c.child = g; null !== g;) g.return = c, g = g.sibling;\n          d = fd(d, e, d.expirationTime);\n          d.return = b;\n          c.sibling = d;\n          c.childExpirationTime = 0;\n          b.memoizedState = Ae;\n          b.child = c;\n          return d;\n        }\n        c = kd(b, a.child, e.children, c);\n        b.memoizedState = null;\n        return b.child = c;\n      }\n      a = a.child;\n      if (g) {\n        g = e.fallback;\n        e = jd(null, d, 0, null);\n        e.return = b;\n        e.child = a;\n        null !== a && (a.return = e);\n        if (0 === (b.mode & 2)) for (a = null !== b.memoizedState ? b.child.child : b.child, e.child = a; null !== a;) a.return = e, a = a.sibling;\n        c = jd(g, d, c, null);\n        c.return = b;\n        e.sibling = c;\n        c.effectTag |= 2;\n        e.childExpirationTime = 0;\n        b.memoizedState = Ae;\n        b.child = e;\n        return c;\n      }\n      b.memoizedState = null;\n      return b.child = kd(b, a, e.children, c);\n    }\n    function Ce(a, b) {\n      a.expirationTime < b && (a.expirationTime = b);\n      var c = a.alternate;\n      null !== c && c.expirationTime < b && (c.expirationTime = b);\n      zc(a.return, b);\n    }\n    function De(a, b, c, d, e, f) {\n      var g = a.memoizedState;\n      null === g ? a.memoizedState = {\n        isBackwards: b,\n        rendering: null,\n        last: d,\n        tail: c,\n        tailExpiration: 0,\n        tailMode: e,\n        lastEffect: f\n      } : (g.isBackwards = b, g.rendering = null, g.last = d, g.tail = c, g.tailExpiration = 0, g.tailMode = e, g.lastEffect = f);\n    }\n    function Ee(a, b, c) {\n      var d = b.pendingProps,\n        e = d.revealOrder,\n        f = d.tail;\n      Q(a, b, d.children, c);\n      d = I.current;\n      if (0 !== (d & 2)) d = d & 1 | 2, b.effectTag |= 64;else {\n        if (null !== a && 0 !== (a.effectTag & 64)) a: for (a = b.child; null !== a;) {\n          if (13 === a.tag) null !== a.memoizedState && Ce(a, c);else if (19 === a.tag) Ce(a, c);else if (null !== a.child) {\n            a.child.return = a;\n            a = a.child;\n            continue;\n          }\n          if (a === b) break a;\n          for (; null === a.sibling;) {\n            if (null === a.return || a.return === b) break a;\n            a = a.return;\n          }\n          a.sibling.return = a.return;\n          a = a.sibling;\n        }\n        d &= 1;\n      }\n      z(I, d);\n      if (0 === (b.mode & 2)) b.memoizedState = null;else switch (e) {\n        case \"forwards\":\n          c = b.child;\n          for (e = null; null !== c;) a = c.alternate, null !== a && null === ud(a) && (e = c), c = c.sibling;\n          c = e;\n          null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);\n          De(b, !1, e, c, f, b.lastEffect);\n          break;\n        case \"backwards\":\n          c = null;\n          e = b.child;\n          for (b.child = null; null !== e;) {\n            a = e.alternate;\n            if (null !== a && null === ud(a)) {\n              b.child = e;\n              break;\n            }\n            a = e.sibling;\n            e.sibling = c;\n            c = e;\n            e = a;\n          }\n          De(b, !0, c, null, f, b.lastEffect);\n          break;\n        case \"together\":\n          De(b, !1, null, null, void 0, b.lastEffect);\n          break;\n        default:\n          b.memoizedState = null;\n      }\n      return b.child;\n    }\n    function re(a, b, c) {\n      null !== a && (b.dependencies = a.dependencies);\n      var d = b.expirationTime;\n      0 !== d && Pc(d);\n      if (b.childExpirationTime < c) return null;\n      if (null !== a && b.child !== a.child) throw Error(n(153));\n      if (null !== b.child) {\n        a = b.child;\n        c = fd(a, a.pendingProps, a.expirationTime);\n        b.child = c;\n        for (c.return = b; null !== a.sibling;) a = a.sibling, c = c.sibling = fd(a, a.pendingProps, a.expirationTime), c.return = b;\n        c.sibling = null;\n      }\n      return b.child;\n    }\n    function Fe(a) {\n      a.effectTag |= 4;\n    }\n    var _Ge, He, Ie, Je;\n    if (Qa) _Ge = function Ge(a, b) {\n      for (var c = b.child; null !== c;) {\n        if (5 === c.tag || 6 === c.tag) Fa(a, c.stateNode);else if (4 !== c.tag && null !== c.child) {\n          c.child.return = c;\n          c = c.child;\n          continue;\n        }\n        if (c === b) break;\n        for (; null === c.sibling;) {\n          if (null === c.return || c.return === b) return;\n          c = c.return;\n        }\n        c.sibling.return = c.return;\n        c = c.sibling;\n      }\n    }, He = function He() {}, Ie = function Ie(a, b, c, d, e) {\n      a = a.memoizedProps;\n      if (a !== d) {\n        var f = b.stateNode,\n          g = pd(H.current);\n        c = Ia(f, c, a, d, e, g);\n        (b.updateQueue = c) && Fe(b);\n      }\n    }, Je = function Je(a, b, c, d) {\n      c !== d && Fe(b);\n    };else if (Ra) {\n      _Ge = function Ge(a, b, c, d) {\n        for (var e = b.child; null !== e;) {\n          if (5 === e.tag) {\n            var f = e.stateNode;\n            c && d && (f = mb(f, e.type, e.memoizedProps, e));\n            Fa(a, f);\n          } else if (6 === e.tag) f = e.stateNode, c && d && (f = nb(f, e.memoizedProps, e)), Fa(a, f);else if (4 !== e.tag) {\n            if (13 === e.tag && 0 !== (e.effectTag & 4) && (f = null !== e.memoizedState)) {\n              var g = e.child;\n              if (null !== g && (null !== g.child && (g.child.return = g, _Ge(a, g, !0, f)), f = g.sibling, null !== f)) {\n                f.return = e;\n                e = f;\n                continue;\n              }\n            }\n            if (null !== e.child) {\n              e.child.return = e;\n              e = e.child;\n              continue;\n            }\n          }\n          if (e === b) break;\n          for (; null === e.sibling;) {\n            if (null === e.return || e.return === b) return;\n            e = e.return;\n          }\n          e.sibling.return = e.return;\n          e = e.sibling;\n        }\n      };\n      var Ke = function Ke(a, b, c, d) {\n        for (var e = b.child; null !== e;) {\n          if (5 === e.tag) {\n            var f = e.stateNode;\n            c && d && (f = mb(f, e.type, e.memoizedProps, e));\n            ib(a, f);\n          } else if (6 === e.tag) f = e.stateNode, c && d && (f = nb(f, e.memoizedProps, e)), ib(a, f);else if (4 !== e.tag) {\n            if (13 === e.tag && 0 !== (e.effectTag & 4) && (f = null !== e.memoizedState)) {\n              var g = e.child;\n              if (null !== g && (null !== g.child && (g.child.return = g, Ke(a, g, !0, f)), f = g.sibling, null !== f)) {\n                f.return = e;\n                e = f;\n                continue;\n              }\n            }\n            if (null !== e.child) {\n              e.child.return = e;\n              e = e.child;\n              continue;\n            }\n          }\n          if (e === b) break;\n          for (; null === e.sibling;) {\n            if (null === e.return || e.return === b) return;\n            e = e.return;\n          }\n          e.sibling.return = e.return;\n          e = e.sibling;\n        }\n      };\n      He = function He(a) {\n        var b = a.stateNode;\n        if (null !== a.firstEffect) {\n          var c = b.containerInfo,\n            d = hb(c);\n          Ke(d, a, !1, !1);\n          b.pendingChildren = d;\n          Fe(a);\n          kb(c, d);\n        }\n      };\n      Ie = function Ie(a, b, c, d, e) {\n        var f = a.stateNode,\n          g = a.memoizedProps;\n        if ((a = null === b.firstEffect) && g === d) b.stateNode = f;else {\n          var l = b.stateNode,\n            h = pd(H.current),\n            k = null;\n          g !== d && (k = Ia(l, c, g, d, e, h));\n          a && null === k ? b.stateNode = f : (f = gb(f, k, c, g, d, b, a, l), Ga(f, c, d, e, h) && Fe(b), b.stateNode = f, a ? Fe(b) : _Ge(f, b, !1, !1));\n        }\n      };\n      Je = function Je(a, b, c, d) {\n        c !== d && (a = pd(od.current), c = pd(H.current), b.stateNode = La(d, a, c, b), Fe(b));\n      };\n    } else He = function He() {}, Ie = function Ie() {}, Je = function Je() {};\n    function Le(a, b) {\n      switch (a.tailMode) {\n        case \"hidden\":\n          b = a.tail;\n          for (var c = null; null !== b;) null !== b.alternate && (c = b), b = b.sibling;\n          null === c ? a.tail = null : c.sibling = null;\n          break;\n        case \"collapsed\":\n          c = a.tail;\n          for (var d = null; null !== c;) null !== c.alternate && (d = c), c = c.sibling;\n          null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;\n      }\n    }\n    function Me(a) {\n      switch (a.tag) {\n        case 1:\n          C(a.type) && Gb();\n          var b = a.effectTag;\n          return b & 4096 ? (a.effectTag = b & -4097 | 64, a) : null;\n        case 3:\n          rd();\n          Hb();\n          b = a.effectTag;\n          if (0 !== (b & 64)) throw Error(n(285));\n          a.effectTag = b & -4097 | 64;\n          return a;\n        case 5:\n          return td(a), null;\n        case 13:\n          return y(I), b = a.effectTag, b & 4096 ? (a.effectTag = b & -4097 | 64, a) : null;\n        case 19:\n          return y(I), null;\n        case 4:\n          return rd(), null;\n        case 10:\n          return yc(a), null;\n        default:\n          return null;\n      }\n    }\n    function Ne(a, b) {\n      return {\n        value: a,\n        source: b,\n        stack: Ab(b)\n      };\n    }\n    var Oe = \"function\" === typeof WeakSet ? WeakSet : Set;\n    function Pe(a, b) {\n      var c = b.source,\n        d = b.stack;\n      null === d && null !== c && (d = Ab(c));\n      null !== c && ta(c.type);\n      b = b.value;\n      null !== a && 1 === a.tag && ta(a.type);\n      try {\n        console.error(b);\n      } catch (e) {\n        setTimeout(function () {\n          throw e;\n        });\n      }\n    }\n    function Qe(a, b) {\n      try {\n        b.props = a.memoizedProps, b.state = a.memoizedState, b.componentWillUnmount();\n      } catch (c) {\n        Re(a, c);\n      }\n    }\n    function Se(a) {\n      var b = a.ref;\n      if (null !== b) if (\"function\" === typeof b) try {\n        b(null);\n      } catch (c) {\n        Re(a, c);\n      } else b.current = null;\n    }\n    function Te(a, b) {\n      switch (b.tag) {\n        case 0:\n        case 11:\n        case 15:\n          Ue(2, 0, b);\n          break;\n        case 1:\n          if (b.effectTag & 256 && null !== a) {\n            var c = a.memoizedProps,\n              d = a.memoizedState;\n            a = b.stateNode;\n            b = a.getSnapshotBeforeUpdate(b.elementType === b.type ? c : rc(b.type, c), d);\n            a.__reactInternalSnapshotBeforeUpdate = b;\n          }\n          break;\n        case 3:\n        case 5:\n        case 6:\n        case 4:\n        case 17:\n          break;\n        default:\n          throw Error(n(163));\n      }\n    }\n    function Ue(a, b, c) {\n      c = c.updateQueue;\n      c = null !== c ? c.lastEffect : null;\n      if (null !== c) {\n        var d = c = c.next;\n        do {\n          if (0 !== (d.tag & a)) {\n            var e = d.destroy;\n            d.destroy = void 0;\n            void 0 !== e && e();\n          }\n          0 !== (d.tag & b) && (e = d.create, d.destroy = e());\n          d = d.next;\n        } while (d !== c);\n      }\n    }\n    function Ve(a, b, c) {\n      \"function\" === typeof We && We(b);\n      switch (b.tag) {\n        case 0:\n        case 11:\n        case 14:\n        case 15:\n          a = b.updateQueue;\n          if (null !== a && (a = a.lastEffect, null !== a)) {\n            var d = a.next;\n            hc(97 < c ? 97 : c, function () {\n              var a = d;\n              do {\n                var c = a.destroy;\n                if (void 0 !== c) {\n                  var g = b;\n                  try {\n                    c();\n                  } catch (l) {\n                    Re(g, l);\n                  }\n                }\n                a = a.next;\n              } while (a !== d);\n            });\n          }\n          break;\n        case 1:\n          Se(b);\n          c = b.stateNode;\n          \"function\" === typeof c.componentWillUnmount && Qe(b, c);\n          break;\n        case 5:\n          Se(b);\n          break;\n        case 4:\n          Qa ? Xe(a, b, c) : Ra && Ye(b);\n      }\n    }\n    function Ze(a, b, c) {\n      for (var d = b;;) if (Ve(a, d, c), null === d.child || Qa && 4 === d.tag) {\n        if (d === b) break;\n        for (; null === d.sibling;) {\n          if (null === d.return || d.return === b) return;\n          d = d.return;\n        }\n        d.sibling.return = d.return;\n        d = d.sibling;\n      } else d.child.return = d, d = d.child;\n    }\n    function $e(a) {\n      var b = a.alternate;\n      a.return = null;\n      a.child = null;\n      a.memoizedState = null;\n      a.updateQueue = null;\n      a.dependencies = null;\n      a.alternate = null;\n      a.firstEffect = null;\n      a.lastEffect = null;\n      a.pendingProps = null;\n      a.memoizedProps = null;\n      null !== b && $e(b);\n    }\n    function Ye(a) {\n      if (Ra) {\n        a = a.stateNode.containerInfo;\n        var b = hb(a);\n        lb(a, b);\n      }\n    }\n    function af(a) {\n      return 5 === a.tag || 3 === a.tag || 4 === a.tag;\n    }\n    function bf(a) {\n      if (Qa) {\n        a: {\n          for (var b = a.return; null !== b;) {\n            if (af(b)) {\n              var c = b;\n              break a;\n            }\n            b = b.return;\n          }\n          throw Error(n(160));\n        }\n        b = c.stateNode;\n        switch (c.tag) {\n          case 5:\n            var d = !1;\n            break;\n          case 3:\n            b = b.containerInfo;\n            d = !0;\n            break;\n          case 4:\n            b = b.containerInfo;\n            d = !0;\n            break;\n          default:\n            throw Error(n(161));\n        }\n        c.effectTag & 16 && (bb(b), c.effectTag &= -17);\n        a: b: for (c = a;;) {\n          for (; null === c.sibling;) {\n            if (null === c.return || af(c.return)) {\n              c = null;\n              break a;\n            }\n            c = c.return;\n          }\n          c.sibling.return = c.return;\n          for (c = c.sibling; 5 !== c.tag && 6 !== c.tag && 18 !== c.tag;) {\n            if (c.effectTag & 2) continue b;\n            if (null === c.child || 4 === c.tag) continue b;else c.child.return = c, c = c.child;\n          }\n          if (!(c.effectTag & 2)) {\n            c = c.stateNode;\n            break a;\n          }\n        }\n        for (var e = a;;) {\n          var f = 5 === e.tag || 6 === e.tag;\n          if (f) f = f ? e.stateNode : e.stateNode.instance, c ? d ? Za(b, f, c) : Ya(b, f, c) : d ? Ua(b, f) : Ta(b, f);else if (4 !== e.tag && null !== e.child) {\n            e.child.return = e;\n            e = e.child;\n            continue;\n          }\n          if (e === a) break;\n          for (; null === e.sibling;) {\n            if (null === e.return || e.return === a) return;\n            e = e.return;\n          }\n          e.sibling.return = e.return;\n          e = e.sibling;\n        }\n      }\n    }\n    function Xe(a, b, c) {\n      for (var d = b, e = !1, f, g;;) {\n        if (!e) {\n          e = d.return;\n          a: for (;;) {\n            if (null === e) throw Error(n(160));\n            f = e.stateNode;\n            switch (e.tag) {\n              case 5:\n                g = !1;\n                break a;\n              case 3:\n                f = f.containerInfo;\n                g = !0;\n                break a;\n              case 4:\n                f = f.containerInfo;\n                g = !0;\n                break a;\n            }\n            e = e.return;\n          }\n          e = !0;\n        }\n        if (5 === d.tag || 6 === d.tag) Ze(a, d, c), g ? ab(f, d.stateNode) : $a(f, d.stateNode);else if (4 === d.tag) {\n          if (null !== d.child) {\n            f = d.stateNode.containerInfo;\n            g = !0;\n            d.child.return = d;\n            d = d.child;\n            continue;\n          }\n        } else if (Ve(a, d, c), null !== d.child) {\n          d.child.return = d;\n          d = d.child;\n          continue;\n        }\n        if (d === b) break;\n        for (; null === d.sibling;) {\n          if (null === d.return || d.return === b) return;\n          d = d.return;\n          4 === d.tag && (e = !1);\n        }\n        d.sibling.return = d.return;\n        d = d.sibling;\n      }\n    }\n    function cf(a, b) {\n      if (Qa) switch (b.tag) {\n        case 0:\n        case 11:\n        case 14:\n        case 15:\n          Ue(4, 8, b);\n          break;\n        case 1:\n          break;\n        case 5:\n          var c = b.stateNode;\n          if (null != c) {\n            var d = b.memoizedProps;\n            a = null !== a ? a.memoizedProps : d;\n            var e = b.type,\n              f = b.updateQueue;\n            b.updateQueue = null;\n            null !== f && Xa(c, f, e, a, d, b);\n          }\n          break;\n        case 6:\n          if (null === b.stateNode) throw Error(n(162));\n          c = b.memoizedProps;\n          Va(b.stateNode, null !== a ? a.memoizedProps : c, c);\n          break;\n        case 3:\n          Sa && (b = b.stateNode, b.hydrate && (b.hydrate = !1, xb(b.containerInfo)));\n          break;\n        case 12:\n          break;\n        case 13:\n          df(b);\n          ef(b);\n          break;\n        case 19:\n          ef(b);\n          break;\n        case 17:\n          break;\n        case 20:\n          break;\n        case 21:\n          break;\n        default:\n          throw Error(n(163));\n      } else {\n        switch (b.tag) {\n          case 0:\n          case 11:\n          case 14:\n          case 15:\n            Ue(4, 8, b);\n            return;\n          case 12:\n            return;\n          case 13:\n            df(b);\n            ef(b);\n            return;\n          case 19:\n            ef(b);\n            return;\n          case 3:\n            Sa && (c = b.stateNode, c.hydrate && (c.hydrate = !1, xb(c.containerInfo)));\n        }\n        a: if (Ra) switch (b.tag) {\n          case 1:\n          case 5:\n          case 6:\n          case 20:\n            break a;\n          case 3:\n          case 4:\n            b = b.stateNode;\n            lb(b.containerInfo, b.pendingChildren);\n            break a;\n          default:\n            throw Error(n(163));\n        }\n      }\n    }\n    function df(a) {\n      var b = a;\n      if (null === a.memoizedState) var c = !1;else c = !0, b = a.child, ff = E();\n      if (Qa && null !== b) a: if (a = b, Qa) for (b = a;;) {\n        if (5 === b.tag) {\n          var d = b.stateNode;\n          c ? cb(d) : eb(b.stateNode, b.memoizedProps);\n        } else if (6 === b.tag) d = b.stateNode, c ? db(d) : fb(d, b.memoizedProps);else if (13 === b.tag && null !== b.memoizedState && null === b.memoizedState.dehydrated) {\n          d = b.child.sibling;\n          d.return = b;\n          b = d;\n          continue;\n        } else if (null !== b.child) {\n          b.child.return = b;\n          b = b.child;\n          continue;\n        }\n        if (b === a) break a;\n        for (; null === b.sibling;) {\n          if (null === b.return || b.return === a) break a;\n          b = b.return;\n        }\n        b.sibling.return = b.return;\n        b = b.sibling;\n      }\n    }\n    function ef(a) {\n      var b = a.updateQueue;\n      if (null !== b) {\n        a.updateQueue = null;\n        var c = a.stateNode;\n        null === c && (c = a.stateNode = new Oe());\n        b.forEach(function (b) {\n          var d = gf.bind(null, a, b);\n          c.has(b) || (c.add(b), b.then(d, d));\n        });\n      }\n    }\n    var hf = \"function\" === typeof WeakMap ? WeakMap : Map;\n    function jf(a, b, c) {\n      c = Gc(c, null);\n      c.tag = 3;\n      c.payload = {\n        element: null\n      };\n      var d = b.value;\n      c.callback = function () {\n        kf || (kf = !0, lf = d);\n        Pe(a, b);\n      };\n      return c;\n    }\n    function mf(a, b, c) {\n      c = Gc(c, null);\n      c.tag = 3;\n      var d = a.type.getDerivedStateFromError;\n      if (\"function\" === typeof d) {\n        var e = b.value;\n        c.payload = function () {\n          Pe(a, b);\n          return d(e);\n        };\n      }\n      var f = a.stateNode;\n      null !== f && \"function\" === typeof f.componentDidCatch && (c.callback = function () {\n        \"function\" !== typeof d && (null === nf ? nf = new Set([this]) : nf.add(this), Pe(a, b));\n        var c = b.stack;\n        this.componentDidCatch(b.value, {\n          componentStack: null !== c ? c : \"\"\n        });\n      });\n      return c;\n    }\n    var of = Math.ceil,\n      pf = q.ReactCurrentDispatcher,\n      qf = q.ReactCurrentOwner,\n      R = 0,\n      rf = 8,\n      S = 16,\n      sf = 32,\n      tf = 0,\n      uf = 1,\n      vf = 2,\n      wf = 3,\n      xf = 4,\n      yf = 5,\n      T = R,\n      U = null,\n      V = null,\n      W = 0,\n      X = tf,\n      zf = null,\n      Af = 1073741823,\n      Bf = 1073741823,\n      Cf = null,\n      Df = 0,\n      Ef = !1,\n      ff = 0,\n      Ff = 500,\n      Y = null,\n      kf = !1,\n      lf = null,\n      nf = null,\n      Gf = !1,\n      Hf = null,\n      If = 90,\n      Jf = null,\n      Kf = 0,\n      Lf = null,\n      Mf = 0;\n    function G() {\n      return (T & (S | sf)) !== R ? 1073741821 - (E() / 10 | 0) : 0 !== Mf ? Mf : Mf = 1073741821 - (E() / 10 | 0);\n    }\n    function Vc(a, b, c) {\n      b = b.mode;\n      if (0 === (b & 2)) return 1073741823;\n      var d = fc();\n      if (0 === (b & 4)) return 99 === d ? 1073741823 : 1073741822;\n      if ((T & S) !== R) return W;\n      if (null !== c) a = mc(a, c.timeoutMs | 0 || 5E3, 250);else switch (d) {\n        case 99:\n          a = 1073741823;\n          break;\n        case 98:\n          a = mc(a, 150, 100);\n          break;\n        case 97:\n        case 96:\n          a = mc(a, 5E3, 250);\n          break;\n        case 95:\n          a = 2;\n          break;\n        default:\n          throw Error(n(326));\n      }\n      null !== U && a === W && --a;\n      return a;\n    }\n    function Wc(a, b) {\n      if (50 < Kf) throw Kf = 0, Lf = null, Error(n(185));\n      a = Nf(a, b);\n      if (null !== a) {\n        var c = fc();\n        1073741823 === b ? (T & rf) !== R && (T & (S | sf)) === R ? Of(a) : (Z(a), T === R && F()) : Z(a);\n        (T & 4) === R || 98 !== c && 99 !== c || (null === Jf ? Jf = new Map([[a, b]]) : (c = Jf.get(a), (void 0 === c || c > b) && Jf.set(a, b)));\n      }\n    }\n    function Nf(a, b) {\n      a.expirationTime < b && (a.expirationTime = b);\n      var c = a.alternate;\n      null !== c && c.expirationTime < b && (c.expirationTime = b);\n      var d = a.return,\n        e = null;\n      if (null === d && 3 === a.tag) e = a.stateNode;else for (; null !== d;) {\n        c = d.alternate;\n        d.childExpirationTime < b && (d.childExpirationTime = b);\n        null !== c && c.childExpirationTime < b && (c.childExpirationTime = b);\n        if (null === d.return && 3 === d.tag) {\n          e = d.stateNode;\n          break;\n        }\n        d = d.return;\n      }\n      null !== e && (U === e && (Pc(b), X === xf && Pf(e, W)), Qf(e, b));\n      return e;\n    }\n    function Rf(a) {\n      var b = a.lastExpiredTime;\n      if (0 !== b) return b;\n      b = a.firstPendingTime;\n      if (!Sf(a, b)) return b;\n      b = a.lastPingedTime;\n      a = a.nextKnownPendingLevel;\n      return b > a ? b : a;\n    }\n    function Z(a) {\n      if (0 !== a.lastExpiredTime) a.callbackExpirationTime = 1073741823, a.callbackPriority = 99, a.callbackNode = jc(Of.bind(null, a));else {\n        var b = Rf(a),\n          c = a.callbackNode;\n        if (0 === b) null !== c && (a.callbackNode = null, a.callbackExpirationTime = 0, a.callbackPriority = 90);else {\n          var d = G();\n          1073741823 === b ? d = 99 : 1 === b || 2 === b ? d = 95 : (d = 10 * (1073741821 - b) - 10 * (1073741821 - d), d = 0 >= d ? 99 : 250 >= d ? 98 : 5250 >= d ? 97 : 95);\n          if (null !== c) {\n            var e = a.callbackPriority;\n            if (a.callbackExpirationTime === b && e >= d) return;\n            c !== $b && Ob(c);\n          }\n          a.callbackExpirationTime = b;\n          a.callbackPriority = d;\n          b = 1073741823 === b ? jc(Of.bind(null, a)) : ic(d, Tf.bind(null, a), {\n            timeout: 10 * (1073741821 - b) - E()\n          });\n          a.callbackNode = b;\n        }\n      }\n    }\n    function Tf(a, b) {\n      Mf = 0;\n      if (b) return b = G(), Uf(a, b), Z(a), null;\n      var c = Rf(a);\n      if (0 !== c) {\n        b = a.callbackNode;\n        if ((T & (S | sf)) !== R) throw Error(n(327));\n        Vf();\n        a === U && c === W || Wf(a, c);\n        if (null !== V) {\n          var d = T;\n          T |= S;\n          var e = Xf();\n          do try {\n            Yf();\n            break;\n          } catch (l) {\n            Zf(a, l);\n          } while (1);\n          wc();\n          T = d;\n          pf.current = e;\n          if (X === uf) throw b = zf, Wf(a, c), Pf(a, c), Z(a), b;\n          if (null === V) switch (e = a.finishedWork = a.current.alternate, a.finishedExpirationTime = c, d = X, U = null, d) {\n            case tf:\n            case uf:\n              throw Error(n(345));\n            case vf:\n              Uf(a, 2 < c ? 2 : c);\n              break;\n            case wf:\n              Pf(a, c);\n              d = a.lastSuspendedTime;\n              c === d && (a.nextKnownPendingLevel = $f(e));\n              if (1073741823 === Af && (e = ff + Ff - E(), 10 < e)) {\n                if (Ef) {\n                  var f = a.lastPingedTime;\n                  if (0 === f || f >= c) {\n                    a.lastPingedTime = c;\n                    Wf(a, c);\n                    break;\n                  }\n                }\n                f = Rf(a);\n                if (0 !== f && f !== c) break;\n                if (0 !== d && d !== c) {\n                  a.lastPingedTime = d;\n                  break;\n                }\n                a.timeoutHandle = Ma(ag.bind(null, a), e);\n                break;\n              }\n              ag(a);\n              break;\n            case xf:\n              Pf(a, c);\n              d = a.lastSuspendedTime;\n              c === d && (a.nextKnownPendingLevel = $f(e));\n              if (Ef && (e = a.lastPingedTime, 0 === e || e >= c)) {\n                a.lastPingedTime = c;\n                Wf(a, c);\n                break;\n              }\n              e = Rf(a);\n              if (0 !== e && e !== c) break;\n              if (0 !== d && d !== c) {\n                a.lastPingedTime = d;\n                break;\n              }\n              1073741823 !== Bf ? d = 10 * (1073741821 - Bf) - E() : 1073741823 === Af ? d = 0 : (d = 10 * (1073741821 - Af) - 5E3, e = E(), c = 10 * (1073741821 - c) - e, d = e - d, 0 > d && (d = 0), d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3E3 > d ? 3E3 : 4320 > d ? 4320 : 1960 * of(d / 1960)) - d, c < d && (d = c));\n              if (10 < d) {\n                a.timeoutHandle = Ma(ag.bind(null, a), d);\n                break;\n              }\n              ag(a);\n              break;\n            case yf:\n              if (1073741823 !== Af && null !== Cf) {\n                f = Af;\n                var g = Cf;\n                d = g.busyMinDurationMs | 0;\n                0 >= d ? d = 0 : (e = g.busyDelayMs | 0, f = E() - (10 * (1073741821 - f) - (g.timeoutMs | 0 || 5E3)), d = f <= e ? 0 : e + d - f);\n                if (10 < d) {\n                  Pf(a, c);\n                  a.timeoutHandle = Ma(ag.bind(null, a), d);\n                  break;\n                }\n              }\n              ag(a);\n              break;\n            default:\n              throw Error(n(329));\n          }\n          Z(a);\n          if (a.callbackNode === b) return Tf.bind(null, a);\n        }\n      }\n      return null;\n    }\n    function Of(a) {\n      var b = a.lastExpiredTime;\n      b = 0 !== b ? b : 1073741823;\n      if (a.finishedExpirationTime === b) ag(a);else {\n        if ((T & (S | sf)) !== R) throw Error(n(327));\n        Vf();\n        a === U && b === W || Wf(a, b);\n        if (null !== V) {\n          var c = T;\n          T |= S;\n          var d = Xf();\n          do try {\n            bg();\n            break;\n          } catch (e) {\n            Zf(a, e);\n          } while (1);\n          wc();\n          T = c;\n          pf.current = d;\n          if (X === uf) throw c = zf, Wf(a, b), Pf(a, b), Z(a), c;\n          if (null !== V) throw Error(n(261));\n          a.finishedWork = a.current.alternate;\n          a.finishedExpirationTime = b;\n          U = null;\n          ag(a);\n          Z(a);\n        }\n      }\n      return null;\n    }\n    function cg(a, b) {\n      Uf(a, b);\n      Z(a);\n      (T & (S | sf)) === R && F();\n    }\n    function dg() {\n      if (null !== Jf) {\n        var a = Jf;\n        Jf = null;\n        a.forEach(function (a, c) {\n          Uf(c, a);\n          Z(c);\n        });\n        F();\n      }\n    }\n    function eg(a, b) {\n      if ((T & (S | sf)) !== R) throw Error(n(187));\n      var c = T;\n      T |= 1;\n      try {\n        return hc(99, a.bind(null, b));\n      } finally {\n        T = c, F();\n      }\n    }\n    function Wf(a, b) {\n      a.finishedWork = null;\n      a.finishedExpirationTime = 0;\n      var c = a.timeoutHandle;\n      c !== Oa && (a.timeoutHandle = Oa, Na(c));\n      if (null !== V) for (c = V.return; null !== c;) {\n        var d = c;\n        switch (d.tag) {\n          case 1:\n            var e = d.type.childContextTypes;\n            null !== e && void 0 !== e && Gb();\n            break;\n          case 3:\n            rd();\n            Hb();\n            break;\n          case 5:\n            td(d);\n            break;\n          case 4:\n            rd();\n            break;\n          case 13:\n            y(I);\n            break;\n          case 19:\n            y(I);\n            break;\n          case 10:\n            yc(d);\n        }\n        c = c.return;\n      }\n      U = a;\n      V = fd(a.current, null);\n      W = b;\n      X = tf;\n      zf = null;\n      Bf = Af = 1073741823;\n      Cf = null;\n      Df = 0;\n      Ef = !1;\n    }\n    function Zf(a, b) {\n      do {\n        try {\n          wc();\n          Nd();\n          if (null === V || null === V.return) return X = uf, zf = b, null;\n          a: {\n            var c = a,\n              d = V.return,\n              e = V,\n              f = b;\n            b = W;\n            e.effectTag |= 2048;\n            e.firstEffect = e.lastEffect = null;\n            if (null !== f && \"object\" === typeof f && \"function\" === typeof f.then) {\n              var g = f,\n                l = 0 !== (I.current & 1),\n                h = d;\n              do {\n                var k;\n                if (k = 13 === h.tag) {\n                  var p = h.memoizedState;\n                  if (null !== p) k = null !== p.dehydrated ? !0 : !1;else {\n                    var D = h.memoizedProps;\n                    k = void 0 === D.fallback ? !1 : !0 !== D.unstable_avoidThisFallback ? !0 : l ? !1 : !0;\n                  }\n                }\n                if (k) {\n                  var x = h.updateQueue;\n                  if (null === x) {\n                    var K = new Set();\n                    K.add(g);\n                    h.updateQueue = K;\n                  } else x.add(g);\n                  if (0 === (h.mode & 2)) {\n                    h.effectTag |= 64;\n                    e.effectTag &= -2981;\n                    if (1 === e.tag) if (null === e.alternate) e.tag = 17;else {\n                      var Ha = Gc(1073741823, null);\n                      Ha.tag = 2;\n                      Ic(e, Ha);\n                    }\n                    e.expirationTime = 1073741823;\n                    break a;\n                  }\n                  f = void 0;\n                  e = b;\n                  var O = c.pingCache;\n                  null === O ? (O = c.pingCache = new hf(), f = new Set(), O.set(g, f)) : (f = O.get(g), void 0 === f && (f = new Set(), O.set(g, f)));\n                  if (!f.has(e)) {\n                    f.add(e);\n                    var w = fg.bind(null, c, g, e);\n                    g.then(w, w);\n                  }\n                  h.effectTag |= 4096;\n                  h.expirationTime = b;\n                  break a;\n                }\n                h = h.return;\n              } while (null !== h);\n              f = Error((ta(e.type) || \"A React component\") + \" suspended while rendering, but no fallback UI was specified.\\n\\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.\" + Ab(e));\n            }\n            X !== yf && (X = vf);\n            f = Ne(f, e);\n            h = d;\n            do {\n              switch (h.tag) {\n                case 3:\n                  g = f;\n                  h.effectTag |= 4096;\n                  h.expirationTime = b;\n                  var r = jf(h, g, b);\n                  Jc(h, r);\n                  break a;\n                case 1:\n                  g = f;\n                  var t = h.type,\n                    N = h.stateNode;\n                  if (0 === (h.effectTag & 64) && (\"function\" === typeof t.getDerivedStateFromError || null !== N && \"function\" === typeof N.componentDidCatch && (null === nf || !nf.has(N)))) {\n                    h.effectTag |= 4096;\n                    h.expirationTime = b;\n                    var Mc = mf(h, g, b);\n                    Jc(h, Mc);\n                    break a;\n                  }\n              }\n              h = h.return;\n            } while (null !== h);\n          }\n          V = gg(V);\n        } catch (Rb) {\n          b = Rb;\n          continue;\n        }\n        break;\n      } while (1);\n    }\n    function Xf() {\n      var a = pf.current;\n      pf.current = Md;\n      return null === a ? Md : a;\n    }\n    function Oc(a, b) {\n      a < Af && 2 < a && (Af = a);\n      null !== b && a < Bf && 2 < a && (Bf = a, Cf = b);\n    }\n    function Pc(a) {\n      a > Df && (Df = a);\n    }\n    function bg() {\n      for (; null !== V;) V = hg(V);\n    }\n    function Yf() {\n      for (; null !== V && !Pb();) V = hg(V);\n    }\n    function hg(a) {\n      var b = ig(a.alternate, a, W);\n      a.memoizedProps = a.pendingProps;\n      null === b && (b = gg(a));\n      qf.current = null;\n      return b;\n    }\n    function gg(a) {\n      V = a;\n      do {\n        var b = V.alternate;\n        a = V.return;\n        if (0 === (V.effectTag & 2048)) {\n          a: {\n            var c = b;\n            b = V;\n            var d = W,\n              e = b.pendingProps;\n            switch (b.tag) {\n              case 2:\n                break;\n              case 16:\n                break;\n              case 15:\n              case 0:\n                break;\n              case 1:\n                C(b.type) && Gb();\n                break;\n              case 3:\n                rd();\n                Hb();\n                e = b.stateNode;\n                e.pendingContext && (e.context = e.pendingContext, e.pendingContext = null);\n                (null === c || null === c.child) && ne(b) && Fe(b);\n                He(b);\n                break;\n              case 5:\n                td(b);\n                var f = pd(od.current);\n                d = b.type;\n                if (null !== c && null != b.stateNode) Ie(c, b, d, e, f), c.ref !== b.ref && (b.effectTag |= 128);else if (e) {\n                  c = pd(H.current);\n                  if (ne(b)) {\n                    e = b;\n                    if (!Sa) throw Error(n(175));\n                    c = ub(e.stateNode, e.type, e.memoizedProps, f, c, e);\n                    e.updateQueue = c;\n                    c = null !== c ? !0 : !1;\n                    c && Fe(b);\n                  } else {\n                    var g = Ea(d, e, f, c, b);\n                    _Ge(g, b, !1, !1);\n                    b.stateNode = g;\n                    Ga(g, d, e, f, c) && Fe(b);\n                  }\n                  null !== b.ref && (b.effectTag |= 128);\n                } else if (null === b.stateNode) throw Error(n(166));\n                break;\n              case 6:\n                if (c && null != b.stateNode) Je(c, b, c.memoizedProps, e);else {\n                  if (\"string\" !== typeof e && null === b.stateNode) throw Error(n(166));\n                  c = pd(od.current);\n                  f = pd(H.current);\n                  if (ne(b)) {\n                    c = b;\n                    if (!Sa) throw Error(n(176));\n                    (c = vb(c.stateNode, c.memoizedProps, c)) && Fe(b);\n                  } else b.stateNode = La(e, c, f, b);\n                }\n                break;\n              case 11:\n                break;\n              case 13:\n                y(I);\n                e = b.memoizedState;\n                if (0 !== (b.effectTag & 64)) {\n                  b.expirationTime = d;\n                  break a;\n                }\n                e = null !== e;\n                f = !1;\n                null === c ? void 0 !== b.memoizedProps.fallback && ne(b) : (d = c.memoizedState, f = null !== d, e || null === d || (d = c.child.sibling, null !== d && (g = b.firstEffect, null !== g ? (b.firstEffect = d, d.nextEffect = g) : (b.firstEffect = b.lastEffect = d, d.nextEffect = null), d.effectTag = 8)));\n                if (e && !f && 0 !== (b.mode & 2)) if (null === c && !0 !== b.memoizedProps.unstable_avoidThisFallback || 0 !== (I.current & 1)) X === tf && (X = wf);else {\n                  if (X === tf || X === wf) X = xf;\n                  0 !== Df && null !== U && (Pf(U, W), Qf(U, Df));\n                }\n                Ra && e && (b.effectTag |= 4);\n                Qa && (e || f) && (b.effectTag |= 4);\n                break;\n              case 7:\n                break;\n              case 8:\n                break;\n              case 12:\n                break;\n              case 4:\n                rd();\n                He(b);\n                break;\n              case 10:\n                yc(b);\n                break;\n              case 9:\n                break;\n              case 14:\n                break;\n              case 17:\n                C(b.type) && Gb();\n                break;\n              case 19:\n                y(I);\n                e = b.memoizedState;\n                if (null === e) break;\n                f = 0 !== (b.effectTag & 64);\n                g = e.rendering;\n                if (null === g) {\n                  if (f) Le(e, !1);else {\n                    if (X !== tf || null !== c && 0 !== (c.effectTag & 64)) for (c = b.child; null !== c;) {\n                      g = ud(c);\n                      if (null !== g) {\n                        b.effectTag |= 64;\n                        Le(e, !1);\n                        c = g.updateQueue;\n                        null !== c && (b.updateQueue = c, b.effectTag |= 4);\n                        null === e.lastEffect && (b.firstEffect = null);\n                        b.lastEffect = e.lastEffect;\n                        c = d;\n                        for (e = b.child; null !== e;) f = e, d = c, f.effectTag &= 2, f.nextEffect = null, f.firstEffect = null, f.lastEffect = null, g = f.alternate, null === g ? (f.childExpirationTime = 0, f.expirationTime = d, f.child = null, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null) : (f.childExpirationTime = g.childExpirationTime, f.expirationTime = g.expirationTime, f.child = g.child, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, d = g.dependencies, f.dependencies = null === d ? null : {\n                          expirationTime: d.expirationTime,\n                          firstContext: d.firstContext,\n                          responders: d.responders\n                        }), e = e.sibling;\n                        z(I, I.current & 1 | 2);\n                        b = b.child;\n                        break a;\n                      }\n                      c = c.sibling;\n                    }\n                  }\n                } else {\n                  if (!f) if (c = ud(g), null !== c) {\n                    if (b.effectTag |= 64, f = !0, c = c.updateQueue, null !== c && (b.updateQueue = c, b.effectTag |= 4), Le(e, !0), null === e.tail && \"hidden\" === e.tailMode) {\n                      b = b.lastEffect = e.lastEffect;\n                      null !== b && (b.nextEffect = null);\n                      break;\n                    }\n                  } else E() > e.tailExpiration && 1 < d && (b.effectTag |= 64, f = !0, Le(e, !1), b.expirationTime = b.childExpirationTime = d - 1);\n                  e.isBackwards ? (g.sibling = b.child, b.child = g) : (c = e.last, null !== c ? c.sibling = g : b.child = g, e.last = g);\n                }\n                if (null !== e.tail) {\n                  0 === e.tailExpiration && (e.tailExpiration = E() + 500);\n                  c = e.tail;\n                  e.rendering = c;\n                  e.tail = c.sibling;\n                  e.lastEffect = b.lastEffect;\n                  c.sibling = null;\n                  e = I.current;\n                  e = f ? e & 1 | 2 : e & 1;\n                  z(I, e);\n                  b = c;\n                  break a;\n                }\n                break;\n              case 20:\n                break;\n              case 21:\n                break;\n              default:\n                throw Error(n(156, b.tag));\n            }\n            b = null;\n          }\n          c = V;\n          if (1 === W || 1 !== c.childExpirationTime) {\n            e = 0;\n            for (f = c.child; null !== f;) d = f.expirationTime, g = f.childExpirationTime, d > e && (e = d), g > e && (e = g), f = f.sibling;\n            c.childExpirationTime = e;\n          }\n          if (null !== b) return b;\n          null !== a && 0 === (a.effectTag & 2048) && (null === a.firstEffect && (a.firstEffect = V.firstEffect), null !== V.lastEffect && (null !== a.lastEffect && (a.lastEffect.nextEffect = V.firstEffect), a.lastEffect = V.lastEffect), 1 < V.effectTag && (null !== a.lastEffect ? a.lastEffect.nextEffect = V : a.firstEffect = V, a.lastEffect = V));\n        } else {\n          b = Me(V);\n          if (null !== b) return b.effectTag &= 2047, b;\n          null !== a && (a.firstEffect = a.lastEffect = null, a.effectTag |= 2048);\n        }\n        b = V.sibling;\n        if (null !== b) return b;\n        V = a;\n      } while (null !== V);\n      X === tf && (X = yf);\n      return null;\n    }\n    function $f(a) {\n      var b = a.expirationTime;\n      a = a.childExpirationTime;\n      return b > a ? b : a;\n    }\n    function ag(a) {\n      var b = fc();\n      hc(99, jg.bind(null, a, b));\n      return null;\n    }\n    function jg(a, b) {\n      Vf();\n      if ((T & (S | sf)) !== R) throw Error(n(327));\n      var c = a.finishedWork,\n        d = a.finishedExpirationTime;\n      if (null === c) return null;\n      a.finishedWork = null;\n      a.finishedExpirationTime = 0;\n      if (c === a.current) throw Error(n(177));\n      a.callbackNode = null;\n      a.callbackExpirationTime = 0;\n      a.callbackPriority = 90;\n      a.nextKnownPendingLevel = 0;\n      var e = $f(c);\n      a.firstPendingTime = e;\n      d <= a.lastSuspendedTime ? a.firstSuspendedTime = a.lastSuspendedTime = a.nextKnownPendingLevel = 0 : d <= a.firstSuspendedTime && (a.firstSuspendedTime = d - 1);\n      d <= a.lastPingedTime && (a.lastPingedTime = 0);\n      d <= a.lastExpiredTime && (a.lastExpiredTime = 0);\n      a === U && (V = U = null, W = 0);\n      1 < c.effectTag ? null !== c.lastEffect ? (c.lastEffect.nextEffect = c, e = c.firstEffect) : e = c : e = c.firstEffect;\n      if (null !== e) {\n        var f = T;\n        T |= sf;\n        qf.current = null;\n        Ca(a.containerInfo);\n        Y = e;\n        do try {\n          kg();\n        } catch (jb) {\n          if (null === Y) throw Error(n(330));\n          Re(Y, jb);\n          Y = Y.nextEffect;\n        } while (null !== Y);\n        Y = e;\n        do try {\n          for (var g = a, l = b; null !== Y;) {\n            var h = Y.effectTag;\n            h & 16 && Qa && bb(Y.stateNode);\n            if (h & 128) {\n              var k = Y.alternate;\n              if (null !== k) {\n                var p = k.ref;\n                null !== p && (\"function\" === typeof p ? p(null) : p.current = null);\n              }\n            }\n            switch (h & 1038) {\n              case 2:\n                bf(Y);\n                Y.effectTag &= -3;\n                break;\n              case 6:\n                bf(Y);\n                Y.effectTag &= -3;\n                cf(Y.alternate, Y);\n                break;\n              case 1024:\n                Y.effectTag &= -1025;\n                break;\n              case 1028:\n                Y.effectTag &= -1025;\n                cf(Y.alternate, Y);\n                break;\n              case 4:\n                cf(Y.alternate, Y);\n                break;\n              case 8:\n                var D = g,\n                  x = Y,\n                  K = l;\n                Qa ? Xe(D, x, K) : Ze(D, x, K);\n                $e(x);\n            }\n            Y = Y.nextEffect;\n          }\n        } catch (jb) {\n          if (null === Y) throw Error(n(330));\n          Re(Y, jb);\n          Y = Y.nextEffect;\n        } while (null !== Y);\n        Da(a.containerInfo);\n        a.current = c;\n        Y = e;\n        do try {\n          for (h = d; null !== Y;) {\n            var Ha = Y.effectTag;\n            if (Ha & 36) {\n              var O = Y.alternate;\n              k = Y;\n              p = h;\n              switch (k.tag) {\n                case 0:\n                case 11:\n                case 15:\n                  Ue(16, 32, k);\n                  break;\n                case 1:\n                  var w = k.stateNode;\n                  if (k.effectTag & 4) if (null === O) w.componentDidMount();else {\n                    var r = k.elementType === k.type ? O.memoizedProps : rc(k.type, O.memoizedProps);\n                    w.componentDidUpdate(r, O.memoizedState, w.__reactInternalSnapshotBeforeUpdate);\n                  }\n                  var t = k.updateQueue;\n                  null !== t && Qc(k, t, w, p);\n                  break;\n                case 3:\n                  var N = k.updateQueue;\n                  if (null !== N) {\n                    g = null;\n                    if (null !== k.child) switch (k.child.tag) {\n                      case 5:\n                        g = za(k.child.stateNode);\n                        break;\n                      case 1:\n                        g = k.child.stateNode;\n                    }\n                    Qc(k, N, g, p);\n                  }\n                  break;\n                case 5:\n                  var Mc = k.stateNode;\n                  null === O && k.effectTag & 4 && Wa(Mc, k.type, k.memoizedProps, k);\n                  break;\n                case 6:\n                  break;\n                case 4:\n                  break;\n                case 12:\n                  break;\n                case 13:\n                  if (Sa && null === k.memoizedState) {\n                    var Rb = k.alternate;\n                    if (null !== Rb) {\n                      var le = Rb.memoizedState;\n                      if (null !== le) {\n                        var me = le.dehydrated;\n                        null !== me && yb(me);\n                      }\n                    }\n                  }\n                  break;\n                case 19:\n                case 17:\n                case 20:\n                case 21:\n                  break;\n                default:\n                  throw Error(n(163));\n              }\n            }\n            if (Ha & 128) {\n              k = void 0;\n              var Sb = Y.ref;\n              if (null !== Sb) {\n                var v = Y.stateNode;\n                switch (Y.tag) {\n                  case 5:\n                    k = za(v);\n                    break;\n                  default:\n                    k = v;\n                }\n                \"function\" === typeof Sb ? Sb(k) : Sb.current = k;\n              }\n            }\n            Y = Y.nextEffect;\n          }\n        } catch (jb) {\n          if (null === Y) throw Error(n(330));\n          Re(Y, jb);\n          Y = Y.nextEffect;\n        } while (null !== Y);\n        Y = null;\n        ac();\n        T = f;\n      } else a.current = c;\n      if (Gf) Gf = !1, Hf = a, If = b;else for (Y = e; null !== Y;) b = Y.nextEffect, Y.nextEffect = null, Y = b;\n      b = a.firstPendingTime;\n      0 === b && (nf = null);\n      1073741823 === b ? a === Lf ? Kf++ : (Kf = 0, Lf = a) : Kf = 0;\n      \"function\" === typeof lg && lg(c.stateNode, d);\n      Z(a);\n      if (kf) throw kf = !1, a = lf, lf = null, a;\n      if ((T & rf) !== R) return null;\n      F();\n      return null;\n    }\n    function kg() {\n      for (; null !== Y;) {\n        var a = Y.effectTag;\n        0 !== (a & 256) && Te(Y.alternate, Y);\n        0 === (a & 512) || Gf || (Gf = !0, ic(97, function () {\n          Vf();\n          return null;\n        }));\n        Y = Y.nextEffect;\n      }\n    }\n    function Vf() {\n      if (90 !== If) {\n        var a = 97 < If ? 97 : If;\n        If = 90;\n        return hc(a, mg);\n      }\n    }\n    function mg() {\n      if (null === Hf) return !1;\n      var a = Hf;\n      Hf = null;\n      if ((T & (S | sf)) !== R) throw Error(n(331));\n      var b = T;\n      T |= sf;\n      for (a = a.current.firstEffect; null !== a;) {\n        try {\n          var c = a;\n          if (0 !== (c.effectTag & 512)) switch (c.tag) {\n            case 0:\n            case 11:\n            case 15:\n              Ue(128, 0, c), Ue(0, 64, c);\n          }\n        } catch (d) {\n          if (null === a) throw Error(n(330));\n          Re(a, d);\n        }\n        c = a.nextEffect;\n        a.nextEffect = null;\n        a = c;\n      }\n      T = b;\n      F();\n      return !0;\n    }\n    function ng(a, b, c) {\n      b = Ne(c, b);\n      b = jf(a, b, 1073741823);\n      Ic(a, b);\n      a = Nf(a, 1073741823);\n      null !== a && Z(a);\n    }\n    function Re(a, b) {\n      if (3 === a.tag) ng(a, a, b);else for (var c = a.return; null !== c;) {\n        if (3 === c.tag) {\n          ng(c, a, b);\n          break;\n        } else if (1 === c.tag) {\n          var d = c.stateNode;\n          if (\"function\" === typeof c.type.getDerivedStateFromError || \"function\" === typeof d.componentDidCatch && (null === nf || !nf.has(d))) {\n            a = Ne(b, a);\n            a = mf(c, a, 1073741823);\n            Ic(c, a);\n            c = Nf(c, 1073741823);\n            null !== c && Z(c);\n            break;\n          }\n        }\n        c = c.return;\n      }\n    }\n    function fg(a, b, c) {\n      var d = a.pingCache;\n      null !== d && d.delete(b);\n      U === a && W === c ? X === xf || X === wf && 1073741823 === Af && E() - ff < Ff ? Wf(a, W) : Ef = !0 : Sf(a, c) && (b = a.lastPingedTime, 0 !== b && b < c || (a.lastPingedTime = c, a.finishedExpirationTime === c && (a.finishedExpirationTime = 0, a.finishedWork = null), Z(a)));\n    }\n    function gf(a, b) {\n      var c = a.stateNode;\n      null !== c && c.delete(b);\n      b = 0;\n      0 === b && (b = G(), b = Vc(b, a, null));\n      a = Nf(a, b);\n      null !== a && Z(a);\n    }\n    var ig;\n    ig = function ig(a, b, c) {\n      var d = b.expirationTime;\n      if (null !== a) {\n        var e = b.pendingProps;\n        if (a.memoizedProps !== e || B.current) Bc = !0;else {\n          if (d < c) {\n            Bc = !1;\n            switch (b.tag) {\n              case 3:\n                ze(b);\n                oe();\n                break;\n              case 5:\n                sd(b);\n                if (b.mode & 4 && 1 !== c && Ka(b.type, e)) return b.expirationTime = b.childExpirationTime = 1, null;\n                break;\n              case 1:\n                C(b.type) && Kb(b);\n                break;\n              case 4:\n                qd(b, b.stateNode.containerInfo);\n                break;\n              case 10:\n                xc(b, b.memoizedProps.value);\n                break;\n              case 13:\n                if (null !== b.memoizedState) {\n                  d = b.child.childExpirationTime;\n                  if (0 !== d && d >= c) return Be(a, b, c);\n                  z(I, I.current & 1);\n                  b = re(a, b, c);\n                  return null !== b ? b.sibling : null;\n                }\n                z(I, I.current & 1);\n                break;\n              case 19:\n                d = b.childExpirationTime >= c;\n                if (0 !== (a.effectTag & 64)) {\n                  if (d) return Ee(a, b, c);\n                  b.effectTag |= 64;\n                }\n                e = b.memoizedState;\n                null !== e && (e.rendering = null, e.tail = null);\n                z(I, I.current);\n                if (!d) return null;\n            }\n            return re(a, b, c);\n          }\n          Bc = !1;\n        }\n      } else Bc = !1;\n      b.expirationTime = 0;\n      switch (b.tag) {\n        case 2:\n          d = b.type;\n          null !== a && (a.alternate = null, b.alternate = null, b.effectTag |= 2);\n          a = b.pendingProps;\n          e = Fb(b, A.current);\n          Ac(b, c);\n          e = Jd(null, b, d, a, e, c);\n          b.effectTag |= 1;\n          if (\"object\" === typeof e && null !== e && \"function\" === typeof e.render && void 0 === e.$$typeof) {\n            b.tag = 1;\n            Nd();\n            if (C(d)) {\n              var f = !0;\n              Kb(b);\n            } else f = !1;\n            b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null;\n            var g = d.getDerivedStateFromProps;\n            \"function\" === typeof g && Uc(b, d, g, a);\n            e.updater = Xc;\n            b.stateNode = e;\n            e._reactInternalFiber = b;\n            ad(b, d, a, c);\n            b = ye(null, b, d, !0, f, c);\n          } else b.tag = 0, Q(null, b, e, c), b = b.child;\n          return b;\n        case 16:\n          e = b.elementType;\n          null !== a && (a.alternate = null, b.alternate = null, b.effectTag |= 2);\n          a = b.pendingProps;\n          sa(e);\n          if (1 !== e._status) throw e._result;\n          e = e._result;\n          b.type = e;\n          f = b.tag = og(e);\n          a = rc(e, a);\n          switch (f) {\n            case 0:\n              b = ve(null, b, e, a, c);\n              break;\n            case 1:\n              b = xe(null, b, e, a, c);\n              break;\n            case 11:\n              b = qe(null, b, e, a, c);\n              break;\n            case 14:\n              b = se(null, b, e, rc(e.type, a), d, c);\n              break;\n            default:\n              throw Error(n(306, e, \"\"));\n          }\n          return b;\n        case 0:\n          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : rc(d, e), ve(a, b, d, e, c);\n        case 1:\n          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : rc(d, e), xe(a, b, d, e, c);\n        case 3:\n          ze(b);\n          d = b.updateQueue;\n          if (null === d) throw Error(n(282));\n          e = b.memoizedState;\n          e = null !== e ? e.element : null;\n          Nc(b, d, b.pendingProps, null, c);\n          d = b.memoizedState.element;\n          if (d === e) oe(), b = re(a, b, c);else {\n            if (e = b.stateNode.hydrate) Sa ? (ee = tb(b.stateNode.containerInfo), de = b, e = fe = !0) : e = !1;\n            if (e) for (c = ld(b, null, d, c), b.child = c; c;) c.effectTag = c.effectTag & -3 | 1024, c = c.sibling;else Q(a, b, d, c), oe();\n            b = b.child;\n          }\n          return b;\n        case 5:\n          return sd(b), null === a && je(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, Ja(d, e) ? g = null : null !== f && Ja(d, f) && (b.effectTag |= 16), we(a, b), b.mode & 4 && 1 !== c && Ka(d, e) ? (b.expirationTime = b.childExpirationTime = 1, b = null) : (Q(a, b, g, c), b = b.child), b;\n        case 6:\n          return null === a && je(b), null;\n        case 13:\n          return Be(a, b, c);\n        case 4:\n          return qd(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = kd(b, null, d, c) : Q(a, b, d, c), b.child;\n        case 11:\n          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : rc(d, e), qe(a, b, d, e, c);\n        case 7:\n          return Q(a, b, b.pendingProps, c), b.child;\n        case 8:\n          return Q(a, b, b.pendingProps.children, c), b.child;\n        case 12:\n          return Q(a, b, b.pendingProps.children, c), b.child;\n        case 10:\n          a: {\n            d = b.type._context;\n            e = b.pendingProps;\n            g = b.memoizedProps;\n            f = e.value;\n            xc(b, f);\n            if (null !== g) {\n              var l = g.value;\n              f = oc(l, f) ? 0 : (\"function\" === typeof d._calculateChangedBits ? d._calculateChangedBits(l, f) : 1073741823) | 0;\n              if (0 === f) {\n                if (g.children === e.children && !B.current) {\n                  b = re(a, b, c);\n                  break a;\n                }\n              } else for (l = b.child, null !== l && (l.return = b); null !== l;) {\n                var h = l.dependencies;\n                if (null !== h) {\n                  g = l.child;\n                  for (var k = h.firstContext; null !== k;) {\n                    if (k.context === d && 0 !== (k.observedBits & f)) {\n                      1 === l.tag && (k = Gc(c, null), k.tag = 2, Ic(l, k));\n                      l.expirationTime < c && (l.expirationTime = c);\n                      k = l.alternate;\n                      null !== k && k.expirationTime < c && (k.expirationTime = c);\n                      zc(l.return, c);\n                      h.expirationTime < c && (h.expirationTime = c);\n                      break;\n                    }\n                    k = k.next;\n                  }\n                } else g = 10 === l.tag ? l.type === b.type ? null : l.child : l.child;\n                if (null !== g) g.return = l;else for (g = l; null !== g;) {\n                  if (g === b) {\n                    g = null;\n                    break;\n                  }\n                  l = g.sibling;\n                  if (null !== l) {\n                    l.return = g.return;\n                    g = l;\n                    break;\n                  }\n                  g = g.return;\n                }\n                l = g;\n              }\n            }\n            Q(a, b, e.children, c);\n            b = b.child;\n          }\n          return b;\n        case 9:\n          return e = b.type, f = b.pendingProps, d = f.children, Ac(b, c), e = Cc(e, f.unstable_observedBits), d = d(e), b.effectTag |= 1, Q(a, b, d, c), b.child;\n        case 14:\n          return e = b.type, f = rc(e, b.pendingProps), f = rc(e.type, f), se(a, b, e, f, d, c);\n        case 15:\n          return ue(a, b, b.type, b.pendingProps, d, c);\n        case 17:\n          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : rc(d, e), null !== a && (a.alternate = null, b.alternate = null, b.effectTag |= 2), b.tag = 1, C(d) ? (a = !0, Kb(b)) : a = !1, Ac(b, c), Zc(b, d, e), ad(b, d, e, c), ye(null, b, d, !0, a, c);\n        case 19:\n          return Ee(a, b, c);\n      }\n      throw Error(n(156, b.tag));\n    };\n    var lg = null,\n      We = null;\n    function pg(a) {\n      if (\"undefined\" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;\n      var b = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n      if (b.isDisabled || !b.supportsFiber) return !0;\n      try {\n        var c = b.inject(a);\n        lg = function lg(a) {\n          try {\n            b.onCommitFiberRoot(c, a, void 0, 64 === (a.current.effectTag & 64));\n          } catch (e) {}\n        };\n        We = function We(a) {\n          try {\n            b.onCommitFiberUnmount(c, a);\n          } catch (e) {}\n        };\n      } catch (d) {}\n      return !0;\n    }\n    function qg(a, b, c, d) {\n      this.tag = a;\n      this.key = c;\n      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;\n      this.index = 0;\n      this.ref = null;\n      this.pendingProps = b;\n      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;\n      this.mode = d;\n      this.effectTag = 0;\n      this.lastEffect = this.firstEffect = this.nextEffect = null;\n      this.childExpirationTime = this.expirationTime = 0;\n      this.alternate = null;\n    }\n    function he(a, b, c, d) {\n      return new qg(a, b, c, d);\n    }\n    function te(a) {\n      a = a.prototype;\n      return !(!a || !a.isReactComponent);\n    }\n    function og(a) {\n      if (\"function\" === typeof a) return te(a) ? 1 : 0;\n      if (void 0 !== a && null !== a) {\n        a = a.$$typeof;\n        if (a === la) return 11;\n        if (a === oa) return 14;\n      }\n      return 2;\n    }\n    function fd(a, b) {\n      var c = a.alternate;\n      null === c ? (c = he(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.effectTag = 0, c.nextEffect = null, c.firstEffect = null, c.lastEffect = null);\n      c.childExpirationTime = a.childExpirationTime;\n      c.expirationTime = a.expirationTime;\n      c.child = a.child;\n      c.memoizedProps = a.memoizedProps;\n      c.memoizedState = a.memoizedState;\n      c.updateQueue = a.updateQueue;\n      b = a.dependencies;\n      c.dependencies = null === b ? null : {\n        expirationTime: b.expirationTime,\n        firstContext: b.firstContext,\n        responders: b.responders\n      };\n      c.sibling = a.sibling;\n      c.index = a.index;\n      c.ref = a.ref;\n      return c;\n    }\n    function hd(a, b, c, d, e, f) {\n      var g = 2;\n      d = a;\n      if (\"function\" === typeof a) te(a) && (g = 1);else if (\"string\" === typeof a) g = 5;else a: switch (a) {\n        case ea:\n          return jd(c.children, e, f, b);\n        case ka:\n          g = 8;\n          e |= 7;\n          break;\n        case fa:\n          g = 8;\n          e |= 1;\n          break;\n        case ha:\n          return a = he(12, c, b, e | 8), a.elementType = ha, a.type = ha, a.expirationTime = f, a;\n        case ma:\n          return a = he(13, c, b, e), a.type = ma, a.elementType = ma, a.expirationTime = f, a;\n        case na:\n          return a = he(19, c, b, e), a.elementType = na, a.expirationTime = f, a;\n        default:\n          if (\"object\" === typeof a && null !== a) switch (a.$$typeof) {\n            case ia:\n              g = 10;\n              break a;\n            case ja:\n              g = 9;\n              break a;\n            case la:\n              g = 11;\n              break a;\n            case oa:\n              g = 14;\n              break a;\n            case pa:\n              g = 16;\n              d = null;\n              break a;\n          }\n          throw Error(n(130, null == a ? a : typeof a, \"\"));\n      }\n      b = he(g, c, b, e);\n      b.elementType = a;\n      b.type = d;\n      b.expirationTime = f;\n      return b;\n    }\n    function jd(a, b, c, d) {\n      a = he(7, a, d, b);\n      a.expirationTime = c;\n      return a;\n    }\n    function gd(a, b, c) {\n      a = he(6, a, null, b);\n      a.expirationTime = c;\n      return a;\n    }\n    function id(a, b, c) {\n      b = he(4, null !== a.children ? a.children : [], a.key, b);\n      b.expirationTime = c;\n      b.stateNode = {\n        containerInfo: a.containerInfo,\n        pendingChildren: null,\n        implementation: a.implementation\n      };\n      return b;\n    }\n    function rg(a, b, c) {\n      this.tag = b;\n      this.current = null;\n      this.containerInfo = a;\n      this.pingCache = this.pendingChildren = null;\n      this.finishedExpirationTime = 0;\n      this.finishedWork = null;\n      this.timeoutHandle = Oa;\n      this.pendingContext = this.context = null;\n      this.hydrate = c;\n      this.callbackNode = null;\n      this.callbackPriority = 90;\n      this.lastExpiredTime = this.lastPingedTime = this.nextKnownPendingLevel = this.lastSuspendedTime = this.firstSuspendedTime = this.firstPendingTime = 0;\n    }\n    function Sf(a, b) {\n      var c = a.firstSuspendedTime;\n      a = a.lastSuspendedTime;\n      return 0 !== c && c >= b && a <= b;\n    }\n    function Pf(a, b) {\n      var c = a.firstSuspendedTime,\n        d = a.lastSuspendedTime;\n      c < b && (a.firstSuspendedTime = b);\n      if (d > b || 0 === c) a.lastSuspendedTime = b;\n      b <= a.lastPingedTime && (a.lastPingedTime = 0);\n      b <= a.lastExpiredTime && (a.lastExpiredTime = 0);\n    }\n    function Qf(a, b) {\n      b > a.firstPendingTime && (a.firstPendingTime = b);\n      var c = a.firstSuspendedTime;\n      0 !== c && (b >= c ? a.firstSuspendedTime = a.lastSuspendedTime = a.nextKnownPendingLevel = 0 : b >= a.lastSuspendedTime && (a.lastSuspendedTime = b + 1), b > a.nextKnownPendingLevel && (a.nextKnownPendingLevel = b));\n    }\n    function Uf(a, b) {\n      var c = a.lastExpiredTime;\n      if (0 === c || c > b) a.lastExpiredTime = b;\n    }\n    function sg(a) {\n      var b = a._reactInternalFiber;\n      if (void 0 === b) {\n        if (\"function\" === typeof a.render) throw Error(n(188));\n        throw Error(n(268, Object.keys(a)));\n      }\n      a = xa(b);\n      return null === a ? null : a.stateNode;\n    }\n    function tg(a, b) {\n      a = a.memoizedState;\n      null !== a && null !== a.dehydrated && a.retryTime < b && (a.retryTime = b);\n    }\n    function ug(a, b) {\n      tg(a, b);\n      (a = a.alternate) && tg(a, b);\n    }\n    var vg = {\n      createContainer: function createContainer(a, b, c) {\n        a = new rg(a, b, c);\n        b = he(3, null, null, 2 === b ? 7 : 1 === b ? 3 : 0);\n        a.current = b;\n        return b.stateNode = a;\n      },\n      updateContainer: function updateContainer(a, b, c, d) {\n        var e = b.current,\n          f = G(),\n          g = Sc.suspense;\n        f = Vc(f, e, g);\n        a: if (c) {\n          c = c._reactInternalFiber;\n          b: {\n            if (ua(c) !== c || 1 !== c.tag) throw Error(n(170));\n            var l = c;\n            do {\n              switch (l.tag) {\n                case 3:\n                  l = l.stateNode.context;\n                  break b;\n                case 1:\n                  if (C(l.type)) {\n                    l = l.stateNode.__reactInternalMemoizedMergedChildContext;\n                    break b;\n                  }\n              }\n              l = l.return;\n            } while (null !== l);\n            throw Error(n(171));\n          }\n          if (1 === c.tag) {\n            var h = c.type;\n            if (C(h)) {\n              c = Jb(c, h, l);\n              break a;\n            }\n          }\n          c = l;\n        } else c = Db;\n        null === b.context ? b.context = c : b.pendingContext = c;\n        b = Gc(f, g);\n        b.payload = {\n          element: a\n        };\n        d = void 0 === d ? null : d;\n        null !== d && (b.callback = d);\n        Ic(e, b);\n        Wc(e, f);\n        return f;\n      },\n      batchedEventUpdates: function batchedEventUpdates(a, b) {\n        var c = T;\n        T |= 2;\n        try {\n          return a(b);\n        } finally {\n          T = c, T === R && F();\n        }\n      },\n      batchedUpdates: function batchedUpdates(a, b) {\n        var c = T;\n        T |= 1;\n        try {\n          return a(b);\n        } finally {\n          T = c, T === R && F();\n        }\n      },\n      unbatchedUpdates: function unbatchedUpdates(a, b) {\n        var c = T;\n        T &= -2;\n        T |= rf;\n        try {\n          return a(b);\n        } finally {\n          T = c, T === R && F();\n        }\n      },\n      deferredUpdates: function deferredUpdates(a) {\n        return hc(97, a);\n      },\n      syncUpdates: function syncUpdates(a, b, c, d) {\n        return hc(99, a.bind(null, b, c, d));\n      },\n      discreteUpdates: function discreteUpdates(a, b, c, d) {\n        var e = T;\n        T |= 4;\n        try {\n          return hc(98, a.bind(null, b, c, d));\n        } finally {\n          T = e, T === R && F();\n        }\n      },\n      flushDiscreteUpdates: function flushDiscreteUpdates() {\n        (T & (1 | S | sf)) === R && (dg(), Vf());\n      },\n      flushControlled: function flushControlled(a) {\n        var b = T;\n        T |= 1;\n        try {\n          hc(99, a);\n        } finally {\n          T = b, T === R && F();\n        }\n      },\n      flushSync: eg,\n      flushPassiveEffects: Vf,\n      IsThisRendererActing: {\n        current: !1\n      },\n      getPublicRootInstance: function getPublicRootInstance(a) {\n        a = a.current;\n        if (!a.child) return null;\n        switch (a.child.tag) {\n          case 5:\n            return za(a.child.stateNode);\n          default:\n            return a.child.stateNode;\n        }\n      },\n      attemptSynchronousHydration: function attemptSynchronousHydration(a) {\n        switch (a.tag) {\n          case 3:\n            var b = a.stateNode;\n            b.hydrate && cg(b, b.firstPendingTime);\n            break;\n          case 13:\n            eg(function () {\n              return Wc(a, 1073741823);\n            }), b = mc(G(), 150, 100), ug(a, b);\n        }\n      },\n      attemptUserBlockingHydration: function attemptUserBlockingHydration(a) {\n        if (13 === a.tag) {\n          var b = mc(G(), 150, 100);\n          Wc(a, b);\n          ug(a, b);\n        }\n      },\n      attemptContinuousHydration: function attemptContinuousHydration(a) {\n        if (13 === a.tag) {\n          G();\n          var b = lc++;\n          Wc(a, b);\n          ug(a, b);\n        }\n      },\n      attemptHydrationAtCurrentPriority: function attemptHydrationAtCurrentPriority(a) {\n        if (13 === a.tag) {\n          var b = G();\n          b = Vc(b, a, null);\n          Wc(a, b);\n          ug(a, b);\n        }\n      },\n      findHostInstance: sg,\n      findHostInstanceWithWarning: function findHostInstanceWithWarning(a) {\n        return sg(a);\n      },\n      findHostInstanceWithNoPortals: function findHostInstanceWithNoPortals(a) {\n        a = ya(a);\n        return null === a ? null : 20 === a.tag ? a.stateNode.instance : a.stateNode;\n      },\n      shouldSuspend: function shouldSuspend() {\n        return !1;\n      },\n      injectIntoDevTools: function injectIntoDevTools(a) {\n        var b = a.findFiberByHostInstance;\n        return pg(aa({}, a, {\n          overrideHookState: null,\n          overrideProps: null,\n          setSuspenseHandler: null,\n          scheduleUpdate: null,\n          currentDispatcherRef: q.ReactCurrentDispatcher,\n          findHostInstanceByFiber: function findHostInstanceByFiber(a) {\n            a = xa(a);\n            return null === a ? null : a.stateNode;\n          },\n          findFiberByHostInstance: function findFiberByHostInstance(a) {\n            return b ? b(a) : null;\n          },\n          findHostInstancesForRefresh: null,\n          scheduleRefresh: null,\n          scheduleRoot: null,\n          setRefreshHandler: null,\n          getCurrentFiber: null\n        }));\n      }\n    };\n    module.exports = vg.default || vg;\n    var $$$renderer = module.exports;\n    module.exports = $$$reconciler;\n    return $$$renderer;\n  };\n})(reactReconciler_production_min);\nvar ReactFiberReconciler = reactReconciler_production_min.exports;\n\n/* eslint-disable no-continue */\n\n/**\n * Checks if two sets of props are equal (recursively)\n *\n * @param {Object} props A\n * @param {Object} props B\n * @returns {Boolean} props equals?\n *\n */\nvar propsEqual = function propsEqual(a, b) {\n  var oldPropsKeys = Object.keys(a);\n  var newPropsKeys = Object.keys(b);\n  if (oldPropsKeys.length !== newPropsKeys.length) {\n    return false;\n  }\n  for (var i = 0; i < oldPropsKeys.length; i += 1) {\n    var propName = oldPropsKeys[i];\n    if (propName === 'render' && !a[propName] !== !b[propName]) {\n      return false;\n    }\n    if (propName !== 'children' && a[propName] !== b[propName]) {\n      if (typeof a[propName] === 'object' && typeof b[propName] === 'object' && propsEqual(a[propName], b[propName])) {\n        continue;\n      }\n      return false;\n    }\n    if (propName === 'children' && (typeof a[propName] === 'string' || typeof b[propName] === 'string')) {\n      return a[propName] === b[propName];\n    }\n  }\n  return true;\n};\nvar _excluded$1 = [\"style\", \"children\"],\n  _excluded2 = [\"style\"];\nvar emptyObject = {};\nvar appendChild = function appendChild(parentInstance, child) {\n  var isParentText = parentInstance.type === 'TEXT' || parentInstance.type === 'LINK' || parentInstance.type === 'TSPAN';\n  var isChildTextInstance = child.type === 'TEXT_INSTANCE';\n  var isOrphanTextInstance = isChildTextInstance && !isParentText;\n\n  // Ignore orphan text instances.\n  // Caused by cases such as <>{name && <Text>{name}</Text>}</>\n  if (isOrphanTextInstance) {\n    console.warn(\"Invalid '\" + child.value + \"' string child outside <Text> component\");\n    return;\n  }\n  parentInstance.children.push(child);\n};\nvar createRenderer = function createRenderer(_ref) {\n  var _ref$onChange = _ref.onChange,\n    onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange;\n  return ReactFiberReconciler({\n    schedulePassiveEffects: scheduler.unstable_scheduleCallback,\n    cancelPassiveEffects: scheduler.unstable_cancelCallback,\n    supportsMutation: true,\n    isPrimaryRenderer: false,\n    warnsIfNotActing: false,\n    appendInitialChild: appendChild,\n    createInstance: function createInstance(type, _ref2) {\n      var style = _ref2.style;\n      _ref2.children;\n      var props = _objectWithoutPropertiesLoose(_ref2, _excluded$1);\n      return {\n        type: type,\n        box: {},\n        style: style || {},\n        props: props || {},\n        children: []\n      };\n    },\n    createTextInstance: function createTextInstance(text, rootContainerInstance) {\n      return {\n        type: 'TEXT_INSTANCE',\n        value: text\n      };\n    },\n    finalizeInitialChildren: function finalizeInitialChildren(element, type, props) {\n      return false;\n    },\n    getPublicInstance: function getPublicInstance(instance) {\n      return instance;\n    },\n    prepareForCommit: function prepareForCommit() {\n      // Noop\n    },\n    clearContainer: function clearContainer() {\n      // Noop\n    },\n    prepareUpdate: function prepareUpdate(element, type, oldProps, newProps) {\n      return !propsEqual(oldProps, newProps);\n    },\n    resetAfterCommit: onChange,\n    resetTextContent: function resetTextContent(element) {\n      // Noop\n    },\n    getRootHostContext: function getRootHostContext() {\n      return emptyObject;\n    },\n    getChildHostContext: function getChildHostContext() {\n      return emptyObject;\n    },\n    shouldSetTextContent: function shouldSetTextContent(type, props) {\n      return false;\n    },\n    now: Date.now,\n    useSyncScheduling: true,\n    appendChild: appendChild,\n    appendChildToContainer: function appendChildToContainer(parentInstance, child) {\n      if (parentInstance.type === 'ROOT') {\n        parentInstance.document = child;\n      } else {\n        appendChild(parentInstance, child);\n      }\n    },\n    insertBefore: function insertBefore(parentInstance, child, beforeChild) {\n      var _parentInstance$child;\n      var index = (_parentInstance$child = parentInstance.children) === null || _parentInstance$child === void 0 ? void 0 : _parentInstance$child.indexOf(beforeChild);\n      if (index === undefined) return;\n      if (index !== -1 && child) parentInstance.children.splice(index, 0, child);\n    },\n    removeChild: function removeChild(parentInstance, child) {\n      var _parentInstance$child2;\n      var index = (_parentInstance$child2 = parentInstance.children) === null || _parentInstance$child2 === void 0 ? void 0 : _parentInstance$child2.indexOf(child);\n      if (index === undefined) return;\n      if (index !== -1) parentInstance.children.splice(index, 1);\n    },\n    removeChildFromContainer: function removeChildFromContainer(parentInstance, child) {\n      var _parentInstance$child3;\n      var index = (_parentInstance$child3 = parentInstance.children) === null || _parentInstance$child3 === void 0 ? void 0 : _parentInstance$child3.indexOf(child);\n      if (index === undefined) return;\n      if (index !== -1) parentInstance.children.splice(index, 1);\n    },\n    commitTextUpdate: function commitTextUpdate(textInstance, oldText, newText) {\n      textInstance.value = newText;\n    },\n    commitUpdate: function commitUpdate(instance, updatePayload, type, oldProps, newProps) {\n      var style = newProps.style,\n        props = _objectWithoutPropertiesLoose(newProps, _excluded2);\n      instance.props = props;\n      instance.style = style;\n    }\n  });\n};\nvar version = \"3.1.8\";\nvar fontStore = new FontStore();\n\n// We must keep a single renderer instance, otherwise React will complain\nvar renderer;\n\n// The pdf instance acts as an event emitter for DOM usage.\n// We only want to trigger an update when PDF content changes\nvar events = {};\nvar pdf = function pdf(initialValue) {\n  var onChange = function onChange() {\n    var _events$change;\n    var listeners = ((_events$change = events.change) === null || _events$change === void 0 ? void 0 : _events$change.slice()) || [];\n    for (var i = 0; i < listeners.length; i += 1) listeners[i]();\n  };\n  var container = {\n    type: 'ROOT',\n    document: null\n  };\n  renderer = renderer || createRenderer({\n    onChange: onChange\n  });\n  var mountNode = renderer.createContainer(container);\n  var updateContainer = function updateContainer(doc) {\n    renderer.updateContainer(doc, mountNode, null);\n  };\n  if (initialValue) updateContainer(initialValue);\n  var render = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(compress) {\n      var props, pdfVersion, language, pageLayout, pageMode, ctx, layout, fileStream;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            if (compress === void 0) {\n              compress = true;\n            }\n            props = container.document.props || {};\n            pdfVersion = props.pdfVersion, language = props.language, pageLayout = props.pageLayout, pageMode = props.pageMode;\n            ctx = new PDFDocument({\n              compress: compress,\n              pdfVersion: pdfVersion,\n              lang: language,\n              displayTitle: true,\n              autoFirstPage: false,\n              pageLayout: pageLayout,\n              pageMode: pageMode\n            });\n            _context.next = 6;\n            return layoutDocument(container.document, fontStore);\n          case 6:\n            layout = _context.sent;\n            fileStream = renderPDF(ctx, layout);\n            return _context.abrupt(\"return\", {\n              layout: layout,\n              fileStream: fileStream\n            });\n          case 9:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n    return function render(_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  var callOnRender = function callOnRender(params) {\n    if (params === void 0) {\n      params = {};\n    }\n    if (container.document.props.onRender) {\n      container.document.props.onRender(params);\n    }\n  };\n  var toBlob = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n      var chunks, _yield$render, _INTERNAL__LAYOUT__DATA_, instance;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            chunks = [];\n            _context2.next = 3;\n            return render();\n          case 3:\n            _yield$render = _context2.sent;\n            _INTERNAL__LAYOUT__DATA_ = _yield$render.layout;\n            instance = _yield$render.fileStream;\n            return _context2.abrupt(\"return\", new Promise(function (resolve, reject) {\n              instance.on('data', function (chunk) {\n                chunks.push(chunk instanceof Uint8Array ? chunk : new Uint8Array(chunk));\n              });\n              instance.on('end', function () {\n                try {\n                  var blob = new Blob(chunks, {\n                    type: 'application/pdf'\n                  });\n                  callOnRender({\n                    blob: blob,\n                    _INTERNAL__LAYOUT__DATA_: _INTERNAL__LAYOUT__DATA_\n                  });\n                  resolve(blob);\n                } catch (error) {\n                  reject(error);\n                }\n              });\n            }));\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2);\n    }));\n    return function toBlob() {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n\n  // TODO: rename this method to `toStream` in next major release, because it return stream not a buffer\n  var toBuffer = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n      return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            callOnRender();\n            _context3.next = 3;\n            return render();\n          case 3:\n            return _context3.abrupt(\"return\", _context3.sent.fileStream);\n          case 4:\n          case \"end\":\n            return _context3.stop();\n        }\n      }, _callee3);\n    }));\n    return function toBuffer() {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n\n  /*\n   * TODO: remove this method in next major release. it is buggy\n   * see\n   * - https://github.com/diegomura/react-pdf/issues/2112\n   * - https://github.com/diegomura/react-pdf/issues/2095\n   */\n  var toString = /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n      var result, _yield$render2, instance;\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            if (process.env.NODE_ENV === 'development') {\n              console.warn('`toString` is deprecated and will be removed in next major release');\n            }\n            result = '';\n            _context4.next = 4;\n            return render(false);\n          case 4:\n            _yield$render2 = _context4.sent;\n            instance = _yield$render2.fileStream;\n            return _context4.abrupt(\"return\", new Promise(function (resolve, reject) {\n              try {\n                instance.on('data', function (buffer) {\n                  result += buffer;\n                });\n                instance.on('end', function () {\n                  callOnRender();\n                  resolve(result);\n                });\n              } catch (error) {\n                reject(error);\n              }\n            }));\n          case 7:\n          case \"end\":\n            return _context4.stop();\n        }\n      }, _callee4);\n    }));\n    return function toString() {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n  var on = function on(event, listener) {\n    if (!events[event]) events[event] = [];\n    events[event].push(listener);\n  };\n  var removeListener = function removeListener(event, listener) {\n    if (!events[event]) return;\n    var idx = events[event].indexOf(listener);\n    if (idx > -1) events[event].splice(idx, 1);\n  };\n  return {\n    on: on,\n    container: container,\n    toBlob: toBlob,\n    toBuffer: toBuffer,\n    toString: toString,\n    removeListener: removeListener,\n    updateContainer: updateContainer\n  };\n};\nvar Font = fontStore;\nvar StyleSheet = {\n  create: function create(s) {\n    return s;\n  }\n};\nvar usePDF = function usePDF(_ref) {\n  var document = _ref.document;\n  var pdfInstance = useRef(null);\n  var _useState = useState({\n      url: null,\n      blob: null,\n      error: null,\n      loading: false\n    }),\n    state = _useState[0],\n    setState = _useState[1];\n\n  // Setup rendering queue\n  useEffect(function () {\n    var renderQueue = queue({\n      autostart: true,\n      concurrency: 1\n    });\n    var queueDocumentRender = function queueDocumentRender() {\n      setState(function (prev) {\n        return _extends({}, prev, {\n          loading: true\n        });\n      });\n      renderQueue.splice(0, renderQueue.length, function () {\n        return state.error ? Promise.resolve() : pdfInstance.current.toBlob();\n      });\n    };\n    var onRenderFailed = function onRenderFailed(error) {\n      console.error(error);\n      setState(function (prev) {\n        return _extends({}, prev, {\n          error: error\n        });\n      });\n    };\n    var onRenderSuccessful = function onRenderSuccessful(blob) {\n      setState({\n        blob: blob,\n        error: null,\n        loading: false,\n        url: URL.createObjectURL(blob)\n      });\n    };\n    pdfInstance.current = pdf();\n    pdfInstance.current.on('change', queueDocumentRender);\n    pdfInstance.current.updateContainer(document);\n    renderQueue.on('error', onRenderFailed);\n    renderQueue.on('success', onRenderSuccessful);\n    return function () {\n      renderQueue.end();\n      pdfInstance.current.removeListener('change', queueDocumentRender);\n    };\n  }, []);\n\n  // Revoke old unused url instances\n  useEffect(function () {\n    return function () {\n      if (state.url) {\n        URL.revokeObjectURL(state.url);\n      }\n    };\n  }, [state.url]);\n  var update = function update() {\n    pdfInstance.current.updateContainer(document);\n  };\n  return [state, update];\n};\nvar _excluded = [\"title\", \"style\", \"className\", \"children\", \"innerRef\", \"showToolbar\"];\nvar PDFViewer = function PDFViewer(_ref) {\n  var title = _ref.title,\n    style = _ref.style,\n    className = _ref.className,\n    children = _ref.children,\n    innerRef = _ref.innerRef,\n    _ref$showToolbar = _ref.showToolbar,\n    showToolbar = _ref$showToolbar === void 0 ? true : _ref$showToolbar,\n    props = _objectWithoutPropertiesLoose(_ref, _excluded);\n  var _usePDF = usePDF({\n      document: children\n    }),\n    instance = _usePDF[0],\n    updateInstance = _usePDF[1];\n  useEffect(updateInstance, [children]);\n  var src = instance.url ? instance.url + \"#toolbar=\" + (showToolbar ? 1 : 0) : null;\n  return /*#__PURE__*/jsx(\"iframe\", _extends({\n    src: src,\n    title: title,\n    ref: innerRef,\n    style: style,\n    className: className\n  }, props));\n};\n\n/* eslint-disable no-console */\nvar BlobProvider = function BlobProvider(_ref) {\n  var doc = _ref.document,\n    children = _ref.children;\n  var _usePDF = usePDF({\n      document: doc\n    }),\n    instance = _usePDF[0],\n    updateInstance = _usePDF[1];\n  useEffect(updateInstance, [doc]);\n  if (!doc) {\n    console.warn('You should pass a valid document to BlobProvider');\n    return null;\n  }\n  return children(instance);\n};\n\n/* eslint-disable no-console */\nvar PDFDownloadLink = function PDFDownloadLink(_ref) {\n  var style = _ref.style,\n    children = _ref.children,\n    className = _ref.className,\n    doc = _ref.document,\n    _ref$fileName = _ref.fileName,\n    fileName = _ref$fileName === void 0 ? 'document.pdf' : _ref$fileName,\n    onClick = _ref.onClick;\n  var _usePDF = usePDF({\n      document: doc\n    }),\n    instance = _usePDF[0],\n    updateInstance = _usePDF[1];\n  useEffect(updateInstance, [children]);\n  if (!doc) {\n    console.warn('You should pass a valid document to PDFDownloadLink');\n    return null;\n  }\n  var handleDownloadIE = function handleDownloadIE() {\n    if (window.navigator.msSaveBlob) {\n      // IE\n      window.navigator.msSaveBlob(instance.blob, fileName);\n    }\n  };\n  var handleClick = function handleClick(event) {\n    handleDownloadIE();\n    if (typeof onClick === 'function') onClick(event, instance);\n  };\n  return /*#__PURE__*/jsx(\"a\", {\n    style: style,\n    href: instance.url,\n    download: fileName,\n    className: className,\n    onClick: handleClick,\n    children: typeof children === 'function' ? children(instance) : children\n  });\n};\nvar throwEnvironmentError = function throwEnvironmentError(name) {\n  throw new Error(name + \" is a Node specific API. You're either using this method in a browser, or your bundler is not loading react-pdf from the appropriate web build.\");\n};\nvar renderToStream = function renderToStream() {\n  throwEnvironmentError('renderToStream');\n};\nvar renderToBuffer = function renderToBuffer() {\n  throwEnvironmentError('renderToBuffer');\n};\nvar renderToString = function renderToString() {\n  throwEnvironmentError('renderToString');\n};\nvar renderToFile = function renderToFile() {\n  throwEnvironmentError('renderToFile');\n};\nvar render = function render() {\n  throwEnvironmentError('render');\n};\n\n// TODO: remove this default export in next major release because it breaks tree-shacking\nvar index = _extends({\n  pdf: pdf,\n  usePDF: usePDF,\n  Font: Font,\n  version: version,\n  StyleSheet: StyleSheet,\n  PDFViewer: PDFViewer,\n  BlobProvider: BlobProvider,\n  PDFDownloadLink: PDFDownloadLink,\n  renderToStream: renderToStream,\n  renderToString: renderToString,\n  renderToFile: renderToFile,\n  render: render\n}, primitives);\nexport { BlobProvider, Font, PDFDownloadLink, PDFViewer, StyleSheet, createRenderer, index as default, pdf, render, renderToBuffer, renderToFile, renderToStream, renderToString, usePDF, version };","map":null,"metadata":{},"sourceType":"module"}