{"ast":null,"code":"import _classCallCheck from \"/Users/koonk/Documents/GitHub/final-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/koonk/Documents/GitHub/final-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/koonk/Documents/GitHub/final-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/koonk/Documents/GitHub/final-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/koonk/Documents/GitHub/final-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { getPrecedence } from '../operators.js';\nimport { escape } from '../../utils/string.js';\nimport { getSafeProperty } from '../../utils/customs.js';\nimport { latexOperators } from '../../utils/latex.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'RelationalNode';\nvar dependencies = ['Node'];\nexport var createRelationalNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n  var operatorMap = {\n    equal: '==',\n    unequal: '!=',\n    smaller: '<',\n    larger: '>',\n    smallerEq: '<=',\n    largerEq: '>='\n  };\n  var RelationalNode = /*#__PURE__*/function (_Node) {\n    _inherits(RelationalNode, _Node);\n    /**\n     * A node representing a chained conditional expression, such as 'x > y > z'\n     *\n     * @param {String[]} conditionals\n     *     An array of conditional operators used to compare the parameters\n     * @param {Node[]} params\n     *     The parameters that will be compared\n     *\n     * @constructor RelationalNode\n     * @extends {Node}\n     */\n    function RelationalNode(conditionals, params) {\n      var _this;\n      _classCallCheck(this, RelationalNode);\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(RelationalNode).call(this));\n      if (!Array.isArray(conditionals)) {\n        throw new TypeError('Parameter conditionals must be an array');\n      }\n      if (!Array.isArray(params)) {\n        throw new TypeError('Parameter params must be an array');\n      }\n      if (conditionals.length !== params.length - 1) {\n        throw new TypeError('Parameter params must contain exactly one more element ' + 'than parameter conditionals');\n      }\n      _this.conditionals = conditionals;\n      _this.params = params;\n      return _this;\n    }\n    _createClass(RelationalNode, [{\n      key: \"_compile\",\n      /**\n       * Compile a node into a JavaScript function.\n       * This basically pre-calculates as much as possible and only leaves open\n       * calculations which depend on a dynamic scope with variables.\n       * @param {Object} math     Math.js namespace with functions and constants.\n       * @param {Object} argNames An object with argument names as key and `true`\n       *                          as value. Used in the SymbolNode to optimize\n       *                          for arguments from user assigned functions\n       *                          (see FunctionAssignmentNode) or special symbols\n       *                          like `end` (see IndexNode).\n       * @return {function} Returns a function which can be called like:\n       *                        evalNode(scope: Object, args: Object, context: *)\n       */\n      value: function _compile(math, argNames) {\n        var self = this;\n        var compiled = this.params.map(function (p) {\n          return p._compile(math, argNames);\n        });\n        return function evalRelationalNode(scope, args, context) {\n          var evalLhs;\n          var evalRhs = compiled[0](scope, args, context);\n          for (var i = 0; i < self.conditionals.length; i++) {\n            evalLhs = evalRhs;\n            evalRhs = compiled[i + 1](scope, args, context);\n            var condFn = getSafeProperty(math, self.conditionals[i]);\n            if (!condFn(evalLhs, evalRhs)) {\n              return false;\n            }\n          }\n          return true;\n        };\n      }\n      /**\n       * Execute a callback for each of the child nodes of this node\n       * @param {function(child: Node, path: string, parent: Node)} callback\n       */\n    }, {\n      key: \"forEach\",\n      value: function forEach(callback) {\n        var _this2 = this;\n        this.params.forEach(function (n, i) {\n          return callback(n, 'params[' + i + ']', _this2);\n        }, this);\n      }\n      /**\n       * Create a new RelationalNode whose children are the results of calling\n       * the provided callback function for each child of the original node.\n       * @param {function(child: Node, path: string, parent: Node): Node} callback\n       * @returns {RelationalNode} Returns a transformed copy of the node\n       */\n    }, {\n      key: \"map\",\n      value: function map(callback) {\n        var _this3 = this;\n        return new RelationalNode(this.conditionals.slice(), this.params.map(function (n, i) {\n          return _this3._ifNode(callback(n, 'params[' + i + ']', _this3));\n        }, this));\n      }\n      /**\n       * Create a clone of this node, a shallow copy\n       * @return {RelationalNode}\n       */\n    }, {\n      key: \"clone\",\n      value: function clone() {\n        return new RelationalNode(this.conditionals, this.params);\n      }\n      /**\n       * Get string representation.\n       * @param {Object} options\n       * @return {string} str\n       */\n    }, {\n      key: \"_toString\",\n      value: function _toString(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var precedence = getPrecedence(this, parenthesis, options && options.implicit);\n        var paramStrings = this.params.map(function (p, index) {\n          var paramPrecedence = getPrecedence(p, parenthesis, options && options.implicit);\n          return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '(' + p.toString(options) + ')' : p.toString(options);\n        });\n        var ret = paramStrings[0];\n        for (var i = 0; i < this.conditionals.length; i++) {\n          ret += ' ' + operatorMap[this.conditionals[i]];\n          ret += ' ' + paramStrings[i + 1];\n        }\n        return ret;\n      }\n      /**\n       * Get a JSON representation of the node\n       * @returns {Object}\n       */\n    }, {\n      key: \"toJSON\",\n      value: function toJSON() {\n        return {\n          mathjs: name,\n          conditionals: this.conditionals,\n          params: this.params\n        };\n      }\n      /**\n       * Instantiate a RelationalNode from its JSON representation\n       * @param {Object} json\n       *     An object structured like\n       *     `{\"mathjs\": \"RelationalNode\", \"conditionals\": ..., \"params\": ...}`,\n       *     where mathjs is optional\n       * @returns {RelationalNode}\n       */\n    }, {\n      key: \"toHTML\",\n      /**\n       * Get HTML representation\n       * @param {Object} options\n       * @return {string} str\n       */\n      value: function toHTML(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var precedence = getPrecedence(this, parenthesis, options && options.implicit);\n        var paramStrings = this.params.map(function (p, index) {\n          var paramPrecedence = getPrecedence(p, parenthesis, options && options.implicit);\n          return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + p.toHTML(options) + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>' : p.toHTML(options);\n        });\n        var ret = paramStrings[0];\n        for (var i = 0; i < this.conditionals.length; i++) {\n          ret += '<span class=\"math-operator math-binary-operator ' + 'math-explicit-binary-operator\">' + escape(operatorMap[this.conditionals[i]]) + '</span>' + paramStrings[i + 1];\n        }\n        return ret;\n      }\n      /**\n       * Get LaTeX representation\n       * @param {Object} options\n       * @return {string} str\n       */\n    }, {\n      key: \"_toTex\",\n      value: function _toTex(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var precedence = getPrecedence(this, parenthesis, options && options.implicit);\n        var paramStrings = this.params.map(function (p, index) {\n          var paramPrecedence = getPrecedence(p, parenthesis, options && options.implicit);\n          return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '\\\\left(' + p.toTex(options) + '\\right)' : p.toTex(options);\n        });\n        var ret = paramStrings[0];\n        for (var i = 0; i < this.conditionals.length; i++) {\n          ret += latexOperators[this.conditionals[i]] + paramStrings[i + 1];\n        }\n        return ret;\n      }\n    }, {\n      key: \"type\",\n      get: function get() {\n        return name;\n      }\n    }, {\n      key: \"isRelationalNode\",\n      get: function get() {\n        return true;\n      }\n    }], [{\n      key: \"fromJSON\",\n      value: function fromJSON(json) {\n        return new RelationalNode(json.conditionals, json.params);\n      }\n    }]);\n    return RelationalNode;\n  }(Node);\n  _defineProperty(RelationalNode, \"name\", name);\n  return RelationalNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":null,"metadata":{},"sourceType":"module"}